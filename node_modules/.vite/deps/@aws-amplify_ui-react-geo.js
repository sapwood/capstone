import {
  map_default,
  useMap,
  use_control_default
} from "./chunk-ZZWUWGEV.js";
import {
  useSetUserAgent
} from "./chunk-ZFYDVO7N.js";
import {
  require_mapbox_gl_draw
} from "./chunk-PNQSKA4A.js";
import {
  BatchDeleteGeofenceCommand,
  BatchPutGeofenceCommand,
  GetGeofenceCommand,
  GetPlaceCommand,
  ListGeofencesCommand,
  LocationClient,
  SearchPlaceIndexForPositionCommand,
  SearchPlaceIndexForSuggestionsCommand,
  SearchPlaceIndexForTextCommand
} from "./chunk-NF6ZMNLY.js";
import {
  DefaultAmplify
} from "./chunk-5LMEXU6I.js";
import "./chunk-Y7SMNMTU.js";
import {
  Amplify,
  Category,
  ConsoleLogger,
  GeoAction,
  Hub,
  Signer,
  fetchAuthSession,
  getAmplifyUserAgent,
  getAmplifyUserAgentObject,
  jitteredExponentialRetry
} from "./chunk-6SW32IDD.js";
import "./chunk-73MXYMUK.js";
import "./chunk-GSZ7ISAW.js";
import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS({
  "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, maplibregl5;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
          var sharedChunk = {};
          shared(sharedChunk);
          maplibregl5 = chunk(sharedChunk);
          if (typeof window !== "undefined") {
            maplibregl5.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t) {
        "use strict";
        var e2 = r;
        function r(t2, e3, r2, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e3, this.by = 3 * (n2 - e3) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e3, this.p2x = r2, this.p2y = n2;
        }
        function n(t2, r2, n2, i2) {
          const s2 = new e2(t2, r2, n2, i2);
          return function(t3) {
            return s2.solve(t3);
          };
        }
        r.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e3) {
          if (void 0 === e3 && (e3 = 1e-6), t2 < 0)
            return 0;
          if (t2 > 1)
            return 1;
          for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e3)
              return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 1e-6)
              break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e3)); n2++)
            t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t2, e3) {
          return this.sampleCurveY(this.solveCurveX(t2, e3));
        } };
        const i = n(0.25, 0.1, 0.25, 1);
        function s(t2, e3, r2) {
          return Math.min(r2, Math.max(e3, t2));
        }
        function a(t2, e3, r2) {
          const n2 = r2 - e3, i2 = ((t2 - e3) % n2 + n2) % n2 + e3;
          return i2 === e3 ? r2 : i2;
        }
        function o(t2, ...e3) {
          for (const r2 of e3)
            for (const e4 in r2)
              t2[e4] = r2[e4];
          return t2;
        }
        let l = 1;
        function u(t2, e3) {
          t2.forEach((t3) => {
            e3[t3] && (e3[t3] = e3[t3].bind(e3));
          });
        }
        function c(t2, e3, r2) {
          const n2 = {};
          for (const i2 in t2)
            n2[i2] = e3.call(r2 || this, t2[i2], i2, t2);
          return n2;
        }
        function h(t2, e3, r2) {
          const n2 = {};
          for (const i2 in t2)
            e3.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
          return n2;
        }
        function p(t2) {
          return Array.isArray(t2) ? t2.map(p) : "object" == typeof t2 && t2 ? c(t2, p) : t2;
        }
        const f = {};
        function d(t2) {
          f[t2] || ("undefined" != typeof console && console.warn(t2), f[t2] = true);
        }
        function y(t2, e3, r2) {
          return (r2.y - t2.y) * (e3.x - t2.x) > (e3.y - t2.y) * (r2.x - t2.x);
        }
        function m(t2) {
          let e3 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
            r2 = t2[i2], n2 = t2[a2], e3 += (n2.x - r2.x) * (r2.y + n2.y);
          return e3;
        }
        function g() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function x(t2) {
          const e3 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
            const s2 = n2 || i2;
            return e3[r2] = !s2 || s2.toLowerCase(), "";
          }), e3["max-age"]) {
            const t3 = parseInt(e3["max-age"], 10);
            isNaN(t3) ? delete e3["max-age"] : e3["max-age"] = t3;
          }
          return e3;
        }
        let v, b, w = null;
        function _(t2) {
          if (null == w) {
            const e3 = t2.navigator ? t2.navigator.userAgent : null;
            w = !!t2.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
          }
          return w;
        }
        function A(t2) {
          return "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap;
        }
        const k = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t2) {
          const e3 = requestAnimationFrame(t2);
          return { cancel: () => cancelAnimationFrame(e3) };
        }, getImageData(t2, e3 = 0) {
          const r2 = window.document.createElement("canvas"), n2 = r2.getContext("2d");
          if (!n2)
            throw new Error("failed to create canvas 2d context");
          return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e3, -e3, t2.width + 2 * e3, t2.height + 2 * e3);
        }, resolveURL: (t2) => (v || (v = document.createElement("a")), v.href = t2, v.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (null == b && (b = matchMedia("(prefers-reduced-motion: reduce)")), b.matches);
        } };
        var S = z;
        function z(t2, e3) {
          this.x = t2, this.y = e3;
        }
        z.prototype = { clone: function() {
          return new z(this.x, this.y);
        }, add: function(t2) {
          return this.clone()._add(t2);
        }, sub: function(t2) {
          return this.clone()._sub(t2);
        }, multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        }, mult: function(t2) {
          return this.clone()._mult(t2);
        }, div: function(t2) {
          return this.clone()._div(t2);
        }, rotate: function(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround: function(t2, e3) {
          return this.clone()._rotateAround(t2, e3);
        }, matMult: function(t2) {
          return this.clone()._matMult(t2);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr: function(t2) {
          var e3 = t2.x - this.x, r2 = t2.y - this.y;
          return e3 * e3 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep: function(t2, e3) {
          return Math.atan2(this.x * e3 - this.y * t2, this.x * t2 + this.y * e3);
        }, _matMult: function(t2) {
          var e3 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e3, this;
        }, _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate: function(t2) {
          var e3 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e3 * this.y;
          return this.x = e3 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround: function(t2, e3) {
          var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e3.y + n2 * (this.x - e3.x) + r2 * (this.y - e3.y);
          return this.x = e3.x + r2 * (this.x - e3.x) - n2 * (this.y - e3.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, z.convert = function(t2) {
          return t2 instanceof z ? t2 : Array.isArray(t2) ? new z(t2[0], t2[1]) : t2;
        };
        const I = { MAX_PARALLEL_IMAGE_REQUESTS: 16, REGISTERED_PROTOCOLS: {} }, M = "mapbox-tiles";
        let B, C, P = 500, V = 50;
        function E() {
          "undefined" == typeof caches || B || (B = caches.open(M));
        }
        let F = 1 / 0;
        const T = { supported: false, testSupport: function(t2) {
          !$ && D && (R ? U(t2) : L = t2);
        } };
        let L, D, $ = false, R = false;
        function U(t2) {
          const e3 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e3);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, D), t2.isContextLost())
              return;
            T.supported = true;
          } catch (t3) {
          }
          t2.deleteTexture(e3), $ = true;
        }
        "undefined" != typeof document && (D = document.createElement("img"), D.onload = function() {
          L && U(L), L = null, R = true;
        }, D.onerror = function() {
          $ = true, L = null;
        }, D.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const O = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        "function" == typeof Object.freeze && Object.freeze(O);
        class q extends Error {
          constructor(t2, e3, r2, n2) {
            super(`AJAXError: ${e3} (${t2}): ${r2}`), this.status = t2, this.statusText = e3, this.url = r2, this.body = n2;
          }
        }
        const j = g() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href;
        function N(t2, e3) {
          const r2 = new AbortController(), n2 = new Request(t2.url, { method: t2.method || "GET", body: t2.body, credentials: t2.credentials, headers: t2.headers, referrer: j(), signal: r2.signal });
          let i2 = false, s2 = false;
          "json" === t2.type && n2.headers.set("Accept", "application/json");
          return ((r3, a2, o2) => {
            if (s2)
              return;
            const l2 = Date.now();
            fetch(n2).then((r4) => r4.ok ? ((r5, a3, o3) => {
              ("arrayBuffer" === t2.type ? r5.arrayBuffer() : "json" === t2.type ? r5.json() : r5.text()).then((t3) => {
                s2 || (a3 && o3 && function(t4, e4, r6) {
                  if (E(), !B)
                    return;
                  const n3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                  e4.headers.forEach((t5, e5) => n3.headers.set(e5, t5));
                  const i3 = x(e4.headers.get("Cache-Control") || "");
                  i3["no-store"] || (i3["max-age"] && n3.headers.set("Expires", new Date(r6 + 1e3 * i3["max-age"]).toUTCString()), new Date(n3.headers.get("Expires")).getTime() - r6 < 42e4 || function(t5, e5) {
                    if (void 0 === C)
                      try {
                        new Response(new ReadableStream()), C = true;
                      } catch (t6) {
                        C = false;
                      }
                    C ? e5(t5.body) : t5.blob().then(e5);
                  }(e4, (e5) => {
                    const r7 = new Response(e5, n3);
                    E(), B && B.then((e6) => e6.put(function(t5) {
                      const e7 = t5.indexOf("?");
                      return e7 < 0 ? t5 : t5.slice(0, e7);
                    }(t4.url), r7)).catch((t5) => d(t5.message));
                  }));
                }(n2, a3, o3), i2 = true, e3(null, t3, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
              }).catch((t3) => {
                s2 || e3(new Error(t3.message));
              });
            })(r4, null, l2) : r4.blob().then((n3) => e3(new q(r4.status, r4.statusText, t2.url, n3)))).catch((t3) => {
              20 !== t3.code && e3(new Error(t3.message));
            });
          })(), { cancel: () => {
            s2 = true, i2 || r2.abort();
          } };
        }
        const K = function(t2, e3) {
          if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
            if (g() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t2, e3);
            if (!g()) {
              const r3 = t2.url.substring(0, t2.url.indexOf("://"));
              return (I.REGISTERED_PROTOCOLS[r3] || N)(t2, e3);
            }
          }
          if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(j()) && !/^\w+:/.test(r2))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
              return N(t2, e3);
            if (g() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t2, e3, void 0, true);
          }
          var r2;
          return function(t3, e4) {
            const r3 = new XMLHttpRequest();
            r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
            for (const e5 in t3.headers)
              r3.setRequestHeader(e5, t3.headers[e5]);
            return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
              e4(new Error(r3.statusText));
            }, r3.onload = () => {
              if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                let n2 = r3.response;
                if ("json" === t3.type)
                  try {
                    n2 = JSON.parse(r3.response);
                  } catch (t4) {
                    return e4(t4);
                  }
                e4(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
              } else {
                const n2 = new Blob([r3.response], { type: r3.getResponseHeader("Content-Type") });
                e4(new q(r3.status, r3.statusText, t3.url, n2));
              }
            }, r3.send(t3.body), { cancel: () => r3.abort() };
          }(t2, e3);
        }, Z = function(t2, e3) {
          return K(o(t2, { type: "arrayBuffer" }), e3);
        };
        function G(t2) {
          const e3 = window.document.createElement("a");
          return e3.href = t2, e3.protocol === window.document.location.protocol && e3.host === window.document.location.host;
        }
        const J = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let X, Y;
        X = [], Y = 0;
        const H = function(t2, e3) {
          if (T.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), Y >= I.MAX_PARALLEL_IMAGE_REQUESTS) {
            const r3 = { requestParameters: t2, callback: e3, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return X.push(r3), r3;
          }
          Y++;
          let r2 = false;
          const n2 = () => {
            if (!r2)
              for (r2 = true, Y--; X.length && Y < I.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                const t3 = X.shift(), { requestParameters: e4, callback: r3, cancelled: n3 } = t3;
                n3 || (t3.cancel = H(e4, r3).cancel);
              }
          }, i2 = Z(t2, (t3, r3, i3, s2) => {
            n2(), t3 ? e3(t3) : r3 && function(t4, e4) {
              "function" == typeof createImageBitmap ? function(t5, e5) {
                const r4 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                createImageBitmap(r4).then((t6) => {
                  e5(null, t6);
                }).catch((t6) => {
                  e5(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                });
              }(t4, e4) : function(t5, e5) {
                const r4 = new Image();
                r4.onload = () => {
                  e5(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, window.requestAnimationFrame(() => {
                    r4.src = J;
                  });
                }, r4.onerror = () => e5(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                const n3 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                r4.src = t5.byteLength ? URL.createObjectURL(n3) : J;
              }(t4, e4);
            }(r3, (t4, r4) => {
              null != t4 ? e3(t4) : null != r4 && e3(null, r4, { cacheControl: i3, expires: s2 });
            });
          });
          return { cancel: () => {
            i2.cancel(), n2();
          } };
        };
        function W(t2, e3, r2) {
          r2[t2] && -1 !== r2[t2].indexOf(e3) || (r2[t2] = r2[t2] || [], r2[t2].push(e3));
        }
        function Q(t2, e3, r2) {
          if (r2 && r2[t2]) {
            const n2 = r2[t2].indexOf(e3);
            -1 !== n2 && r2[t2].splice(n2, 1);
          }
        }
        class tt {
          constructor(t2, e3 = {}) {
            o(this, e3), this.type = t2;
          }
        }
        class et extends tt {
          constructor(t2, e3 = {}) {
            super("error", o({ error: t2 }, e3));
          }
        }
        class rt {
          on(t2, e3) {
            return this._listeners = this._listeners || {}, W(t2, e3, this._listeners), this;
          }
          off(t2, e3) {
            return Q(t2, e3, this._listeners), Q(t2, e3, this._oneTimeListeners), this;
          }
          once(t2, e3) {
            return this._oneTimeListeners = this._oneTimeListeners || {}, W(t2, e3, this._oneTimeListeners), this;
          }
          fire(t2, e3) {
            "string" == typeof t2 && (t2 = new tt(t2, e3 || {}));
            const r2 = t2.type;
            if (this.listens(r2)) {
              t2.target = this;
              const e4 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
              for (const r3 of e4)
                r3.call(this, t2);
              const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
              for (const e5 of n2)
                Q(r2, e5, this._oneTimeListeners), e5.call(this, t2);
              const i2 = this._eventedParent;
              i2 && (o(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
            } else
              t2 instanceof et && console.error(t2.error);
            return this;
          }
          listens(t2) {
            return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
          }
          setEventedParent(t2, e3) {
            return this._eventedParent = t2, this._eventedParentData = e3, this;
          }
        }
        var nt = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        class it {
          constructor(t2, e3, r2, n2) {
            this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e3 && e3.__line__ && (this.line = e3.__line__);
          }
        }
        function st(t2) {
          const e3 = t2.value;
          return e3 ? [new it(t2.key, e3, "constants have been deprecated as of v8")] : [];
        }
        function at(t2, ...e3) {
          for (const r2 of e3)
            for (const e4 in r2)
              t2[e4] = r2[e4];
          return t2;
        }
        function ot(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function lt(t2) {
          if (Array.isArray(t2))
            return t2.map(lt);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            const e3 = {};
            for (const r2 in t2)
              e3[r2] = lt(t2[r2]);
            return e3;
          }
          return ot(t2);
        }
        class ut extends Error {
          constructor(t2, e3) {
            super(e3), this.message = e3, this.key = t2;
          }
        }
        class ct {
          constructor(t2, e3 = []) {
            this.parent = t2, this.bindings = {};
            for (const [t3, r2] of e3)
              this.bindings[t3] = r2;
          }
          concat(t2) {
            return new ct(this, t2);
          }
          get(t2) {
            if (this.bindings[t2])
              return this.bindings[t2];
            if (this.parent)
              return this.parent.get(t2);
            throw new Error(`${t2} not found in scope.`);
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        const ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "resolvedImage" };
        function wt(t2, e3) {
          return { kind: "array", itemType: t2, N: e3 };
        }
        function _t(t2) {
          if ("array" === t2.kind) {
            const e3 = _t(t2.itemType);
            return "number" == typeof t2.N ? `array<${e3}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e3}>`;
          }
          return t2.kind;
        }
        const At = [ht, pt, ft, dt, yt, vt, mt, wt(gt), bt];
        function kt(t2, e3) {
          if ("error" === e3.kind)
            return null;
          if ("array" === t2.kind) {
            if ("array" === e3.kind && (0 === e3.N && "value" === e3.itemType.kind || !kt(t2.itemType, e3.itemType)) && ("number" != typeof t2.N || t2.N === e3.N))
              return null;
          } else {
            if (t2.kind === e3.kind)
              return null;
            if ("value" === t2.kind) {
              for (const t3 of At)
                if (!kt(t3, e3))
                  return null;
            }
          }
          return `Expected ${_t(t2)} but found ${_t(e3)} instead.`;
        }
        function St(t2, e3) {
          return e3.some((e4) => e4.kind === t2.kind);
        }
        function zt(t2, e3) {
          return e3.some((e4) => "null" === e4 ? null === t2 : "array" === e4 ? Array.isArray(t2) : "object" === e4 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e4 === typeof t2);
        }
        var It, Mt = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function Bt(t2) {
          return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
        }
        function Ct(t2) {
          return Bt("%" === t2[t2.length - 1] ? parseFloat(t2) / 100 * 255 : parseInt(t2));
        }
        function Pt(t2) {
          return (e3 = "%" === t2[t2.length - 1] ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e3 > 1 ? 1 : e3;
          var e3;
        }
        function Vt(t2, e3, r2) {
          return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e3 - t2) * r2 * 6 : 2 * r2 < 1 ? e3 : 3 * r2 < 2 ? t2 + (e3 - t2) * (2 / 3 - r2) * 6 : t2;
        }
        try {
          It = {}.parseCSSColor = function(t2) {
            var e3, r2 = t2.replace(/ /g, "").toLowerCase();
            if (r2 in Mt)
              return Mt[r2].slice();
            if ("#" === r2[0])
              return 4 === r2.length ? (e3 = parseInt(r2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === r2.length && (e3 = parseInt(r2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
            var n2 = r2.indexOf("("), i2 = r2.indexOf(")");
            if (-1 !== n2 && i2 + 1 === r2.length) {
              var s2 = r2.substr(0, n2), a2 = r2.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
              switch (s2) {
                case "rgba":
                  if (4 !== a2.length)
                    return null;
                  o2 = Pt(a2.pop());
                case "rgb":
                  return 3 !== a2.length ? null : [Ct(a2[0]), Ct(a2[1]), Ct(a2[2]), o2];
                case "hsla":
                  if (4 !== a2.length)
                    return null;
                  o2 = Pt(a2.pop());
                case "hsl":
                  if (3 !== a2.length)
                    return null;
                  var l2 = (parseFloat(a2[0]) % 360 + 360) % 360 / 360, u2 = Pt(a2[1]), c2 = Pt(a2[2]), h2 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h2;
                  return [Bt(255 * Vt(p2, h2, l2 + 1 / 3)), Bt(255 * Vt(p2, h2, l2)), Bt(255 * Vt(p2, h2, l2 - 1 / 3)), o2];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t2) {
        }
        class Et {
          constructor(t2, e3, r2, n2 = 1) {
            this.r = t2, this.g = e3, this.b = r2, this.a = n2;
          }
          static parse(t2) {
            if (!t2)
              return;
            if (t2 instanceof Et)
              return t2;
            if ("string" != typeof t2)
              return;
            const e3 = It(t2);
            return e3 ? new Et(e3[0] / 255 * e3[3], e3[1] / 255 * e3[3], e3[2] / 255 * e3[3], e3[3]) : void 0;
          }
          toString() {
            const [t2, e3, r2, n2] = this.toArray();
            return `rgba(${Math.round(t2)},${Math.round(e3)},${Math.round(r2)},${n2})`;
          }
          toArray() {
            const { r: t2, g: e3, b: r2, a: n2 } = this;
            return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e3 / n2, 255 * r2 / n2, n2];
          }
        }
        Et.black = new Et(0, 0, 0, 1), Et.white = new Et(1, 1, 1, 1), Et.transparent = new Et(0, 0, 0, 0), Et.red = new Et(1, 0, 0, 1);
        class Ft {
          constructor(t2, e3, r2) {
            this.sensitivity = t2 ? e3 ? "variant" : "case" : e3 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e3) {
            return this.collator.compare(t2, e3);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Tt {
          constructor(t2, e3, r2, n2, i2) {
            this.text = t2, this.image = e3, this.scale = r2, this.fontStack = n2, this.textColor = i2;
          }
        }
        class Lt {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new Lt([new Tt(t2, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
          }
          static factory(t2) {
            return t2 instanceof Lt ? t2 : Lt.fromString(t2);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
          }
          serialize() {
            const t2 = ["format"];
            for (const e3 of this.sections) {
              if (e3.image) {
                t2.push(["image", e3.image.name]);
                continue;
              }
              t2.push(e3.text);
              const r2 = {};
              e3.fontStack && (r2["text-font"] = ["literal", e3.fontStack.split(",")]), e3.scale && (r2["font-scale"] = e3.scale), e3.textColor && (r2["text-color"] = ["rgba"].concat(e3.textColor.toArray())), t2.push(r2);
            }
            return t2;
          }
        }
        class Dt {
          constructor(t2) {
            this.name = t2.name, this.available = t2.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t2) {
            return t2 ? new Dt({ name: t2, available: false }) : null;
          }
          serialize() {
            return ["image", this.name];
          }
        }
        function $t(t2, e3, r2, n2) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e3 && e3 >= 0 && e3 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e3, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e3, r2, n2] : [t2, e3, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Rt(t2) {
          if (null === t2)
            return true;
          if ("string" == typeof t2)
            return true;
          if ("boolean" == typeof t2)
            return true;
          if ("number" == typeof t2)
            return true;
          if (t2 instanceof Et)
            return true;
          if (t2 instanceof Ft)
            return true;
          if (t2 instanceof Lt)
            return true;
          if (t2 instanceof Dt)
            return true;
          if (Array.isArray(t2)) {
            for (const e3 of t2)
              if (!Rt(e3))
                return false;
            return true;
          }
          if ("object" == typeof t2) {
            for (const e3 in t2)
              if (!Rt(t2[e3]))
                return false;
            return true;
          }
          return false;
        }
        function Ut(t2) {
          if (null === t2)
            return ht;
          if ("string" == typeof t2)
            return ft;
          if ("boolean" == typeof t2)
            return dt;
          if ("number" == typeof t2)
            return pt;
          if (t2 instanceof Et)
            return yt;
          if (t2 instanceof Ft)
            return xt;
          if (t2 instanceof Lt)
            return vt;
          if (t2 instanceof Dt)
            return bt;
          if (Array.isArray(t2)) {
            const e3 = t2.length;
            let r2;
            for (const e4 of t2) {
              const t3 = Ut(e4);
              if (r2) {
                if (r2 === t3)
                  continue;
                r2 = gt;
                break;
              }
              r2 = t3;
            }
            return wt(r2 || gt, e3);
          }
          return mt;
        }
        function Ot(t2) {
          const e3 = typeof t2;
          return null === t2 ? "" : "string" === e3 || "number" === e3 || "boolean" === e3 ? String(t2) : t2 instanceof Et || t2 instanceof Lt || t2 instanceof Dt ? t2.toString() : JSON.stringify(t2);
        }
        class qt {
          constructor(t2, e3) {
            this.type = t2, this.value = e3;
          }
          static parse(t2, e3) {
            if (2 !== t2.length)
              return e3.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (!Rt(t2[1]))
              return e3.error("invalid value");
            const r2 = t2[1];
            let n2 = Ut(r2);
            const i2 = e3.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new qt(n2, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Et ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Lt ? this.value.serialize() : this.value;
          }
        }
        class jt {
          constructor(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          }
          toJSON() {
            return this.message;
          }
        }
        const Nt = { string: ft, number: pt, boolean: dt, object: mt };
        class Kt {
          constructor(t2, e3) {
            this.type = t2, this.args = e3;
          }
          static parse(t2, e3) {
            if (t2.length < 2)
              return e3.error("Expected at least one argument.");
            let r2, n2 = 1;
            const i2 = t2[0];
            if ("array" === i2) {
              let i3, s3;
              if (t2.length > 2) {
                const r3 = t2[1];
                if ("string" != typeof r3 || !(r3 in Nt) || "object" === r3)
                  return e3.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = Nt[r3], n2++;
              } else
                i3 = gt;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                  return e3.error('The length argument to "array" must be a positive integer literal', 2);
                s3 = t2[2], n2++;
              }
              r2 = wt(i3, s3);
            } else
              r2 = Nt[i2];
            const s2 = [];
            for (; n2 < t2.length; n2++) {
              const r3 = e3.parse(t2[n2], n2, gt);
              if (!r3)
                return null;
              s2.push(r3);
            }
            return new Kt(r2, s2);
          }
          evaluate(t2) {
            for (let e3 = 0; e3 < this.args.length; e3++) {
              const r2 = this.args[e3].evaluate(t2);
              if (!kt(this.type, Ut(r2)))
                return r2;
              if (e3 === this.args.length - 1)
                throw new jt(`Expected value to be of type ${_t(this.type)}, but found ${_t(Ut(r2))} instead.`);
            }
            return null;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = this.type, e3 = [t2.kind];
            if ("array" === t2.kind) {
              const r2 = t2.itemType;
              if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
                e3.push(r2.kind);
                const n2 = t2.N;
                ("number" == typeof n2 || this.args.length > 1) && e3.push(n2);
              }
            }
            return e3.concat(this.args.map((t3) => t3.serialize()));
          }
        }
        class Zt {
          constructor(t2) {
            this.type = vt, this.sections = t2;
          }
          static parse(t2, e3) {
            if (t2.length < 2)
              return e3.error("Expected at least one argument.");
            const r2 = t2[1];
            if (!Array.isArray(r2) && "object" == typeof r2)
              return e3.error("First argument must be an image or text section.");
            const n2 = [];
            let i2 = false;
            for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
              const s2 = t2[r3];
              if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                i2 = false;
                let t3 = null;
                if (s2["font-scale"] && (t3 = e3.parse(s2["font-scale"], 1, pt), !t3))
                  return null;
                let r4 = null;
                if (s2["text-font"] && (r4 = e3.parse(s2["text-font"], 1, wt(ft)), !r4))
                  return null;
                let a2 = null;
                if (s2["text-color"] && (a2 = e3.parse(s2["text-color"], 1, yt), !a2))
                  return null;
                const o2 = n2[n2.length - 1];
                o2.scale = t3, o2.font = r4, o2.textColor = a2;
              } else {
                const s3 = e3.parse(t2[r3], 1, gt);
                if (!s3)
                  return null;
                const a2 = s3.type.kind;
                if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                  return e3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
              }
            }
            return new Zt(n2);
          }
          evaluate(t2) {
            return new Lt(this.sections.map((e3) => {
              const r2 = e3.content.evaluate(t2);
              return Ut(r2) === bt ? new Tt("", r2, null, null, null) : new Tt(Ot(r2), null, e3.scale ? e3.scale.evaluate(t2) : null, e3.font ? e3.font.evaluate(t2).join(",") : null, e3.textColor ? e3.textColor.evaluate(t2) : null);
            }));
          }
          eachChild(t2) {
            for (const e3 of this.sections)
              t2(e3.content), e3.scale && t2(e3.scale), e3.font && t2(e3.font), e3.textColor && t2(e3.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["format"];
            for (const e3 of this.sections) {
              t2.push(e3.content.serialize());
              const r2 = {};
              e3.scale && (r2["font-scale"] = e3.scale.serialize()), e3.font && (r2["text-font"] = e3.font.serialize()), e3.textColor && (r2["text-color"] = e3.textColor.serialize()), t2.push(r2);
            }
            return t2;
          }
        }
        class Gt {
          constructor(t2) {
            this.type = bt, this.input = t2;
          }
          static parse(t2, e3) {
            if (2 !== t2.length)
              return e3.error("Expected two arguments.");
            const r2 = e3.parse(t2[1], 1, ft);
            return r2 ? new Gt(r2) : e3.error("No image name provided.");
          }
          evaluate(t2) {
            const e3 = this.input.evaluate(t2), r2 = Dt.fromString(e3);
            return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e3) > -1), r2;
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["image", this.input.serialize()];
          }
        }
        const Jt = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
        class Xt {
          constructor(t2, e3) {
            this.type = t2, this.args = e3;
          }
          static parse(t2, e3) {
            if (t2.length < 2)
              return e3.error("Expected at least one argument.");
            const r2 = t2[0];
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
              return e3.error("Expected one argument.");
            const n2 = Jt[r2], i2 = [];
            for (let r3 = 1; r3 < t2.length; r3++) {
              const n3 = e3.parse(t2[r3], r3, gt);
              if (!n3)
                return null;
              i2.push(n3);
            }
            return new Xt(n2, i2);
          }
          evaluate(t2) {
            if ("boolean" === this.type.kind)
              return Boolean(this.args[0].evaluate(t2));
            if ("color" === this.type.kind) {
              let e3, r2;
              for (const n2 of this.args) {
                if (e3 = n2.evaluate(t2), r2 = null, e3 instanceof Et)
                  return e3;
                if ("string" == typeof e3) {
                  const r3 = t2.parseColor(e3);
                  if (r3)
                    return r3;
                } else if (Array.isArray(e3) && (r2 = e3.length < 3 || e3.length > 4 ? `Invalid rbga value ${JSON.stringify(e3)}: expected an array containing either three or four numeric values.` : $t(e3[0], e3[1], e3[2], e3[3]), !r2))
                  return new Et(e3[0] / 255, e3[1] / 255, e3[2] / 255, e3[3]);
              }
              throw new jt(r2 || `Could not parse color from value '${"string" == typeof e3 ? e3 : String(JSON.stringify(e3))}'`);
            }
            if ("number" === this.type.kind) {
              let e3 = null;
              for (const r2 of this.args) {
                if (e3 = r2.evaluate(t2), null === e3)
                  return 0;
                const n2 = Number(e3);
                if (!isNaN(n2))
                  return n2;
              }
              throw new jt(`Could not convert ${JSON.stringify(e3)} to number.`);
            }
            return "formatted" === this.type.kind ? Lt.fromString(Ot(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Dt.fromString(Ot(this.args[0].evaluate(t2))) : Ot(this.args[0].evaluate(t2));
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            if ("formatted" === this.type.kind)
              return new Zt([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind)
              return new Gt(this.args[0]).serialize();
            const t2 = [`to-${this.type.kind}`];
            return this.eachChild((e3) => {
              t2.push(e3.serialize());
            }), t2;
          }
        }
        const Yt = ["Unknown", "Point", "LineString", "Polygon"];
        class Ht {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Yt[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t2) {
            let e3 = this._parseColorCache[t2];
            return e3 || (e3 = this._parseColorCache[t2] = Et.parse(t2)), e3;
          }
        }
        class Wt {
          constructor(t2, e3, r2, n2) {
            this.name = t2, this.type = e3, this._evaluate = r2, this.args = n2;
          }
          evaluate(t2) {
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t2) => t2.serialize()));
          }
          static parse(t2, e3) {
            const r2 = t2[0], n2 = Wt.definitions[r2];
            if (!n2)
              return e3.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e4]) => !Array.isArray(e4) || e4.length === t2.length - 1);
            let o2 = null;
            for (const [n3, s3] of a2) {
              o2 = new we(e3.registry, e3.path, null, e3.scope);
              const a3 = [];
              let l2 = false;
              for (let e4 = 1; e4 < t2.length; e4++) {
                const r3 = t2[e4], i3 = Array.isArray(n3) ? n3[e4 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
                if (!s4) {
                  l2 = true;
                  break;
                }
                a3.push(s4);
              }
              if (!l2)
                if (Array.isArray(n3) && n3.length !== a3.length)
                  o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
                else {
                  for (let t3 = 0; t3 < a3.length; t3++) {
                    const e4 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                    o2.concat(t3 + 1).checkSubtype(e4, r3.type);
                  }
                  if (0 === o2.errors.length)
                    return new Wt(r2, i2, s3, a3);
                }
            }
            if (1 === a2.length)
              e3.errors.push(...o2.errors);
            else {
              const r3 = (a2.length ? a2 : s2).map(([t3]) => {
                return e4 = t3, Array.isArray(e4) ? `(${e4.map(_t).join(", ")})` : `(${_t(e4.type)}...)`;
                var e4;
              }).join(" | "), n3 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                const i3 = e3.parse(t2[r4], 1 + n3.length);
                if (!i3)
                  return null;
                n3.push(_t(i3.type));
              }
              e3.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t2, e3) {
            Wt.definitions = e3;
            for (const r2 in e3)
              t2[r2] = Wt;
          }
        }
        class Qt {
          constructor(t2, e3, r2) {
            this.type = xt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e3;
          }
          static parse(t2, e3) {
            if (2 !== t2.length)
              return e3.error("Expected one argument.");
            const r2 = t2[1];
            if ("object" != typeof r2 || Array.isArray(r2))
              return e3.error("Collator options argument must be an object.");
            const n2 = e3.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, dt);
            if (!n2)
              return null;
            const i2 = e3.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, dt);
            if (!i2)
              return null;
            let s2 = null;
            return r2.locale && (s2 = e3.parse(r2.locale, 1, ft), !s2) ? null : new Qt(n2, i2, s2);
          }
          evaluate(t2) {
            return new Ft(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
          }
        }
        const te = 8192;
        function ee(t2, e3) {
          t2[0] = Math.min(t2[0], e3[0]), t2[1] = Math.min(t2[1], e3[1]), t2[2] = Math.max(t2[2], e3[0]), t2[3] = Math.max(t2[3], e3[1]);
        }
        function re(t2, e3) {
          return !(t2[0] <= e3[0] || t2[2] >= e3[2] || t2[1] <= e3[1] || t2[3] >= e3[3]);
        }
        function ne(t2, e3) {
          const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e3.z);
          return [Math.round(r2 * i2 * te), Math.round(n2 * i2 * te)];
        }
        function ie(t2, e3, r2) {
          const n2 = t2[0] - e3[0], i2 = t2[1] - e3[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
          return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
        }
        function se(t2, e3) {
          let r2 = false;
          for (let a2 = 0, o2 = e3.length; a2 < o2; a2++) {
            const o3 = e3[a2];
            for (let e4 = 0, a3 = o3.length; e4 < a3 - 1; e4++) {
              if (ie(t2, o3[e4], o3[e4 + 1]))
                return false;
              (i2 = o3[e4])[1] > (n2 = t2)[1] != (s2 = o3[e4 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r2 = !r2);
            }
          }
          var n2, i2, s2;
          return r2;
        }
        function ae(t2, e3) {
          for (let r2 = 0; r2 < e3.length; r2++)
            if (se(t2, e3[r2]))
              return true;
          return false;
        }
        function oe(t2, e3, r2, n2) {
          const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e3[0] - r2[0]) * s2 - i2 * (e3[1] - r2[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function le(t2, e3, r2) {
          for (const u2 of r2)
            for (let r3 = 0; r3 < u2.length - 1; ++r3)
              if (0 != (o2 = [(a2 = u2[r3 + 1])[0] - (s2 = u2[r3])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e3)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] && oe(n2, i2, s2, a2) && oe(s2, a2, n2, i2))
                return true;
          var n2, i2, s2, a2, o2, l2;
          return false;
        }
        function ue(t2, e3) {
          for (let r2 = 0; r2 < t2.length; ++r2)
            if (!se(t2[r2], e3))
              return false;
          for (let r2 = 0; r2 < t2.length - 1; ++r2)
            if (le(t2[r2], t2[r2 + 1], e3))
              return false;
          return true;
        }
        function ce(t2, e3) {
          for (let r2 = 0; r2 < e3.length; r2++)
            if (ue(t2, e3[r2]))
              return true;
          return false;
        }
        function he(t2, e3, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = [];
            for (let n3 = 0; n3 < t2[i2].length; n3++) {
              const a2 = ne(t2[i2][n3], r2);
              ee(e3, a2), s2.push(a2);
            }
            n2.push(s2);
          }
          return n2;
        }
        function pe(t2, e3, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = he(t2[i2], e3, r2);
            n2.push(s2);
          }
          return n2;
        }
        function fe(t2, e3, r2, n2) {
          if (t2[0] < r2[0] || t2[0] > r2[2]) {
            const e4 = 0.5 * n2;
            let i2 = t2[0] - r2[0] > e4 ? -n2 : r2[0] - t2[0] > e4 ? n2 : 0;
            0 === i2 && (i2 = t2[0] - r2[2] > e4 ? -n2 : r2[2] - t2[0] > e4 ? n2 : 0), t2[0] += i2;
          }
          ee(e3, t2);
        }
        function de(t2, e3, r2, n2) {
          const i2 = Math.pow(2, n2.z) * te, s2 = [n2.x * te, n2.y * te], a2 = [];
          for (const n3 of t2)
            for (const t3 of n3) {
              const n4 = [t3.x + s2[0], t3.y + s2[1]];
              fe(n4, e3, r2, i2), a2.push(n4);
            }
          return a2;
        }
        function ye(t2, e3, r2, n2) {
          const i2 = Math.pow(2, n2.z) * te, s2 = [n2.x * te, n2.y * te], a2 = [];
          for (const r3 of t2) {
            const t3 = [];
            for (const n3 of r3) {
              const r4 = [n3.x + s2[0], n3.y + s2[1]];
              ee(e3, r4), t3.push(r4);
            }
            a2.push(t3);
          }
          if (e3[2] - e3[0] <= i2 / 2) {
            (o2 = e3)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t3 of a2)
              for (const n3 of t3)
                fe(n3, e3, r2, i2);
          }
          var o2;
          return a2;
        }
        class me {
          constructor(t2, e3) {
            this.type = dt, this.geojson = t2, this.geometries = e3;
          }
          static parse(t2, e3) {
            if (2 !== t2.length)
              return e3.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (Rt(t2[1])) {
              const e4 = t2[1];
              if ("FeatureCollection" === e4.type)
                for (let t3 = 0; t3 < e4.features.length; ++t3) {
                  const r2 = e4.features[t3].geometry.type;
                  if ("Polygon" === r2 || "MultiPolygon" === r2)
                    return new me(e4, e4.features[t3].geometry);
                }
              else if ("Feature" === e4.type) {
                const t3 = e4.geometry.type;
                if ("Polygon" === t3 || "MultiPolygon" === t3)
                  return new me(e4, e4.geometry);
              } else if ("Polygon" === e4.type || "MultiPolygon" === e4.type)
                return new me(e4, e4);
            }
            return e3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType())
                return function(t3, e3) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e3.type) {
                    const s2 = he(e3.coordinates, n2, i2), a2 = de(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!se(t4, s2))
                        return false;
                  }
                  if ("MultiPolygon" === e3.type) {
                    const s2 = pe(e3.coordinates, n2, i2), a2 = de(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!ae(t4, s2))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
              if ("LineString" === t2.geometryType())
                return function(t3, e3) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e3.type) {
                    const s2 = he(e3.coordinates, n2, i2), a2 = ye(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!ue(t4, s2))
                        return false;
                  }
                  if ("MultiPolygon" === e3.type) {
                    const s2 = pe(e3.coordinates, n2, i2), a2 = ye(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!ce(t4, s2))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        function ge(t2) {
          if (t2 instanceof Wt) {
            if ("get" === t2.name && 1 === t2.args.length)
              return false;
            if ("feature-state" === t2.name)
              return false;
            if ("has" === t2.name && 1 === t2.args.length)
              return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
              return false;
            if (/^filter-/.test(t2.name))
              return false;
          }
          if (t2 instanceof me)
            return false;
          let e3 = true;
          return t2.eachChild((t3) => {
            e3 && !ge(t3) && (e3 = false);
          }), e3;
        }
        function xe(t2) {
          if (t2 instanceof Wt && "feature-state" === t2.name)
            return false;
          let e3 = true;
          return t2.eachChild((t3) => {
            e3 && !xe(t3) && (e3 = false);
          }), e3;
        }
        function ve(t2, e3) {
          if (t2 instanceof Wt && e3.indexOf(t2.name) >= 0)
            return false;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 && !ve(t3, e3) && (r2 = false);
          }), r2;
        }
        class be {
          constructor(t2, e3) {
            this.type = e3.type, this.name = t2, this.boundExpression = e3;
          }
          static parse(t2, e3) {
            if (2 !== t2.length || "string" != typeof t2[1])
              return e3.error("'var' expression requires exactly one string literal argument.");
            const r2 = t2[1];
            return e3.scope.has(r2) ? new be(r2, e3.scope.get(r2)) : e3.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        class we {
          constructor(t2, e3 = [], r2, n2 = new ct(), i2 = []) {
            this.registry = t2, this.path = e3, this.key = e3.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
          }
          parse(t2, e3, r2, n2, i2 = {}) {
            return e3 ? this.concat(e3, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
          }
          _parse(t2, e3) {
            function r2(t3, e4, r3) {
              return "assert" === r3 ? new Kt(e4, [t3]) : "coerce" === r3 ? new Xt(e4, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = t2[0];
              if ("string" != typeof n2)
                return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i2 = this.registry[n2];
              if (i2) {
                let n3 = i2.parse(t2, this);
                if (!n3)
                  return null;
                if (this.expectedType) {
                  const t3 = this.expectedType, i3 = n3.type;
                  if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind)
                    if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind) {
                      if (this.checkSubtype(t3, i3))
                        return null;
                    } else
                      n3 = r2(n3, t3, e3.typeAnnotation || "coerce");
                  else
                    n3 = r2(n3, t3, e3.typeAnnotation || "assert");
                }
                if (!(n3 instanceof qt) && "resolvedImage" !== n3.type.kind && _e(n3)) {
                  const t3 = new Ht();
                  try {
                    n3 = new qt(n3.type, n3.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return n3;
              }
              return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
          }
          concat(t2, e3, r2) {
            const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
            return new we(this.registry, n2, e3 || null, i2, this.errors);
          }
          error(t2, ...e3) {
            const r2 = `${this.key}${e3.map((t3) => `[${t3}]`).join("")}`;
            this.errors.push(new ut(r2, t2));
          }
          checkSubtype(t2, e3) {
            const r2 = kt(t2, e3);
            return r2 && this.error(r2), r2;
          }
        }
        function _e(t2) {
          if (t2 instanceof be)
            return _e(t2.boundExpression);
          if (t2 instanceof Wt && "error" === t2.name)
            return false;
          if (t2 instanceof Qt)
            return false;
          if (t2 instanceof me)
            return false;
          const e3 = t2 instanceof Xt || t2 instanceof Kt;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 = e3 ? r2 && _e(t3) : r2 && t3 instanceof qt;
          }), !!r2 && ge(t2) && ve(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Ae(t2, e3) {
          const r2 = t2.length - 1;
          let n2, i2, s2 = 0, a2 = r2, o2 = 0;
          for (; s2 <= a2; )
            if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e3) {
              if (o2 === r2 || e3 < i2)
                return o2;
              s2 = o2 + 1;
            } else {
              if (!(n2 > e3))
                throw new jt("Input is not a number.");
              a2 = o2 - 1;
            }
          return 0;
        }
        class ke {
          constructor(t2, e3, r2) {
            this.type = t2, this.input = e3, this.labels = [], this.outputs = [];
            for (const [t3, e4] of r2)
              this.labels.push(t3), this.outputs.push(e4);
          }
          static parse(t2, e3) {
            if (t2.length - 1 < 4)
              return e3.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e3.error("Expected an even number of arguments.");
            const r2 = e3.parse(t2[1], 1, pt);
            if (!r2)
              return null;
            const n2 = [];
            let i2 = null;
            e3.expectedType && "value" !== e3.expectedType.kind && (i2 = e3.expectedType);
            for (let r3 = 1; r3 < t2.length; r3 += 2) {
              const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
              if ("number" != typeof s2)
                return e3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= s2)
                return e3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e3.parse(a2, l2, i2);
              if (!u2)
                return null;
              i2 = i2 || u2.type, n2.push([s2, u2]);
            }
            return new ke(i2, r2, n2);
          }
          evaluate(t2) {
            const e3 = this.labels, r2 = this.outputs;
            if (1 === e3.length)
              return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e3[0])
              return r2[0].evaluate(t2);
            const i2 = e3.length;
            return n2 >= e3[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Ae(e3, n2)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (const e3 of this.outputs)
              t2(e3);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["step", this.input.serialize()];
            for (let e3 = 0; e3 < this.labels.length; e3++)
              e3 > 0 && t2.push(this.labels[e3]), t2.push(this.outputs[e3].serialize());
            return t2;
          }
        }
        function Se(t2, e3, r2) {
          return t2 * (1 - r2) + e3 * r2;
        }
        var ze = Object.freeze({ __proto__: null, number: Se, color: function(t2, e3, r2) {
          return new Et(Se(t2.r, e3.r, r2), Se(t2.g, e3.g, r2), Se(t2.b, e3.b, r2), Se(t2.a, e3.a, r2));
        }, array: function(t2, e3, r2) {
          return t2.map((t3, n2) => Se(t3, e3[n2], r2));
        } });
        const Ie = 0.95047, Me = 1.08883, Be = 4 / 29, Ce = 6 / 29, Pe = 3 * Ce * Ce, Ve = Math.PI / 180, Ee = 180 / Math.PI;
        function Fe(t2) {
          return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Pe + Be;
        }
        function Te(t2) {
          return t2 > Ce ? t2 * t2 * t2 : Pe * (t2 - Be);
        }
        function Le(t2) {
          return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
        }
        function De(t2) {
          return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function $e(t2) {
          const e3 = De(t2.r), r2 = De(t2.g), n2 = De(t2.b), i2 = Fe((0.4124564 * e3 + 0.3575761 * r2 + 0.1804375 * n2) / Ie), s2 = Fe((0.2126729 * e3 + 0.7151522 * r2 + 0.072175 * n2) / 1);
          return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Fe((0.0193339 * e3 + 0.119192 * r2 + 0.9503041 * n2) / Me)), alpha: t2.a };
        }
        function Re(t2) {
          let e3 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e3 : e3 + t2.a / 500, n2 = isNaN(t2.b) ? e3 : e3 - t2.b / 200;
          return e3 = 1 * Te(e3), r2 = Ie * Te(r2), n2 = Me * Te(n2), new Et(Le(3.2404542 * r2 - 1.5371385 * e3 - 0.4985314 * n2), Le(-0.969266 * r2 + 1.8760108 * e3 + 0.041556 * n2), Le(0.0556434 * r2 - 0.2040259 * e3 + 1.0572252 * n2), t2.alpha);
        }
        function Ue(t2, e3, r2) {
          const n2 = e3 - t2;
          return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
        }
        const Oe = { forward: $e, reverse: Re, interpolate: function(t2, e3, r2) {
          return { l: Se(t2.l, e3.l, r2), a: Se(t2.a, e3.a, r2), b: Se(t2.b, e3.b, r2), alpha: Se(t2.alpha, e3.alpha, r2) };
        } }, qe = { forward: function(t2) {
          const { l: e3, a: r2, b: n2 } = $e(t2), i2 = Math.atan2(n2, r2) * Ee;
          return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e3, alpha: t2.a };
        }, reverse: function(t2) {
          const e3 = t2.h * Ve, r2 = t2.c;
          return Re({ l: t2.l, a: Math.cos(e3) * r2, b: Math.sin(e3) * r2, alpha: t2.alpha });
        }, interpolate: function(t2, e3, r2) {
          return { h: Ue(t2.h, e3.h, r2), c: Se(t2.c, e3.c, r2), l: Se(t2.l, e3.l, r2), alpha: Se(t2.alpha, e3.alpha, r2) };
        } };
        var je = Object.freeze({ __proto__: null, lab: Oe, hcl: qe });
        class Ne {
          constructor(t2, e3, r2, n2, i2) {
            this.type = t2, this.operator = e3, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t3, e4] of i2)
              this.labels.push(t3), this.outputs.push(e4);
          }
          static interpolationFactor(t2, r2, n2, i2) {
            let s2 = 0;
            if ("exponential" === t2.name)
              s2 = Ke(r2, t2.base, n2, i2);
            else if ("linear" === t2.name)
              s2 = Ke(r2, 1, n2, i2);
            else if ("cubic-bezier" === t2.name) {
              const a2 = t2.controlPoints;
              s2 = new e2(a2[0], a2[1], a2[2], a2[3]).solve(Ke(r2, 1, n2, i2));
            }
            return s2;
          }
          static parse(t2, e3) {
            let [r2, n2, i2, ...s2] = t2;
            if (!Array.isArray(n2) || 0 === n2.length)
              return e3.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0])
              n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              const t3 = n2[1];
              if ("number" != typeof t3)
                return e3.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t3 };
            } else {
              if ("cubic-bezier" !== n2[0])
                return e3.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                const t3 = n2.slice(1);
                if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                  return e3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4)
              return e3.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e3.error("Expected an even number of arguments.");
            if (i2 = e3.parse(i2, 2, pt), !i2)
              return null;
            const a2 = [];
            let o2 = null;
            "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = yt : e3.expectedType && "value" !== e3.expectedType.kind && (o2 = e3.expectedType);
            for (let t3 = 0; t3 < s2.length; t3 += 2) {
              const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
              if ("number" != typeof r3)
                return e3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (a2.length && a2[a2.length - 1][0] >= r3)
                return e3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              const u2 = e3.parse(n3, l2, o2);
              if (!u2)
                return null;
              o2 = o2 || u2.type, a2.push([r3, u2]);
            }
            return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new Ne(o2, r2, n2, i2, a2) : e3.error(`Type ${_t(o2)} is not interpolatable.`);
          }
          evaluate(t2) {
            const e3 = this.labels, r2 = this.outputs;
            if (1 === e3.length)
              return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e3[0])
              return r2[0].evaluate(t2);
            const i2 = e3.length;
            if (n2 >= e3[i2 - 1])
              return r2[i2 - 1].evaluate(t2);
            const s2 = Ae(e3, n2), a2 = Ne.interpolationFactor(this.interpolation, n2, e3[s2], e3[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
            return "interpolate" === this.operator ? ze[this.type.kind.toLowerCase()](o2, l2, a2) : "interpolate-hcl" === this.operator ? qe.reverse(qe.interpolate(qe.forward(o2), qe.forward(l2), a2)) : Oe.reverse(Oe.interpolate(Oe.forward(o2), Oe.forward(l2), a2));
          }
          eachChild(t2) {
            t2(this.input);
            for (const e3 of this.outputs)
              t2(e3);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            let t2;
            t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const e3 = [this.operator, t2, this.input.serialize()];
            for (let t3 = 0; t3 < this.labels.length; t3++)
              e3.push(this.labels[t3], this.outputs[t3].serialize());
            return e3;
          }
        }
        function Ke(t2, e3, r2, n2) {
          const i2 = n2 - r2, s2 = t2 - r2;
          return 0 === i2 ? 0 : 1 === e3 ? s2 / i2 : (Math.pow(e3, s2) - 1) / (Math.pow(e3, i2) - 1);
        }
        class Ze {
          constructor(t2, e3) {
            this.type = t2, this.args = e3;
          }
          static parse(t2, e3) {
            if (t2.length < 2)
              return e3.error("Expectected at least one argument.");
            let r2 = null;
            const n2 = e3.expectedType;
            n2 && "value" !== n2.kind && (r2 = n2);
            const i2 = [];
            for (const n3 of t2.slice(1)) {
              const t3 = e3.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t3)
                return null;
              r2 = r2 || t3.type, i2.push(t3);
            }
            const s2 = n2 && i2.some((t3) => kt(n2, t3.type));
            return new Ze(s2 ? gt : r2, i2);
          }
          evaluate(t2) {
            let e3, r2 = null, n2 = 0;
            for (const i2 of this.args)
              if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Dt && !r2.available && (e3 || (e3 = r2.name), r2 = null, n2 === this.args.length && (r2 = e3)), null !== r2)
                break;
            return r2;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["coalesce"];
            return this.eachChild((e3) => {
              t2.push(e3.serialize());
            }), t2;
          }
        }
        class Ge {
          constructor(t2, e3) {
            this.type = e3.type, this.bindings = [].concat(t2), this.result = e3;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (const e3 of this.bindings)
              t2(e3[1]);
            t2(this.result);
          }
          static parse(t2, e3) {
            if (t2.length < 4)
              return e3.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
            const r2 = [];
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
              const i2 = t2[n3];
              if ("string" != typeof i2)
                return e3.error(`Expected string, but found ${typeof i2} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i2))
                return e3.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const s2 = e3.parse(t2[n3 + 1], n3 + 1);
              if (!s2)
                return null;
              r2.push([i2, s2]);
            }
            const n2 = e3.parse(t2[t2.length - 1], t2.length - 1, e3.expectedType, r2);
            return n2 ? new Ge(r2, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t2 = ["let"];
            for (const [e3, r2] of this.bindings)
              t2.push(e3, r2.serialize());
            return t2.push(this.result.serialize()), t2;
          }
        }
        class Je {
          constructor(t2, e3, r2) {
            this.type = t2, this.index = e3, this.input = r2;
          }
          static parse(t2, e3) {
            if (3 !== t2.length)
              return e3.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e3.parse(t2[1], 1, pt), n2 = e3.parse(t2[2], 2, wt(e3.expectedType || gt));
            return r2 && n2 ? new Je(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t2) {
            const e3 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e3 < 0)
              throw new jt(`Array index out of bounds: ${e3} < 0.`);
            if (e3 >= r2.length)
              throw new jt(`Array index out of bounds: ${e3} > ${r2.length - 1}.`);
            if (e3 !== Math.floor(e3))
              throw new jt(`Array index must be an integer, but found ${e3} instead.`);
            return r2[e3];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        class Xe {
          constructor(t2, e3) {
            this.type = dt, this.needle = t2, this.haystack = e3;
          }
          static parse(t2, e3) {
            if (3 !== t2.length)
              return e3.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e3.parse(t2[1], 1, gt), n2 = e3.parse(t2[2], 2, gt);
            return r2 && n2 ? St(r2.type, [dt, ft, pt, ht, gt]) ? new Xe(r2, n2) : e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r2.type)} instead`) : null;
          }
          evaluate(t2) {
            const e3 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!r2)
              return false;
            if (!zt(e3, ["boolean", "string", "number", "null"]))
              throw new jt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Ut(e3))} instead.`);
            if (!zt(r2, ["string", "array"]))
              throw new jt(`Expected second argument to be of type array or string, but found ${_t(Ut(r2))} instead.`);
            return r2.indexOf(e3) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class Ye {
          constructor(t2, e3, r2) {
            this.type = pt, this.needle = t2, this.haystack = e3, this.fromIndex = r2;
          }
          static parse(t2, e3) {
            if (t2.length <= 2 || t2.length >= 5)
              return e3.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e3.parse(t2[1], 1, gt), n2 = e3.parse(t2[2], 2, gt);
            if (!r2 || !n2)
              return null;
            if (!St(r2.type, [dt, ft, pt, ht, gt]))
              return e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e3.parse(t2[3], 3, pt);
              return i2 ? new Ye(r2, n2, i2) : null;
            }
            return new Ye(r2, n2);
          }
          evaluate(t2) {
            const e3 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!zt(e3, ["boolean", "string", "number", "null"]))
              throw new jt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Ut(e3))} instead.`);
            if (!zt(r2, ["string", "array"]))
              throw new jt(`Expected second argument to be of type array or string, but found ${_t(Ut(r2))} instead.`);
            if (this.fromIndex) {
              const n2 = this.fromIndex.evaluate(t2);
              return r2.indexOf(e3, n2);
            }
            return r2.indexOf(e3);
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              const t2 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class He {
          constructor(t2, e3, r2, n2, i2, s2) {
            this.inputType = t2, this.type = e3, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
          }
          static parse(t2, e3) {
            if (t2.length < 5)
              return e3.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 1)
              return e3.error("Expected an even number of arguments.");
            let r2, n2;
            e3.expectedType && "value" !== e3.expectedType.kind && (n2 = e3.expectedType);
            const i2 = {}, s2 = [];
            for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
              let o3 = t2[a3];
              const l2 = t2[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e3.concat(a3);
              if (0 === o3.length)
                return u2.error("Expected at least one branch label.");
              for (const t3 of o3) {
                if ("number" != typeof t3 && "string" != typeof t3)
                  return u2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                  return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t3 && Math.floor(t3) !== t3)
                  return u2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u2.checkSubtype(r2, Ut(t3)))
                    return null;
                } else
                  r2 = Ut(t3);
                if (void 0 !== i2[String(t3)])
                  return u2.error("Branch labels must be unique.");
                i2[String(t3)] = s2.length;
              }
              const c2 = e3.parse(l2, a3, n2);
              if (!c2)
                return null;
              n2 = n2 || c2.type, s2.push(c2);
            }
            const a2 = e3.parse(t2[1], 1, gt);
            if (!a2)
              return null;
            const o2 = e3.parse(t2[t2.length - 1], t2.length - 1, n2);
            return o2 ? "value" !== a2.type.kind && e3.concat(1).checkSubtype(r2, a2.type) ? null : new He(r2, n2, a2, i2, s2, o2) : null;
          }
          evaluate(t2) {
            const e3 = this.input.evaluate(t2);
            return (Ut(e3) === this.inputType && this.outputs[this.cases[e3]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["match", this.input.serialize()], e3 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
            for (const t3 of e3) {
              const e4 = n2[this.cases[t3]];
              void 0 === e4 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e4][1].push(t3);
            }
            const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
            for (const [e4, n3] of r2)
              t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e4].serialize());
            return t2.push(this.otherwise.serialize()), t2;
          }
        }
        class We {
          constructor(t2, e3, r2) {
            this.type = t2, this.branches = e3, this.otherwise = r2;
          }
          static parse(t2, e3) {
            if (t2.length < 4)
              return e3.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 0)
              return e3.error("Expected an odd number of arguments.");
            let r2;
            e3.expectedType && "value" !== e3.expectedType.kind && (r2 = e3.expectedType);
            const n2 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              const s2 = e3.parse(t2[i3], i3, dt);
              if (!s2)
                return null;
              const a2 = e3.parse(t2[i3 + 1], i3 + 1, r2);
              if (!a2)
                return null;
              n2.push([s2, a2]), r2 = r2 || a2.type;
            }
            const i2 = e3.parse(t2[t2.length - 1], t2.length - 1, r2);
            return i2 ? new We(r2, n2, i2) : null;
          }
          evaluate(t2) {
            for (const [e3, r2] of this.branches)
              if (e3.evaluate(t2))
                return r2.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (const [e3, r2] of this.branches)
              t2(e3), t2(r2);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t2, e3]) => e3.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["case"];
            return this.eachChild((e3) => {
              t2.push(e3.serialize());
            }), t2;
          }
        }
        class Qe {
          constructor(t2, e3, r2, n2) {
            this.type = t2, this.input = e3, this.beginIndex = r2, this.endIndex = n2;
          }
          static parse(t2, e3) {
            if (t2.length <= 2 || t2.length >= 5)
              return e3.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e3.parse(t2[1], 1, gt), n2 = e3.parse(t2[2], 2, pt);
            if (!r2 || !n2)
              return null;
            if (!St(r2.type, [wt(gt), ft, gt]))
              return e3.error(`Expected first argument to be of type array or string, but found ${_t(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e3.parse(t2[3], 3, pt);
              return i2 ? new Qe(r2.type, r2, n2, i2) : null;
            }
            return new Qe(r2.type, r2, n2);
          }
          evaluate(t2) {
            const e3 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            if (!zt(e3, ["string", "array"]))
              throw new jt(`Expected first argument to be of type array or string, but found ${_t(Ut(e3))} instead.`);
            if (this.endIndex) {
              const n2 = this.endIndex.evaluate(t2);
              return e3.slice(r2, n2);
            }
            return e3.slice(r2);
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              const t2 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        function tr(t2, e3) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e3.kind || "string" === e3.kind || "number" === e3.kind || "null" === e3.kind || "value" === e3.kind : "string" === e3.kind || "number" === e3.kind || "value" === e3.kind;
        }
        function er(t2, e3, r2, n2) {
          return 0 === n2.compare(e3, r2);
        }
        function rr(t2, e3, r2) {
          const n2 = "==" !== t2 && "!=" !== t2;
          return class i2 {
            constructor(t3, e4, r3) {
              this.type = dt, this.lhs = t3, this.rhs = e4, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e4.type.kind;
            }
            static parse(t3, e4) {
              if (3 !== t3.length && 4 !== t3.length)
                return e4.error("Expected two or three arguments.");
              const r3 = t3[0];
              let s2 = e4.parse(t3[1], 1, gt);
              if (!s2)
                return null;
              if (!tr(r3, s2.type))
                return e4.concat(1).error(`"${r3}" comparisons are not supported for type '${_t(s2.type)}'.`);
              let a2 = e4.parse(t3[2], 2, gt);
              if (!a2)
                return null;
              if (!tr(r3, a2.type))
                return e4.concat(2).error(`"${r3}" comparisons are not supported for type '${_t(a2.type)}'.`);
              if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                return e4.error(`Cannot compare types '${_t(s2.type)}' and '${_t(a2.type)}'.`);
              n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new Kt(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new Kt(s2.type, [a2])));
              let o2 = null;
              if (4 === t3.length) {
                if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                  return e4.error("Cannot use collator to compare non-string types.");
                if (o2 = e4.parse(t3[3], 3, xt), !o2)
                  return null;
              }
              return new i2(s2, a2, o2);
            }
            evaluate(i3) {
              const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                const e4 = Ut(s2), r3 = Ut(a2);
                if (e4.kind !== r3.kind || "string" !== e4.kind && "number" !== e4.kind)
                  throw new jt(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e4.kind}, ${r3.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t3 = Ut(s2), r3 = Ut(a2);
                if ("string" !== t3.kind || "string" !== r3.kind)
                  return e3(i3, s2, a2);
              }
              return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e3(i3, s2, a2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e4 = [t2];
              return this.eachChild((t3) => {
                e4.push(t3.serialize());
              }), e4;
            }
          };
        }
        const nr = rr("==", function(t2, e3, r2) {
          return e3 === r2;
        }, er), ir = rr("!=", function(t2, e3, r2) {
          return e3 !== r2;
        }, function(t2, e3, r2, n2) {
          return !er(0, e3, r2, n2);
        }), sr = rr("<", function(t2, e3, r2) {
          return e3 < r2;
        }, function(t2, e3, r2, n2) {
          return n2.compare(e3, r2) < 0;
        }), ar = rr(">", function(t2, e3, r2) {
          return e3 > r2;
        }, function(t2, e3, r2, n2) {
          return n2.compare(e3, r2) > 0;
        }), or = rr("<=", function(t2, e3, r2) {
          return e3 <= r2;
        }, function(t2, e3, r2, n2) {
          return n2.compare(e3, r2) <= 0;
        }), lr = rr(">=", function(t2, e3, r2) {
          return e3 >= r2;
        }, function(t2, e3, r2, n2) {
          return n2.compare(e3, r2) >= 0;
        });
        class ur {
          constructor(t2, e3, r2, n2, i2) {
            this.type = ft, this.number = t2, this.locale = e3, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
          }
          static parse(t2, e3) {
            if (3 !== t2.length)
              return e3.error("Expected two arguments.");
            const r2 = e3.parse(t2[1], 1, pt);
            if (!r2)
              return null;
            const n2 = t2[2];
            if ("object" != typeof n2 || Array.isArray(n2))
              return e3.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n2.locale && (i2 = e3.parse(n2.locale, 1, ft), !i2))
              return null;
            let s2 = null;
            if (n2.currency && (s2 = e3.parse(n2.currency, 1, ft), !s2))
              return null;
            let a2 = null;
            if (n2["min-fraction-digits"] && (a2 = e3.parse(n2["min-fraction-digits"], 1, pt), !a2))
              return null;
            let o2 = null;
            return n2["max-fraction-digits"] && (o2 = e3.parse(n2["max-fraction-digits"], 1, pt), !o2) ? null : new ur(r2, i2, s2, a2, o2);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
          }
        }
        class cr {
          constructor(t2) {
            this.type = pt, this.input = t2;
          }
          static parse(t2, e3) {
            if (2 !== t2.length)
              return e3.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            const r2 = e3.parse(t2[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e3.error(`Expected argument of type string or array, but found ${_t(r2.type)} instead.`) : new cr(r2) : null;
          }
          evaluate(t2) {
            const e3 = this.input.evaluate(t2);
            if ("string" == typeof e3)
              return e3.length;
            if (Array.isArray(e3))
              return e3.length;
            throw new jt(`Expected value to be of type string or array, but found ${_t(Ut(e3))} instead.`);
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["length"];
            return this.eachChild((e3) => {
              t2.push(e3.serialize());
            }), t2;
          }
        }
        const hr = { "==": nr, "!=": ir, ">": ar, "<": sr, ">=": lr, "<=": or, array: Kt, at: Je, boolean: Kt, case: We, coalesce: Ze, collator: Qt, format: Zt, image: Gt, in: Xe, "index-of": Ye, interpolate: Ne, "interpolate-hcl": Ne, "interpolate-lab": Ne, length: cr, let: Ge, literal: qt, match: He, number: Kt, "number-format": ur, object: Kt, slice: Qe, step: ke, string: Kt, "to-boolean": Xt, "to-color": Xt, "to-number": Xt, "to-string": Xt, var: be, within: me };
        function pr(t2, [e3, r2, n2, i2]) {
          e3 = e3.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
          const s2 = i2 ? i2.evaluate(t2) : 1, a2 = $t(e3, r2, n2, s2);
          if (a2)
            throw new jt(a2);
          return new Et(e3 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
        }
        function fr(t2, e3) {
          return t2 in e3;
        }
        function dr(t2, e3) {
          const r2 = e3[t2];
          return void 0 === r2 ? null : r2;
        }
        function yr(t2) {
          return { type: t2 };
        }
        function mr(t2) {
          return { result: "success", value: t2 };
        }
        function gr(t2) {
          return { result: "error", value: t2 };
        }
        function xr(t2) {
          return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
        }
        function vr(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function br(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function wr(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
        }
        function _r(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
        }
        function Ar(t2) {
          return t2;
        }
        function kr(t2, e3) {
          const r2 = "color" === e3.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (br(e3) ? "exponential" : "interval");
          if (r2 && ((t2 = at({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Et.parse(t3[1])])), t2.default = Et.parse(t2.default ? t2.default : e3.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !je[t2.colorSpace])
            throw new Error(`Unknown color space: ${t2.colorSpace}`);
          let a2, o2, l2;
          if ("exponential" === s2)
            a2 = Mr;
          else if ("interval" === s2)
            a2 = Ir;
          else if ("categorical" === s2) {
            a2 = zr, o2 = /* @__PURE__ */ Object.create(null);
            for (const e4 of t2.stops)
              o2[e4[0]] = e4[1];
            l2 = typeof t2.stops[0][0];
          } else {
            if ("identity" !== s2)
              throw new Error(`Unknown function type "${s2}"`);
            a2 = Br;
          }
          if (n2) {
            const r3 = {}, n3 = [];
            for (let e4 = 0; e4 < t2.stops.length; e4++) {
              const i4 = t2.stops[e4], s4 = i4[0].zoom;
              void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
            }
            const i3 = [];
            for (const t3 of n3)
              i3.push([r3[t3].zoom, kr(r3[t3], e3)]);
            const s3 = { name: "linear" };
            return { kind: "composite", interpolationType: s3, interpolationFactor: Ne.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Mr({ stops: i3, base: t2.base }, e3, r4).evaluate(r4, n4) };
          }
          if (i2) {
            const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: Ne.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e3, r4, o2, l2) };
          }
          return { kind: "source", evaluate(r3, n3) {
            const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
            return void 0 === i3 ? Sr(t2.default, e3.default) : a2(t2, e3, i3, o2, l2);
          } };
        }
        function Sr(t2, e3, r2) {
          return void 0 !== t2 ? t2 : void 0 !== e3 ? e3 : void 0 !== r2 ? r2 : void 0;
        }
        function zr(t2, e3, r2, n2, i2) {
          return Sr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e3.default);
        }
        function Ir(t2, e3, r2) {
          if ("number" !== wr(r2))
            return Sr(t2.default, e3.default);
          const n2 = t2.stops.length;
          if (1 === n2)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[n2 - 1][0])
            return t2.stops[n2 - 1][1];
          const i2 = Ae(t2.stops.map((t3) => t3[0]), r2);
          return t2.stops[i2][1];
        }
        function Mr(t2, e3, r2) {
          const n2 = void 0 !== t2.base ? t2.base : 1;
          if ("number" !== wr(r2))
            return Sr(t2.default, e3.default);
          const i2 = t2.stops.length;
          if (1 === i2)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0])
            return t2.stops[i2 - 1][1];
          const s2 = Ae(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e4, r3, n3) {
            const i3 = n3 - r3, s3 = t3 - r3;
            return 0 === i3 ? 0 : 1 === e4 ? s3 / i3 : (Math.pow(e4, s3) - 1) / (Math.pow(e4, i3) - 1);
          }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
          let u2 = ze[e3.type] || Ar;
          if (t2.colorSpace && "rgb" !== t2.colorSpace) {
            const e4 = je[t2.colorSpace];
            u2 = (t3, r3) => e4.reverse(e4.interpolate(e4.forward(t3), e4.forward(r3), a2));
          }
          return "function" == typeof o2.evaluate ? { evaluate(...t3) {
            const e4 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
            if (void 0 !== e4 && void 0 !== r3)
              return u2(e4, r3, a2);
          } } : u2(o2, l2, a2);
        }
        function Br(t2, e3, r2) {
          return "color" === e3.type ? r2 = Et.parse(r2) : "formatted" === e3.type ? r2 = Lt.fromString(r2.toString()) : "resolvedImage" === e3.type ? r2 = Dt.fromString(r2.toString()) : wr(r2) === e3.type || "enum" === e3.type && e3.values[r2] || (r2 = void 0), Sr(r2, t2.default, e3.default);
        }
        Wt.register(hr, { error: [{ kind: "error" }, [ft], (t2, [e3]) => {
          throw new jt(e3.evaluate(t2));
        }], typeof: [ft, [gt], (t2, [e3]) => _t(Ut(e3.evaluate(t2)))], "to-rgba": [wt(pt, 4), [yt], (t2, [e3]) => e3.evaluate(t2).toArray()], rgb: [yt, [pt, pt, pt], pr], rgba: [yt, [pt, pt, pt, pt], pr], has: { type: dt, overloads: [[[ft], (t2, [e3]) => fr(e3.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e3, r2]) => fr(e3.evaluate(t2), r2.evaluate(t2))]] }, get: { type: gt, overloads: [[[ft], (t2, [e3]) => dr(e3.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e3, r2]) => dr(e3.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [gt, [ft], (t2, [e3]) => dr(e3.evaluate(t2), t2.featureState || {})], properties: [mt, [], (t2) => t2.properties()], "geometry-type": [ft, [], (t2) => t2.geometryType()], id: [gt, [], (t2) => t2.id()], zoom: [pt, [], (t2) => t2.globals.zoom], "heatmap-density": [pt, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [pt, [], (t2) => t2.globals.lineProgress || 0], accumulated: [gt, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [pt, yr(pt), (t2, e3) => {
          let r2 = 0;
          for (const n2 of e3)
            r2 += n2.evaluate(t2);
          return r2;
        }], "*": [pt, yr(pt), (t2, e3) => {
          let r2 = 1;
          for (const n2 of e3)
            r2 *= n2.evaluate(t2);
          return r2;
        }], "-": { type: pt, overloads: [[[pt, pt], (t2, [e3, r2]) => e3.evaluate(t2) - r2.evaluate(t2)], [[pt], (t2, [e3]) => -e3.evaluate(t2)]] }, "/": [pt, [pt, pt], (t2, [e3, r2]) => e3.evaluate(t2) / r2.evaluate(t2)], "%": [pt, [pt, pt], (t2, [e3, r2]) => e3.evaluate(t2) % r2.evaluate(t2)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t2, [e3, r2]) => Math.pow(e3.evaluate(t2), r2.evaluate(t2))], sqrt: [pt, [pt], (t2, [e3]) => Math.sqrt(e3.evaluate(t2))], log10: [pt, [pt], (t2, [e3]) => Math.log(e3.evaluate(t2)) / Math.LN10], ln: [pt, [pt], (t2, [e3]) => Math.log(e3.evaluate(t2))], log2: [pt, [pt], (t2, [e3]) => Math.log(e3.evaluate(t2)) / Math.LN2], sin: [pt, [pt], (t2, [e3]) => Math.sin(e3.evaluate(t2))], cos: [pt, [pt], (t2, [e3]) => Math.cos(e3.evaluate(t2))], tan: [pt, [pt], (t2, [e3]) => Math.tan(e3.evaluate(t2))], asin: [pt, [pt], (t2, [e3]) => Math.asin(e3.evaluate(t2))], acos: [pt, [pt], (t2, [e3]) => Math.acos(e3.evaluate(t2))], atan: [pt, [pt], (t2, [e3]) => Math.atan(e3.evaluate(t2))], min: [pt, yr(pt), (t2, e3) => Math.min(...e3.map((e4) => e4.evaluate(t2)))], max: [pt, yr(pt), (t2, e3) => Math.max(...e3.map((e4) => e4.evaluate(t2)))], abs: [pt, [pt], (t2, [e3]) => Math.abs(e3.evaluate(t2))], round: [pt, [pt], (t2, [e3]) => {
          const r2 = e3.evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [pt, [pt], (t2, [e3]) => Math.floor(e3.evaluate(t2))], ceil: [pt, [pt], (t2, [e3]) => Math.ceil(e3.evaluate(t2))], "filter-==": [dt, [ft, gt], (t2, [e3, r2]) => t2.properties()[e3.value] === r2.value], "filter-id-==": [dt, [gt], (t2, [e3]) => t2.id() === e3.value], "filter-type-==": [dt, [ft], (t2, [e3]) => t2.geometryType() === e3.value], "filter-<": [dt, [ft, gt], (t2, [e3, r2]) => {
          const n2 = t2.properties()[e3.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter-id-<": [dt, [gt], (t2, [e3]) => {
          const r2 = t2.id(), n2 = e3.value;
          return typeof r2 == typeof n2 && r2 < n2;
        }], "filter->": [dt, [ft, gt], (t2, [e3, r2]) => {
          const n2 = t2.properties()[e3.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-id->": [dt, [gt], (t2, [e3]) => {
          const r2 = t2.id(), n2 = e3.value;
          return typeof r2 == typeof n2 && r2 > n2;
        }], "filter-<=": [dt, [ft, gt], (t2, [e3, r2]) => {
          const n2 = t2.properties()[e3.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter-id-<=": [dt, [gt], (t2, [e3]) => {
          const r2 = t2.id(), n2 = e3.value;
          return typeof r2 == typeof n2 && r2 <= n2;
        }], "filter->=": [dt, [ft, gt], (t2, [e3, r2]) => {
          const n2 = t2.properties()[e3.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-id->=": [dt, [gt], (t2, [e3]) => {
          const r2 = t2.id(), n2 = e3.value;
          return typeof r2 == typeof n2 && r2 >= n2;
        }], "filter-has": [dt, [gt], (t2, [e3]) => e3.value in t2.properties()], "filter-has-id": [dt, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [dt, [wt(ft)], (t2, [e3]) => e3.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [dt, [wt(gt)], (t2, [e3]) => e3.value.indexOf(t2.id()) >= 0], "filter-in-small": [dt, [ft, wt(gt)], (t2, [e3, r2]) => r2.value.indexOf(t2.properties()[e3.value]) >= 0], "filter-in-large": [dt, [ft, wt(gt)], (t2, [e3, r2]) => function(t3, e4, r3, n2) {
          for (; r3 <= n2; ) {
            const i2 = r3 + n2 >> 1;
            if (e4[i2] === t3)
              return true;
            e4[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
          }
          return false;
        }(t2.properties()[e3.value], r2.value, 0, r2.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t2, [e3, r2]) => e3.evaluate(t2) && r2.evaluate(t2)], [yr(dt), (t2, e3) => {
          for (const r2 of e3)
            if (!r2.evaluate(t2))
              return false;
          return true;
        }]] }, any: { type: dt, overloads: [[[dt, dt], (t2, [e3, r2]) => e3.evaluate(t2) || r2.evaluate(t2)], [yr(dt), (t2, e3) => {
          for (const r2 of e3)
            if (r2.evaluate(t2))
              return true;
          return false;
        }]] }, "!": [dt, [dt], (t2, [e3]) => !e3.evaluate(t2)], "is-supported-script": [dt, [ft], (t2, [e3]) => {
          const r2 = t2.globals && t2.globals.isSupportedScript;
          return !r2 || r2(e3.evaluate(t2));
        }], upcase: [ft, [ft], (t2, [e3]) => e3.evaluate(t2).toUpperCase()], downcase: [ft, [ft], (t2, [e3]) => e3.evaluate(t2).toLowerCase()], concat: [ft, yr(gt), (t2, e3) => e3.map((e4) => Ot(e4.evaluate(t2))).join("")], "resolved-locale": [ft, [xt], (t2, [e3]) => e3.evaluate(t2).resolvedLocale()] });
        class Cr {
          constructor(t2, e3) {
            this.expression = t2, this._warningHistory = {}, this._evaluator = new Ht(), this._defaultValue = e3 ? function(t3) {
              return "color" === t3.type && _r(t3.default) ? new Et(0, 0, 0, 0) : "color" === t3.type ? Et.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
            }(e3) : null, this._enumValues = e3 && "enum" === e3.type ? e3.values : null;
          }
          evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, s2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e3, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e3, r2, n2, i2, s2) {
            this._evaluator.globals = t2, this._evaluator.feature = e3 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
            try {
              const t3 = this.expression.evaluate(this._evaluator);
              if (null == t3 || "number" == typeof t3 && t3 != t3)
                return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues))
                throw new jt(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
              return t3;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
            }
          }
        }
        function Pr(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in hr;
        }
        function Vr(t2, e3) {
          const r2 = new we(hr, [], e3 ? function(t3) {
            const e4 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, resolvedImage: bt };
            return "array" === t3.type ? wt(e4[t3.value] || gt, t3.length) : e4[t3.type];
          }(e3) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e3 && "string" === e3.type ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? mr(new Cr(n2, e3)) : gr(r2.errors);
        }
        class Er {
          constructor(t2, e3) {
            this.kind = t2, this._styleExpression = e3, this.isStateDependent = "constant" !== t2 && !xe(e3.expression);
          }
          evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, s2);
          }
          evaluate(t2, e3, r2, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e3, r2, n2, i2, s2);
          }
        }
        class Fr {
          constructor(t2, e3, r2, n2) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e3, this.isStateDependent = "camera" !== t2 && !xe(e3.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, s2);
          }
          evaluate(t2, e3, r2, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e3, r2, n2, i2, s2);
          }
          interpolationFactor(t2, e3, r2) {
            return this.interpolationType ? Ne.interpolationFactor(this.interpolationType, t2, e3, r2) : 0;
          }
        }
        function Tr(t2, e3) {
          const r2 = Vr(t2, e3);
          if ("error" === r2.result)
            return r2;
          const n2 = r2.value.expression, i2 = ge(n2);
          if (!i2 && !xr(e3))
            return gr([new ut("", "data expressions not supported")]);
          const s2 = ve(n2, ["zoom"]);
          if (!s2 && !vr(e3))
            return gr([new ut("", "zoom expressions not supported")]);
          const a2 = Dr(n2);
          return a2 || s2 ? a2 instanceof ut ? gr([a2]) : a2 instanceof Ne && !br(e3) ? gr([new ut("", '"interpolate" expressions cannot be used with this property')]) : mr(a2 ? new Fr(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof Ne ? a2.interpolation : void 0) : new Er(i2 ? "constant" : "source", r2.value)) : gr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Lr {
          constructor(t2, e3) {
            this._parameters = t2, this._specification = e3, at(this, kr(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new Lr(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function Dr(t2) {
          let e3 = null;
          if (t2 instanceof Ge)
            e3 = Dr(t2.result);
          else if (t2 instanceof Ze) {
            for (const r2 of t2.args)
              if (e3 = Dr(r2), e3)
                break;
          } else
            (t2 instanceof ke || t2 instanceof Ne) && t2.input instanceof Wt && "zoom" === t2.input.name && (e3 = t2);
          return e3 instanceof ut || t2.eachChild((t3) => {
            const r2 = Dr(t3);
            r2 instanceof ut ? e3 = r2 : !e3 && r2 ? e3 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e3 && r2 && e3 !== r2 && (e3 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e3;
        }
        function $r(t2) {
          const e3 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
          let o2 = [];
          const l2 = wr(r2);
          if ("object" !== l2)
            return [new it(e3, r2, `object expected, ${l2} found`)];
          for (const t3 in r2) {
            const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
            let c2;
            if (i2[l3])
              c2 = i2[l3];
            else if (n2[l3])
              c2 = pn;
            else if (i2["*"])
              c2 = i2["*"];
            else {
              if (!n2["*"]) {
                o2.push(new it(e3, r2[t3], `unknown property "${t3}"`));
                continue;
              }
              c2 = pn;
            }
            o2 = o2.concat(c2({ key: (e3 ? `${e3}.` : e3) + t3, value: r2[t3], valueSpec: u2, style: s2, styleSpec: a2, object: r2, objectKey: t3 }, r2));
          }
          for (const t3 in n2)
            i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && o2.push(new it(e3, r2, `missing required property "${t3}"`));
          return o2;
        }
        function Rr(t2) {
          const e3 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || pn;
          if ("array" !== wr(e3))
            return [new it(s2, e3, `array expected, ${wr(e3)} found`)];
          if (r2.length && e3.length !== r2.length)
            return [new it(s2, e3, `array length ${r2.length} expected, length ${e3.length} found`)];
          if (r2["min-length"] && e3.length < r2["min-length"])
            return [new it(s2, e3, `array length at least ${r2["min-length"]} expected, length ${e3.length} found`)];
          let o2 = { type: r2.value, values: r2.values };
          i2.$version < 7 && (o2.function = r2.function), "object" === wr(r2.value) && (o2 = r2.value);
          let l2 = [];
          for (let t3 = 0; t3 < e3.length; t3++)
            l2 = l2.concat(a2({ array: e3, arrayIndex: t3, value: e3[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }));
          return l2;
        }
        function Ur(t2) {
          const e3 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
          let i2 = wr(r2);
          return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new it(e3, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new it(e3, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new it(e3, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
        }
        function Or(t2) {
          const e3 = t2.valueSpec, r2 = ot(t2.value.type);
          let n2, i2, s2, a2 = {};
          const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === wr(t2.value.stops) && "array" === wr(t2.value.stops[0]) && "object" === wr(t2.value.stops[0][0]), c2 = $r({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === r2)
              return [new it(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let e4 = [];
            const n3 = t3.value;
            return e4 = e4.concat(Rr({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === wr(n3) && 0 === n3.length && e4.push(new it(t3.key, n3, "array must have at least one stop")), e4;
          }, default: function(t3) {
            return pn({ key: t3.key, value: t3.value, valueSpec: e3, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return "identity" === r2 && o2 && c2.push(new it(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new it(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !br(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !xr(t2.valueSpec) ? c2.push(new it(t2.key, t2.value, "property functions not supported")) : o2 && !vr(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new it(t2.key, t2.value, '"property" property is required')), c2;
          function h2(t3) {
            let r3 = [];
            const n3 = t3.value, o3 = t3.key;
            if ("array" !== wr(n3))
              return [new it(o3, n3, `array expected, ${wr(n3)} found`)];
            if (2 !== n3.length)
              return [new it(o3, n3, `array length 2 expected, length ${n3.length} found`)];
            if (u2) {
              if ("object" !== wr(n3[0]))
                return [new it(o3, n3, `object expected, ${wr(n3[0])} found`)];
              if (void 0 === n3[0].zoom)
                return [new it(o3, n3, "object stop key must have zoom")];
              if (void 0 === n3[0].value)
                return [new it(o3, n3, "object stop key must have value")];
              if (s2 && s2 > ot(n3[0].zoom))
                return [new it(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              ot(n3[0].zoom) !== s2 && (s2 = ot(n3[0].zoom), i2 = void 0, a2 = {}), r3 = r3.concat($r({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Ur, value: p2 } }));
            } else
              r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
            return Pr(lt(n3[1])) ? r3.concat([new it(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(pn({ key: `${o3}[1]`, value: n3[1], valueSpec: e3, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function p2(t3, s3) {
            const o3 = wr(t3.value), l3 = ot(t3.value), u3 = null !== t3.value ? t3.value : s3;
            if (n2) {
              if (o3 !== n2)
                return [new it(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else
              n2 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3)
              return [new it(t3.key, u3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r2) {
              let n3 = `number expected, ${o3} found`;
              return xr(e3) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new it(t3.key, u3, n3)];
            }
            return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i2 && l3 < i2 ? [new it(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in a2 ? [new it(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new it(t3.key, u3, `integer expected, found ${l3}`)];
          }
        }
        function qr(t2) {
          const e3 = ("property" === t2.expressionContext ? Tr : Vr)(lt(t2.value), t2.valueSpec);
          if ("error" === e3.result)
            return e3.value.map((e4) => new it(`${t2.key}${e4.key}`, t2.value, e4.message));
          const r2 = e3.value.expression || e3.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
            return [new it(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !xe(r2))
            return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext && !xe(r2))
            return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!ve(r2, ["zoom", "feature-state"]))
              return [new it(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !ge(r2))
              return [new it(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function jr(t2) {
          const e3 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(ot(r2)) && i2.push(new it(e3, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(ot(r2)) && i2.push(new it(e3, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
        }
        function Nr(t2) {
          if (true === t2 || false === t2)
            return true;
          if (!Array.isArray(t2) || 0 === t2.length)
            return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (const e3 of t2.slice(1))
                if (!Nr(e3) && "boolean" != typeof e3)
                  return false;
              return true;
            default:
              return true;
          }
        }
        const Kr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Zr(t2) {
          if (null == t2)
            return { filter: () => true, needGeometry: false };
          Nr(t2) || (t2 = Xr(t2));
          const e3 = Vr(t2, Kr);
          if ("error" === e3.result)
            throw new Error(e3.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
          return { filter: (t3, r2, n2) => e3.value.evaluate(t3, r2, {}, n2), needGeometry: Jr(t2) };
        }
        function Gr(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }
        function Jr(t2) {
          if (!Array.isArray(t2))
            return false;
          if ("within" === t2[0])
            return true;
          for (let e3 = 1; e3 < t2.length; e3++)
            if (Jr(t2[e3]))
              return true;
          return false;
        }
        function Xr(t2) {
          if (!t2)
            return true;
          const e3 = t2[0];
          return t2.length <= 1 ? "any" !== e3 : "==" === e3 ? Yr(t2[1], t2[2], "==") : "!=" === e3 ? Qr(Yr(t2[1], t2[2], "==")) : "<" === e3 || ">" === e3 || "<=" === e3 || ">=" === e3 ? Yr(t2[1], t2[2], e3) : "any" === e3 ? (r2 = t2.slice(1), ["any"].concat(r2.map(Xr))) : "all" === e3 ? ["all"].concat(t2.slice(1).map(Xr)) : "none" === e3 ? ["all"].concat(t2.slice(1).map(Xr).map(Qr)) : "in" === e3 ? Hr(t2[1], t2.slice(2)) : "!in" === e3 ? Qr(Hr(t2[1], t2.slice(2))) : "has" === e3 ? Wr(t2[1]) : "!has" === e3 ? Qr(Wr(t2[1])) : "within" !== e3 || t2;
          var r2;
        }
        function Yr(t2, e3, r2) {
          switch (t2) {
            case "$type":
              return [`filter-type-${r2}`, e3];
            case "$id":
              return [`filter-id-${r2}`, e3];
            default:
              return [`filter-${r2}`, t2, e3];
          }
        }
        function Hr(t2, e3) {
          if (0 === e3.length)
            return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e3]];
            case "$id":
              return ["filter-id-in", ["literal", e3]];
            default:
              return e3.length > 200 && !e3.some((t3) => typeof t3 != typeof e3[0]) ? ["filter-in-large", t2, ["literal", e3.sort(Gr)]] : ["filter-in-small", t2, ["literal", e3]];
          }
        }
        function Wr(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function Qr(t2) {
          return ["!", t2];
        }
        function tn(t2) {
          return Nr(lt(t2.value)) ? qr(at({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : en(t2);
        }
        function en(t2) {
          const e3 = t2.value, r2 = t2.key;
          if ("array" !== wr(e3))
            return [new it(r2, e3, `array expected, ${wr(e3)} found`)];
          const n2 = t2.styleSpec;
          let i2, s2 = [];
          if (e3.length < 1)
            return [new it(r2, e3, "filter array must have at least 1 element")];
          switch (s2 = s2.concat(jr({ key: `${r2}[0]`, value: e3[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), ot(e3[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e3.length >= 2 && "$type" === ot(e3[1]) && s2.push(new it(r2, e3, `"$type" cannot be use with operator "${e3[0]}"`));
            case "==":
            case "!=":
              3 !== e3.length && s2.push(new it(r2, e3, `filter array for operator "${e3[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e3.length >= 2 && (i2 = wr(e3[1]), "string" !== i2 && s2.push(new it(`${r2}[1]`, e3[1], `string expected, ${i2} found`)));
              for (let a2 = 2; a2 < e3.length; a2++)
                i2 = wr(e3[a2]), "$type" === ot(e3[1]) ? s2 = s2.concat(jr({ key: `${r2}[${a2}]`, value: e3[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new it(`${r2}[${a2}]`, e3[a2], `string, number, or boolean expected, ${i2} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e3.length; n3++)
                s2 = s2.concat(en({ key: `${r2}[${n3}]`, value: e3[n3], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = wr(e3[1]), 2 !== e3.length ? s2.push(new it(r2, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new it(`${r2}[1]`, e3[1], `string expected, ${i2} found`));
              break;
            case "within":
              i2 = wr(e3[1]), 2 !== e3.length ? s2.push(new it(r2, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "object" !== i2 && s2.push(new it(`${r2}[1]`, e3[1], `object expected, ${i2} found`));
          }
          return s2;
        }
        function rn(t2, e3) {
          const r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.value, a2 = t2.objectKey, o2 = i2[`${e3}_${t2.layerType}`];
          if (!o2)
            return [];
          const l2 = a2.match(/^(.*)-transition$/);
          if ("paint" === e3 && l2 && o2[l2[1]] && o2[l2[1]].transition)
            return pn({ key: r2, value: s2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
          const u2 = t2.valueSpec || o2[a2];
          if (!u2)
            return [new it(r2, s2, `unknown property "${a2}"`)];
          let c2;
          if ("string" === wr(s2) && xr(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s2)))
            return [new it(r2, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
          const h2 = [];
          return "symbol" === t2.layerType && ("text-field" === a2 && n2 && !n2.glyphs && h2.push(new it(r2, s2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a2 && _r(lt(s2)) && "identity" === ot(s2.type) && h2.push(new it(r2, s2, '"text-font" does not support identity functions'))), h2.concat(pn({ key: t2.key, value: s2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e3, propertyKey: a2 }));
        }
        function nn(t2) {
          return rn(t2, "paint");
        }
        function sn(t2) {
          return rn(t2, "layout");
        }
        function an(t2) {
          let e3 = [];
          const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
          r2.type || r2.ref || e3.push(new it(n2, r2, 'either "type" or "ref" is required'));
          let a2 = ot(r2.type);
          const o2 = ot(r2.ref);
          if (r2.id) {
            const s3 = ot(r2.id);
            for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
              const t3 = i2.layers[a3];
              ot(t3.id) === s3 && e3.push(new it(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
            }
          }
          if ("ref" in r2) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
              t4 in r2 && e3.push(new it(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
            }), i2.layers.forEach((e4) => {
              ot(e4.id) === o2 && (t3 = e4);
            }), t3 ? t3.ref ? e3.push(new it(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = ot(t3.type) : e3.push(new it(n2, r2.ref, `ref layer "${o2}" not found`));
          } else if ("background" !== a2)
            if (r2.source) {
              const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && ot(t3.type);
              t3 ? "vector" === s3 && "raster" === a2 ? e3.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster" === s3 && "raster" !== a2 ? e3.push(new it(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e3.push(new it(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === s3 && t3.lineMetrics || e3.push(new it(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e3.push(new it(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e3.push(new it(n2, r2.source, `source "${r2.source}" not found`));
            } else
              e3.push(new it(n2, r2, 'missing required property "source"'));
          return e3 = e3.concat($r({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => pn({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: tn, layout: (t3) => $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => sn(at({ layerType: a2 }, t4)) } }), paint: (t3) => $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => nn(at({ layerType: a2 }, t4)) } }) } })), e3;
        }
        function on(t2) {
          const e3 = t2.value, r2 = t2.key, n2 = wr(e3);
          return "string" !== n2 ? [new it(r2, e3, `string expected, ${n2} found`)] : [];
        }
        const ln = { promoteId: function({ key: t2, value: e3 }) {
          if ("string" === wr(e3))
            return on({ key: t2, value: e3 });
          {
            const r2 = [];
            for (const n2 in e3)
              r2.push(...on({ key: `${t2}.${n2}`, value: e3[n2] }));
            return r2;
          }
        } };
        function un(t2) {
          const e3 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
          if (!e3.type)
            return [new it(r2, e3, '"type" is required')];
          const s2 = ot(e3.type);
          let a2;
          switch (s2) {
            case "vector":
            case "raster":
            case "raster-dem":
              return a2 = $r({ key: r2, value: e3, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: ln }), a2;
            case "geojson":
              if (a2 = $r({ key: r2, value: e3, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: ln }), e3.cluster)
                for (const t3 in e3.clusterProperties) {
                  const [n3, i3] = e3.clusterProperties[t3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                  a2.push(...qr({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...qr({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
                }
              return a2;
            case "video":
              return $r({ key: r2, value: e3, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
            case "image":
              return $r({ key: r2, value: e3, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
            case "canvas":
              return [new it(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return jr({ key: `${r2}.type`, value: e3.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
          }
        }
        function cn(t2) {
          const e3 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
          let s2 = [];
          const a2 = wr(e3);
          if (void 0 === e3)
            return s2;
          if ("object" !== a2)
            return s2 = s2.concat([new it("light", e3, `object expected, ${a2} found`)]), s2;
          for (const t3 in e3) {
            const a3 = t3.match(/^(.*)-transition$/);
            s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? pn({ key: t3, value: e3[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? pn({ key: t3, value: e3[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new it(t3, e3[t3], `unknown property "${t3}"`)]);
          }
          return s2;
        }
        const hn = { "*": () => [], array: Rr, boolean: function(t2) {
          const e3 = t2.value, r2 = t2.key, n2 = wr(e3);
          return "boolean" !== n2 ? [new it(r2, e3, `boolean expected, ${n2} found`)] : [];
        }, number: Ur, color: function(t2) {
          const e3 = t2.key, r2 = t2.value, n2 = wr(r2);
          return "string" !== n2 ? [new it(e3, r2, `color expected, ${n2} found`)] : null === It(r2) ? [new it(e3, r2, `color expected, "${r2}" found`)] : [];
        }, constants: st, enum: jr, filter: tn, function: Or, layer: an, object: $r, source: un, light: cn, string: on, formatted: function(t2) {
          return 0 === on(t2).length ? [] : qr(t2);
        }, resolvedImage: function(t2) {
          return 0 === on(t2).length ? [] : qr(t2);
        } };
        function pn(t2) {
          const e3 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
          return r2.expression && _r(ot(e3)) ? Or(t2) : r2.expression && Pr(lt(e3)) ? qr(t2) : r2.type && hn[r2.type] ? hn[r2.type](t2) : $r(at({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function fn(t2) {
          const e3 = t2.value, r2 = t2.key, n2 = on(t2);
          return n2.length || (-1 === e3.indexOf("{fontstack}") && n2.push(new it(r2, e3, '"glyphs" url must include a "{fontstack}" token')), -1 === e3.indexOf("{range}") && n2.push(new it(r2, e3, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function dn(t2, e3 = nt) {
          let r2 = [];
          return r2 = r2.concat(pn({ key: "", value: t2, valueSpec: e3.$root, styleSpec: e3, style: t2, objectElementValidators: { glyphs: fn, "*": () => [] } })), t2.constants && (r2 = r2.concat(st({ key: "constants", value: t2.constants, style: t2, styleSpec: e3 }))), yn(r2);
        }
        function yn(t2) {
          return [].concat(t2).sort((t3, e3) => t3.line - e3.line);
        }
        function mn(t2) {
          return function(...e3) {
            return yn(t2.apply(this, e3));
          };
        }
        dn.source = mn(un), dn.light = mn(cn), dn.layer = mn(an), dn.filter = mn(tn), dn.paintProperty = mn(nn), dn.layoutProperty = mn(sn);
        const gn = dn, xn = gn.light, vn = gn.paintProperty, bn = gn.layoutProperty;
        function wn(t2, e3) {
          let r2 = false;
          if (e3 && e3.length)
            for (const n2 of e3)
              t2.fire(new et(new Error(n2.message))), r2 = true;
          return r2;
        }
        class _n {
          constructor(t2, e3, r2) {
            const n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              const i3 = new Int32Array(this.arrayBuffer);
              t2 = i3[0], this.d = (e3 = i3[1]) + 2 * (r2 = i3[2]);
              for (let t3 = 0; t3 < this.d * this.d; t3++) {
                const e4 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                n2.push(e4 === r3 ? null : i3.subarray(e4, r3));
              }
              const s2 = i3[3 + n2.length + 1];
              this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
            } else {
              this.d = e3 + 2 * r2;
              for (let t3 = 0; t3 < this.d * this.d; t3++)
                n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e3, this.extent = t2, this.padding = r2, this.scale = e3 / t2, this.uid = 0;
            const i2 = r2 / e3 * t2;
            this.min = -i2, this.max = t2 + i2;
          }
          insert(t2, e3, r2, n2, i2) {
            this._forEachCell(e3, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e3), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t2, e3, r2, n2, i2, s2) {
            this.cells[i2].push(s2);
          }
          query(t2, e3, r2, n2, i2) {
            const s2 = this.min, a2 = this.max;
            if (t2 <= s2 && e3 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
              return Array.prototype.slice.call(this.keys);
            {
              const s3 = [];
              return this._forEachCell(t2, e3, r2, n2, this._queryCell, s3, {}, i2), s3;
            }
          }
          _queryCell(t2, e3, r2, n2, i2, s2, a2, o2) {
            const l2 = this.cells[i2];
            if (null !== l2) {
              const i3 = this.keys, u2 = this.bboxes;
              for (let c2 = 0; c2 < l2.length; c2++) {
                const h2 = l2[c2];
                if (void 0 === a2[h2]) {
                  const l3 = 4 * h2;
                  (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e3 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
                }
              }
            }
          }
          _forEachCell(t2, e3, r2, n2, i2, s2, a2, o2) {
            const l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e3), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
            for (let p2 = l2; p2 <= c2; p2++)
              for (let l3 = u2; l3 <= h2; l3++) {
                const u3 = this.d * l3 + p2;
                if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e3, r2, n2, u3, s2, a2, o2))
                  return;
              }
          }
          _convertFromCellCoord(t2) {
            return (t2 - this.padding) / this.scale;
          }
          _convertToCellCoord(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            const t2 = this.cells, e3 = 3 + this.cells.length + 1 + 1;
            let r2 = 0;
            for (let t3 = 0; t3 < this.cells.length; t3++)
              r2 += this.cells[t3].length;
            const n2 = new Int32Array(e3 + r2 + this.keys.length + this.bboxes.length);
            n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
            let i2 = e3;
            for (let e4 = 0; e4 < t2.length; e4++) {
              const r3 = t2[e4];
              n2[3 + e4] = i2, n2.set(r3, i2), i2 += r3.length;
            }
            return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
          }
          static serialize(t2, e3) {
            const r2 = t2.toArrayBuffer();
            return e3 && e3.push(r2), { buffer: r2 };
          }
          static deserialize(t2) {
            return new _n(t2.buffer);
          }
        }
        const An = {};
        function kn(t2, e3, r2 = {}) {
          Object.defineProperty(e3, "_classRegistryKey", { value: t2, writeable: false }), An[t2] = { klass: e3, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        kn("Object", Object), kn("TransferableGridIndex", _n), kn("Color", Et), kn("Error", Error), kn("AJAXError", q), kn("ResolvedImage", Dt), kn("StylePropertyFunction", Lr), kn("StyleExpression", Cr, { omit: ["_evaluator"] }), kn("ZoomDependentExpression", Fr), kn("ZoomConstantExpression", Er), kn("CompoundExpression", Wt, { omit: ["_evaluate"] });
        for (const t2 in hr)
          hr[t2]._classRegistryKey || kn(`Expression_${t2}`, hr[t2]);
        function Sn(t2) {
          return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function zn(t2, e3) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob)
            return t2;
          if (Sn(t2))
            return e3 && e3.push(t2), t2;
          if (A(t2))
            return e3 && e3.push(t2), t2;
          if (ArrayBuffer.isView(t2)) {
            const r2 = t2;
            return e3 && e3.push(r2.buffer), r2;
          }
          if (t2 instanceof ImageData)
            return e3 && e3.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            const r2 = [];
            for (const n2 of t2)
              r2.push(zn(n2, e3));
            return r2;
          }
          if ("object" == typeof t2) {
            const r2 = t2.constructor, n2 = r2._classRegistryKey;
            if (!n2)
              throw new Error("can't serialize object of unregistered class");
            const i2 = r2.serialize ? r2.serialize(t2, e3) : {};
            if (!r2.serialize) {
              for (const r3 in t2) {
                if (!t2.hasOwnProperty(r3))
                  continue;
                if (An[n2].omit.indexOf(r3) >= 0)
                  continue;
                const s2 = t2[r3];
                i2[r3] = An[n2].shallow.indexOf(r3) >= 0 ? s2 : zn(s2, e3);
              }
              t2 instanceof Error && (i2.message = t2.message);
            }
            if (i2.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n2 && (i2.$name = n2), i2;
          }
          throw new Error("can't serialize object of type " + typeof t2);
        }
        function In(t2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || Sn(t2) || A(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData)
            return t2;
          if (Array.isArray(t2))
            return t2.map(In);
          if ("object" == typeof t2) {
            const e3 = t2.$name || "Object";
            if (!An[e3])
              throw new Error(`can't deserialize unregistered class ${e3}`);
            const { klass: r2 } = An[e3];
            if (!r2)
              throw new Error(`can't deserialize unregistered class ${e3}`);
            if (r2.deserialize)
              return r2.deserialize(t2);
            const n2 = Object.create(r2.prototype);
            for (const r3 of Object.keys(t2)) {
              if ("$name" === r3)
                continue;
              const i2 = t2[r3];
              n2[r3] = An[e3].shallow.indexOf(r3) >= 0 ? i2 : In(i2);
            }
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t2);
        }
        class Mn {
          constructor() {
            this.first = true;
          }
          update(t2, e3) {
            const r2 = Math.floor(t2);
            return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e3) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e3), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
          }
        }
        const Bn = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
        function Cn(t2) {
          for (const e3 of t2)
            if (En(e3.charCodeAt(0)))
              return true;
          return false;
        }
        function Pn(t2) {
          for (const e3 of t2)
            if (!Vn(e3.charCodeAt(0)))
              return false;
          return true;
        }
        function Vn(t2) {
          return !(Bn.Arabic(t2) || Bn["Arabic Supplement"](t2) || Bn["Arabic Extended-A"](t2) || Bn["Arabic Presentation Forms-A"](t2) || Bn["Arabic Presentation Forms-B"](t2));
        }
        function En(t2) {
          return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(Bn["Bopomofo Extended"](t2) || Bn.Bopomofo(t2) || Bn["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Bn["CJK Compatibility Ideographs"](t2) || Bn["CJK Compatibility"](t2) || Bn["CJK Radicals Supplement"](t2) || Bn["CJK Strokes"](t2) || !(!Bn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || Bn["CJK Unified Ideographs Extension A"](t2) || Bn["CJK Unified Ideographs"](t2) || Bn["Enclosed CJK Letters and Months"](t2) || Bn["Hangul Compatibility Jamo"](t2) || Bn["Hangul Jamo Extended-A"](t2) || Bn["Hangul Jamo Extended-B"](t2) || Bn["Hangul Jamo"](t2) || Bn["Hangul Syllables"](t2) || Bn.Hiragana(t2) || Bn["Ideographic Description Characters"](t2) || Bn.Kanbun(t2) || Bn["Kangxi Radicals"](t2) || Bn["Katakana Phonetic Extensions"](t2) || Bn.Katakana(t2) && 12540 !== t2 || !(!Bn["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Bn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Bn["Unified Canadian Aboriginal Syllabics"](t2) || Bn["Unified Canadian Aboriginal Syllabics Extended"](t2) || Bn["Vertical Forms"](t2) || Bn["Yijing Hexagram Symbols"](t2) || Bn["Yi Syllables"](t2) || Bn["Yi Radicals"](t2))));
        }
        function Fn(t2) {
          return !(En(t2) || function(t3) {
            return !!(Bn["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || Bn["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || Bn["Letterlike Symbols"](t3) || Bn["Number Forms"](t3) || Bn["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Bn["Control Pictures"](t3) && 9251 !== t3 || Bn["Optical Character Recognition"](t3) || Bn["Enclosed Alphanumerics"](t3) || Bn["Geometric Shapes"](t3) || Bn["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Bn["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Bn["CJK Symbols and Punctuation"](t3) || Bn.Katakana(t3) || Bn["Private Use Area"](t3) || Bn["CJK Compatibility Forms"](t3) || Bn["Small Form Variants"](t3) || Bn["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
          }(t2));
        }
        function Tn(t2) {
          return t2 >= 1424 && t2 <= 2303 || Bn["Arabic Presentation Forms-A"](t2) || Bn["Arabic Presentation Forms-B"](t2);
        }
        function Ln(t2, e3) {
          return !(!e3 && Tn(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Bn.Khmer(t2));
        }
        function Dn(t2) {
          for (const e3 of t2)
            if (Tn(e3.charCodeAt(0)))
              return true;
          return false;
        }
        const $n = "deferred", Rn = "loading", Un = "loaded";
        let On = null, qn = "unavailable", jn = null;
        const Nn = function(t2) {
          t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (qn = "error"), On && On(t2);
        };
        function Kn() {
          Zn.fire(new tt("pluginStateChange", { pluginStatus: qn, pluginURL: jn }));
        }
        const Zn = new rt(), Gn = function() {
          return qn;
        }, Jn = function() {
          if (qn !== $n || !jn)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          qn = Rn, Kn(), jn && Z({ url: jn }, (t2) => {
            t2 ? Nn(t2) : (qn = Un, Kn());
          });
        }, Xn = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => qn === Un || null != Xn.applyArabicShaping, isLoading: () => qn === Rn, setState(t2) {
          qn = t2.pluginStatus, jn = t2.pluginURL;
        }, isParsed: () => null != Xn.applyArabicShaping && null != Xn.processBidirectionalText && null != Xn.processStyledBidirectionalText, getPluginURL: () => jn };
        class Yn {
          constructor(t2, e3) {
            this.zoom = t2, e3 ? (this.now = e3.now, this.fadeDuration = e3.fadeDuration, this.zoomHistory = e3.zoomHistory, this.transition = e3.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Mn(), this.transition = {});
          }
          isSupportedScript(t2) {
            return function(t3, e3) {
              for (const r2 of t3)
                if (!Ln(r2.charCodeAt(0), e3))
                  return false;
              return true;
            }(t2, Xn.isLoaded());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t2 = this.zoom, e3 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
            return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e3 + (1 - e3) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e3 };
          }
        }
        class Hn {
          constructor(t2, e3) {
            this.property = t2, this.value = e3, this.expression = function(t3, e4) {
              if (_r(t3))
                return new Lr(t3, e4);
              if (Pr(t3)) {
                const r2 = Tr(t3, e4);
                if ("error" === r2.result)
                  throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                return r2.value;
              }
              {
                let r2 = t3;
                return "string" == typeof t3 && "color" === e4.type && (r2 = Et.parse(t3)), { kind: "constant", evaluate: () => r2 };
              }
            }(void 0 === e3 ? t2.specification.default : e3, t2.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t2, e3, r2) {
            return this.property.possiblyEvaluate(this, t2, e3, r2);
          }
        }
        class Wn {
          constructor(t2) {
            this.property = t2, this.value = new Hn(t2, void 0);
          }
          transitioned(t2, e3) {
            return new ti(this.property, this.value, e3, o({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new ti(this.property, this.value, null, {}, 0);
          }
        }
        class Qn {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
          }
          getValue(t2) {
            return p(this._values[t2].value.value);
          }
          setValue(t2, e3) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Wn(this._values[t2].property)), this._values[t2].value = new Hn(this._values[t2].property, null === e3 ? void 0 : p(e3));
          }
          getTransition(t2) {
            return p(this._values[t2].transition);
          }
          setTransition(t2, e3) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Wn(this._values[t2].property)), this._values[t2].transition = p(e3) || void 0;
          }
          serialize() {
            const t2 = {};
            for (const e3 of Object.keys(this._values)) {
              const r2 = this.getValue(e3);
              void 0 !== r2 && (t2[e3] = r2);
              const n2 = this.getTransition(e3);
              void 0 !== n2 && (t2[`${e3}-transition`] = n2);
            }
            return t2;
          }
          transitioned(t2, e3) {
            const r2 = new ei(this._properties);
            for (const n2 of Object.keys(this._values))
              r2._values[n2] = this._values[n2].transitioned(t2, e3._values[n2]);
            return r2;
          }
          untransitioned() {
            const t2 = new ei(this._properties);
            for (const e3 of Object.keys(this._values))
              t2._values[e3] = this._values[e3].untransitioned();
            return t2;
          }
        }
        class ti {
          constructor(t2, e3, r2, n2, i2) {
            this.property = t2, this.value = e3, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t2, e3, r2) {
            const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e3, r2), s2 = this.prior;
            if (s2) {
              if (n2 > this.end)
                return this.prior = null, i2;
              if (this.value.isDataDriven())
                return this.prior = null, i2;
              if (n2 < this.begin)
                return s2.possiblyEvaluate(t2, e3, r2);
              {
                const a2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s2.possiblyEvaluate(t2, e3, r2), i2, function(t3) {
                  if (t3 <= 0)
                    return 0;
                  if (t3 >= 1)
                    return 1;
                  const e4 = t3 * t3, r3 = e4 * t3;
                  return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e4) + r3 - 0.75);
                }(a2));
              }
            }
            return i2;
          }
        }
        class ei {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e3, r2) {
            const n2 = new ii(this._properties);
            for (const i2 of Object.keys(this._values))
              n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e3, r2);
            return n2;
          }
          hasTransition() {
            for (const t2 of Object.keys(this._values))
              if (this._values[t2].prior)
                return true;
            return false;
          }
        }
        class ri {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
          }
          getValue(t2) {
            return p(this._values[t2].value);
          }
          setValue(t2, e3) {
            this._values[t2] = new Hn(this._values[t2].property, null === e3 ? void 0 : p(e3));
          }
          serialize() {
            const t2 = {};
            for (const e3 of Object.keys(this._values)) {
              const r2 = this.getValue(e3);
              void 0 !== r2 && (t2[e3] = r2);
            }
            return t2;
          }
          possiblyEvaluate(t2, e3, r2) {
            const n2 = new ii(this._properties);
            for (const i2 of Object.keys(this._values))
              n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e3, r2);
            return n2;
          }
        }
        class ni {
          constructor(t2, e3, r2) {
            this.property = t2, this.value = e3, this.parameters = r2;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }
          evaluate(t2, e3, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e3, r2, n2);
          }
        }
        class ii {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class si {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e3) {
            return t2.expression.evaluate(e3);
          }
          interpolate(t2, e3, r2) {
            const n2 = ze[this.specification.type];
            return n2 ? n2(t2, e3, r2) : t2;
          }
        }
        class ai {
          constructor(t2, e3) {
            this.specification = t2, this.overrides = e3;
          }
          possiblyEvaluate(t2, e3, r2, n2) {
            return new ni(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e3, null, {}, r2, n2) } : t2.expression, e3);
          }
          interpolate(t2, e3, r2) {
            if ("constant" !== t2.value.kind || "constant" !== e3.value.kind)
              return t2;
            if (void 0 === t2.value.value || void 0 === e3.value.value)
              return new ni(this, { kind: "constant", value: void 0 }, t2.parameters);
            const n2 = ze[this.specification.type];
            return n2 ? new ni(this, { kind: "constant", value: n2(t2.value.value, e3.value.value, r2) }, t2.parameters) : t2;
          }
          evaluate(t2, e3, r2, n2, i2, s2) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e3, r2, n2, i2, s2);
          }
        }
        class oi extends ai {
          possiblyEvaluate(t2, e3, r2, n2) {
            if (void 0 === t2.value)
              return new ni(this, { kind: "constant", value: void 0 }, e3);
            if ("constant" === t2.expression.kind) {
              const i2 = t2.expression.evaluate(e3, null, {}, r2, n2), s2 = "resolvedImage" === t2.property.specification.type && "string" != typeof i2 ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e3);
              return new ni(this, { kind: "constant", value: a2 }, e3);
            }
            if ("camera" === t2.expression.kind) {
              const r3 = this._calculate(t2.expression.evaluate({ zoom: e3.zoom - 1 }), t2.expression.evaluate({ zoom: e3.zoom }), t2.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
              return new ni(this, { kind: "constant", value: r3 }, e3);
            }
            return new ni(this, t2.expression, e3);
          }
          evaluate(t2, e3, r2, n2, i2, s2) {
            if ("source" === t2.kind) {
              const a2 = t2.evaluate(e3, r2, n2, i2, s2);
              return this._calculate(a2, a2, a2, e3);
            }
            return "composite" === t2.kind ? this._calculate(t2.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e3.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r2, n2), e3) : t2.value;
          }
          _calculate(t2, e3, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e3 } : { from: r2, to: e3 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class li {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e3, r2, n2) {
            if (void 0 !== t2.value) {
              if ("constant" === t2.expression.kind) {
                const i2 = t2.expression.evaluate(e3, null, {}, r2, n2);
                return this._calculate(i2, i2, i2, e3);
              }
              return this._calculate(t2.expression.evaluate(new Yn(Math.floor(e3.zoom - 1), e3)), t2.expression.evaluate(new Yn(Math.floor(e3.zoom), e3)), t2.expression.evaluate(new Yn(Math.floor(e3.zoom + 1), e3)), e3);
            }
          }
          _calculate(t2, e3, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e3 } : { from: r2, to: e3 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class ui {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e3, r2, n2) {
            return !!t2.expression.evaluate(e3, null, {}, r2, n2);
          }
          interpolate() {
            return false;
          }
        }
        class ci {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e3 in t2) {
              const r2 = t2[e3];
              r2.specification.overridable && this.overridableProperties.push(e3);
              const n2 = this.defaultPropertyValues[e3] = new Hn(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e3] = new Wn(r2);
              this.defaultTransitioningPropertyValues[e3] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e3] = n2.possiblyEvaluate({});
            }
          }
        }
        kn("DataDrivenProperty", ai), kn("DataConstantProperty", si), kn("CrossFadedDataDrivenProperty", oi), kn("CrossFadedProperty", li), kn("ColorRampProperty", ui);
        const hi = "-transition";
        class pi extends rt {
          constructor(t2, e3) {
            if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t2.type && (this.metadata = (t2 = t2).metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e3.layout && (this._unevaluatedLayout = new ri(e3.layout)), e3.paint)) {
              this._transitionablePaint = new Qn(e3.paint);
              for (const e4 in t2.paint)
                this.setPaintProperty(e4, t2.paint[e4], { validate: false });
              for (const e4 in t2.layout)
                this.setLayoutProperty(e4, t2.layout[e4], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ii(e3.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t2) {
            return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          setLayoutProperty(t2, e3, r2 = {}) {
            null != e3 && this._validate(bn, `layers.${this.id}.layout.${t2}`, t2, e3, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e3) : this.visibility = e3);
          }
          getPaintProperty(t2) {
            return t2.endsWith(hi) ? this._transitionablePaint.getTransition(t2.slice(0, -hi.length)) : this._transitionablePaint.getValue(t2);
          }
          setPaintProperty(t2, e3, r2 = {}) {
            if (null != e3 && this._validate(vn, `layers.${this.id}.paint.${t2}`, t2, e3, r2))
              return false;
            if (t2.endsWith(hi))
              return this._transitionablePaint.setTransition(t2.slice(0, -hi.length), e3 || void 0), false;
            {
              const r3 = this._transitionablePaint._values[t2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), s2 = r3.value;
              this._transitionablePaint.setValue(t2, e3), this._handleSpecialPaintPropertyUpdate(t2);
              const a2 = this._transitionablePaint._values[t2].value;
              return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          _handleOverridablePaintPropertyUpdate(t2, e3, r2) {
            return false;
          }
          isHidden(t2) {
            return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t2, e3) {
            t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e3);
          }
          serialize() {
            const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), h(t2, (t3, e3) => !(void 0 === t3 || "layout" === e3 && !Object.keys(t3).length || "paint" === e3 && !Object.keys(t3).length));
          }
          _validate(t2, e3, r2, n2, i2 = {}) {
            return (!i2 || false !== i2.validate) && wn(this, t2.call(gn, { key: e3, layerType: this.type, objectKey: r2, value: n2, styleSpec: nt, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t2 in this.paint._values) {
              const e3 = this.paint.get(t2);
              if (e3 instanceof ni && xr(e3.property.specification) && ("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent)
                return true;
            }
            return false;
          }
        }
        const fi = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class di {
          constructor(t2, e3) {
            this._structArray = t2, this._pos1 = e3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class yi {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t2, e3) {
            return t2._trim(), e3 && (t2.isTransferred = true, e3.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            const e3 = Object.create(this.prototype);
            return e3.arrayBuffer = t2.arrayBuffer, e3.length = t2.length, e3.capacity = t2.arrayBuffer.byteLength / e3.bytesPerElement, e3._refreshViews(), e3;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e3 = this.uint8;
              this._refreshViews(), e3 && this.uint8.set(e3);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function mi(t2, e3 = 1) {
          let r2 = 0, n2 = 0;
          return { members: t2.map((t3) => {
            const i2 = fi[t3.type].BYTES_PER_ELEMENT, s2 = r2 = gi(r2, Math.max(e3, i2)), a2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
          }), size: gi(r2, Math.max(n2, e3)), alignment: e3 };
        }
        function gi(t2, e3) {
          return Math.ceil(t2 / e3) * e3;
        }
        class xi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e3);
          }
          emplace(t2, e3, r2) {
            const n2 = 2 * t2;
            return this.int16[n2 + 0] = e3, this.int16[n2 + 1] = r2, t2;
          }
        }
        xi.prototype.bytesPerElement = 4, kn("StructArrayLayout2i4", xi);
        class vi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e3, r2, n2);
          }
          emplace(t2, e3, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
          }
        }
        vi.prototype.bytesPerElement = 8, kn("StructArrayLayout4i8", vi);
        class bi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e3, r2, n2, i2, s2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        bi.prototype.bytesPerElement = 12, kn("StructArrayLayout2i4i12", bi);
        class wi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e3, r2, n2, i2, s2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2) {
            const o2 = 4 * t2, l2 = 8 * t2;
            return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = a2, t2;
          }
        }
        wi.prototype.bytesPerElement = 8, kn("StructArrayLayout2i4ub8", wi);
        class _i extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e3);
          }
          emplace(t2, e3, r2) {
            const n2 = 2 * t2;
            return this.float32[n2 + 0] = e3, this.float32[n2 + 1] = r2, t2;
          }
        }
        _i.prototype.bytesPerElement = 8, kn("StructArrayLayout2f8", _i);
        class Ai extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t2, e3, r2, n2, i2, s2, a2, o2, l2, u2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = 10 * t2;
            return this.uint16[h2 + 0] = e3, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
          }
        }
        Ai.prototype.bytesPerElement = 20, kn("StructArrayLayout10ui20", Ai);
        class ki extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
            const p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = 12 * t2;
            return this.int16[f2 + 0] = e3, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
          }
        }
        ki.prototype.bytesPerElement = 24, kn("StructArrayLayout4i4ui4i24", ki);
        class Si extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
          }
          emplace(t2, e3, r2, n2) {
            const i2 = 3 * t2;
            return this.float32[i2 + 0] = e3, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        Si.prototype.bytesPerElement = 12, kn("StructArrayLayout3f12", Si);
        class zi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t2);
          }
          emplace(t2, e3) {
            return this.uint32[1 * t2 + 0] = e3, t2;
          }
        }
        zi.prototype.bytesPerElement = 4, kn("StructArrayLayout1ul4", zi);
        class Ii extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t2, e3, r2, n2, i2, s2, a2, o2, l2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = 10 * t2, h2 = 5 * t2;
            return this.int16[c2 + 0] = e3, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
          }
        }
        Ii.prototype.bytesPerElement = 20, kn("StructArrayLayout6i1ul2ui20", Ii);
        class Mi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e3, r2, n2, i2, s2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        Mi.prototype.bytesPerElement = 12, kn("StructArrayLayout2i2i2i12", Mi);
        class Bi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e3, r2, n2, i2);
          }
          emplace(t2, e3, r2, n2, i2, s2) {
            const a2 = 4 * t2, o2 = 8 * t2;
            return this.float32[a2 + 0] = e3, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
          }
        }
        Bi.prototype.bytesPerElement = 16, kn("StructArrayLayout2f1f2i16", Bi);
        class Ci extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e3, r2, n2);
          }
          emplace(t2, e3, r2, n2, i2) {
            const s2 = 12 * t2, a2 = 3 * t2;
            return this.uint8[s2 + 0] = e3, this.uint8[s2 + 1] = r2, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
          }
        }
        Ci.prototype.bytesPerElement = 12, kn("StructArrayLayout2ub2f12", Ci);
        class Pi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
          }
          emplace(t2, e3, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[i2 + 0] = e3, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
          }
        }
        Pi.prototype.bytesPerElement = 6, kn("StructArrayLayout3ui6", Pi);
        class Vi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
            const g2 = this.length;
            return this.resize(g2 + 1), this.emplace(g2, t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
            const x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
            return this.int16[x2 + 0] = e3, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
          }
        }
        Vi.prototype.bytesPerElement = 48, kn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Vi);
        class Ei extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, z2, I2) {
            const M2 = this.length;
            return this.resize(M2 + 1), this.emplace(M2, t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, z2, I2);
          }
          emplace(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, z2, I2, M2) {
            const B2 = 34 * t2, C2 = 17 * t2;
            return this.int16[B2 + 0] = e3, this.int16[B2 + 1] = r2, this.int16[B2 + 2] = n2, this.int16[B2 + 3] = i2, this.int16[B2 + 4] = s2, this.int16[B2 + 5] = a2, this.int16[B2 + 6] = o2, this.int16[B2 + 7] = l2, this.uint16[B2 + 8] = u2, this.uint16[B2 + 9] = c2, this.uint16[B2 + 10] = h2, this.uint16[B2 + 11] = p2, this.uint16[B2 + 12] = f2, this.uint16[B2 + 13] = d2, this.uint16[B2 + 14] = y2, this.uint16[B2 + 15] = m2, this.uint16[B2 + 16] = g2, this.uint16[B2 + 17] = x2, this.uint16[B2 + 18] = v2, this.uint16[B2 + 19] = b2, this.uint16[B2 + 20] = w2, this.uint16[B2 + 21] = _2, this.uint16[B2 + 22] = A2, this.uint32[C2 + 12] = k2, this.float32[C2 + 13] = S2, this.float32[C2 + 14] = z2, this.float32[C2 + 15] = I2, this.float32[C2 + 16] = M2, t2;
          }
        }
        Ei.prototype.bytesPerElement = 68, kn("StructArrayLayout8i15ui1ul4f68", Ei);
        class Fi extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t2);
          }
          emplace(t2, e3) {
            return this.float32[1 * t2 + 0] = e3, t2;
          }
        }
        Fi.prototype.bytesPerElement = 4, kn("StructArrayLayout1f4", Fi);
        class Ti extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
          }
          emplace(t2, e3, r2, n2) {
            const i2 = 3 * t2;
            return this.int16[i2 + 0] = e3, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
          }
        }
        Ti.prototype.bytesPerElement = 6, kn("StructArrayLayout3i6", Ti);
        class Li extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
          }
          emplace(t2, e3, r2, n2) {
            const i2 = 4 * t2;
            return this.uint32[2 * t2 + 0] = e3, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
          }
        }
        Li.prototype.bytesPerElement = 8, kn("StructArrayLayout1ul2ui8", Li);
        class Di extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e3);
          }
          emplace(t2, e3, r2) {
            const n2 = 2 * t2;
            return this.uint16[n2 + 0] = e3, this.uint16[n2 + 1] = r2, t2;
          }
        }
        Di.prototype.bytesPerElement = 4, kn("StructArrayLayout2ui4", Di);
        class $i extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t2);
          }
          emplace(t2, e3) {
            return this.uint16[1 * t2 + 0] = e3, t2;
          }
        }
        $i.prototype.bytesPerElement = 2, kn("StructArrayLayout1ui2", $i);
        class Ri extends yi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e3, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e3, r2, n2);
          }
          emplace(t2, e3, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.float32[s2 + 0] = e3, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
          }
        }
        Ri.prototype.bytesPerElement = 16, kn("StructArrayLayout4f16", Ri);
        class Ui extends di {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new S(this.anchorPointX, this.anchorPointY);
          }
        }
        Ui.prototype.size = 20;
        class Oi extends Ii {
          get(t2) {
            return new Ui(this, t2);
          }
        }
        kn("CollisionBoxArray", Oi);
        class qi extends di {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 37] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 38] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 10] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        qi.prototype.size = 48;
        class ji extends Vi {
          get(t2) {
            return new qi(this, t2);
          }
        }
        kn("PlacedSymbolArray", ji);
        class Ni extends di {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 12] = t2;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 15];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 16];
          }
        }
        Ni.prototype.size = 68;
        class Ki extends Ei {
          get(t2) {
            return new Ni(this, t2);
          }
        }
        kn("SymbolInstanceArray", Ki);
        class Zi extends Fi {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        kn("GlyphOffsetArray", Zi);
        class Gi extends Ti {
          getx(t2) {
            return this.int16[3 * t2 + 0];
          }
          gety(t2) {
            return this.int16[3 * t2 + 1];
          }
          gettileUnitDistanceFromAnchor(t2) {
            return this.int16[3 * t2 + 2];
          }
        }
        kn("SymbolLineVertexArray", Gi);
        class Ji extends di {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        Ji.prototype.size = 8;
        class Xi extends Li {
          get(t2) {
            return new Ji(this, t2);
          }
        }
        kn("FeatureIndexArray", Xi);
        class Yi extends xi {
        }
        class Hi extends xi {
        }
        class Wi extends bi {
        }
        class Qi extends wi {
        }
        class ts extends _i {
        }
        class es extends Ai {
        }
        class rs extends ki {
        }
        class ns extends Si {
        }
        class is extends zi {
        }
        class ss extends Mi {
        }
        class as extends Ci {
        }
        class os extends Pi {
        }
        class ls extends Di {
        }
        const us = mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: cs } = us;
        class hs {
          constructor(t2 = []) {
            this.segments = t2;
          }
          prepareSegment(t2, e3, r2, n2) {
            let i2 = this.segments[this.segments.length - 1];
            return t2 > hs.MAX_VERTEX_ARRAY_LENGTH && d(`Max vertices per segment is ${hs.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > hs.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e3.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t2 of this.segments)
              for (const e3 in t2.vaos)
                t2.vaos[e3].destroy();
          }
          static simpleSegment(t2, e3, r2, n2) {
            return new hs([{ vertexOffset: t2, primitiveOffset: e3, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        function ps(t2, e3) {
          return 256 * (t2 = s(Math.floor(t2), 0, 255)) + s(Math.floor(e3), 0, 255);
        }
        hs.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, kn("SegmentVector", hs);
        const fs = mi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var ds = { exports: {} }, ys = { exports: {} };
        ys.exports = function(t2, e3) {
          var r2, n2, i2, s2, a2, o2, l2, u2;
          for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e3, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
            l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l2 = 0, r2) {
            case 3:
              l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
            case 2:
              l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
        var ms = { exports: {} };
        ms.exports = function(t2, e3) {
          for (var r2, n2 = t2.length, i2 = e3 ^ n2, s2 = 0; n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
        var gs = ys.exports, xs = ms.exports;
        ds.exports = gs, ds.exports.murmur3 = gs, ds.exports.murmur2 = xs;
        var vs = ds.exports;
        class bs {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t2, e3, r2, n2) {
            this.ids.push(ws(t2)), this.positions.push(e3, r2, n2);
          }
          getPositions(t2) {
            const e3 = ws(t2);
            let r2 = 0, n2 = this.ids.length - 1;
            for (; r2 < n2; ) {
              const t3 = r2 + n2 >> 1;
              this.ids[t3] >= e3 ? n2 = t3 : r2 = t3 + 1;
            }
            const i2 = [];
            for (; this.ids[r2] === e3; )
              i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return i2;
          }
          static serialize(t2, e3) {
            const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return _s(r2, n2, 0, r2.length - 1), e3 && e3.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
          }
          static deserialize(t2) {
            const e3 = new bs();
            return e3.ids = t2.ids, e3.positions = t2.positions, e3.indexed = true, e3;
          }
        }
        function ws(t2) {
          const e3 = +t2;
          return !isNaN(e3) && e3 <= Number.MAX_SAFE_INTEGER ? e3 : vs(String(t2));
        }
        function _s(t2, e3, r2, n2) {
          for (; r2 < n2; ) {
            const i2 = t2[r2 + n2 >> 1];
            let s2 = r2 - 1, a2 = n2 + 1;
            for (; ; ) {
              do {
                s2++;
              } while (t2[s2] < i2);
              do {
                a2--;
              } while (t2[a2] > i2);
              if (s2 >= a2)
                break;
              As(t2, s2, a2), As(e3, 3 * s2, 3 * a2), As(e3, 3 * s2 + 1, 3 * a2 + 1), As(e3, 3 * s2 + 2, 3 * a2 + 2);
            }
            a2 - r2 < n2 - a2 ? (_s(t2, e3, r2, a2), r2 = a2 + 1) : (_s(t2, e3, a2 + 1, n2), n2 = a2);
          }
        }
        function As(t2, e3, r2) {
          const n2 = t2[e3];
          t2[e3] = t2[r2], t2[r2] = n2;
        }
        kn("FeaturePositionMap", bs);
        class ks {
          constructor(t2, e3) {
            this.gl = t2.gl, this.location = e3;
          }
        }
        class Ss extends ks {
          constructor(t2, e3) {
            super(t2, e3), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
          }
        }
        class zs extends ks {
          constructor(t2, e3) {
            super(t2, e3), this.current = [0, 0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
          }
        }
        class Is extends ks {
          constructor(t2, e3) {
            super(t2, e3), this.current = Et.transparent;
          }
          set(t2) {
            t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
          }
        }
        const Ms = new Float32Array(16);
        function Bs(t2) {
          return [ps(255 * t2.r, 255 * t2.g), ps(255 * t2.b, 255 * t2.a)];
        }
        class Cs {
          constructor(t2, e3, r2) {
            this.value = t2, this.uniformNames = e3.map((t3) => `u_${t3}`), this.type = r2;
          }
          setUniform(t2, e3, r2) {
            t2.set(r2.constantOr(this.value));
          }
          getBinding(t2, e3, r2) {
            return "color" === this.type ? new Is(t2, e3) : new Ss(t2, e3);
          }
        }
        class Ps {
          constructor(t2, e3) {
            this.uniformNames = e3.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t2, e3) {
            this.pixelRatioFrom = e3.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e3.tlbr, this.patternTo = t2.tlbr;
          }
          setUniform(t2, e3, r2, n2) {
            const i2 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
            i2 && t2.set(i2);
          }
          getBinding(t2, e3, r2) {
            return "u_pattern" === r2.substr(0, 9) ? new zs(t2, e3) : new Ss(t2, e3);
          }
        }
        class Vs {
          constructor(t2, e3, r2, n2) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e3.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e3, r2, n2, i2) {
            const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new Yn(0), e3, {}, n2, [], i2);
            this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
          }
          updatePaintArray(t2, e3, r2, n2) {
            const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
            this._setPaintValue(t2, e3, i2);
          }
          _setPaintValue(t2, e3, r2) {
            if ("color" === this.type) {
              const n2 = Bs(r2);
              for (let r3 = t2; r3 < e3; r3++)
                this.paintVertexArray.emplace(r3, n2[0], n2[1]);
            } else {
              for (let n2 = t2; n2 < e3; n2++)
                this.paintVertexArray.emplace(n2, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Es {
          constructor(t2, e3, r2, n2, i2, s2) {
            this.expression = t2, this.uniformNames = e3.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e3.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
          }
          populatePaintArray(t2, e3, r2, n2, i2) {
            const s2 = this.expression.evaluate(new Yn(this.zoom), e3, {}, n2, [], i2), a2 = this.expression.evaluate(new Yn(this.zoom + 1), e3, {}, n2, [], i2), o2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
          }
          updatePaintArray(t2, e3, r2, n2) {
            const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
            this._setPaintValue(t2, e3, i2, s2);
          }
          _setPaintValue(t2, e3, r2, n2) {
            if ("color" === this.type) {
              const i2 = Bs(r2), s2 = Bs(n2);
              for (let r3 = t2; r3 < e3; r3++)
                this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
            } else {
              for (let i2 = t2; i2 < e3; i2++)
                this.paintVertexArray.emplace(i2, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e3) {
            const r2 = this.useIntegerZoom ? Math.floor(e3.zoom) : e3.zoom, n2 = s(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
            t2.set(n2);
          }
          getBinding(t2, e3, r2) {
            return new Ss(t2, e3);
          }
        }
        class Fs {
          constructor(t2, e3, r2, n2, i2, s2) {
            this.expression = t2, this.type = e3, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
          }
          populatePaintArray(t2, e3, r2) {
            const n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e3.patterns && e3.patterns[this.layerId], r2);
          }
          updatePaintArray(t2, e3, r2, n2, i2) {
            this._setPaintValues(t2, e3, r2.patterns && r2.patterns[this.layerId], i2);
          }
          _setPaintValues(t2, e3, r2, n2) {
            if (!n2 || !r2)
              return;
            const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l2 = n2[s2], u2 = n2[a2];
            if (o2 && l2 && u2)
              for (let r3 = t2; r3 < e3; r3++)
                this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
          }
          upload(t2) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, fs.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, fs.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Ts {
          constructor(t2, e3, r2) {
            this.binders = {}, this._buffers = [];
            const n2 = [];
            for (const i2 in t2.paint._values) {
              if (!r2(i2))
                continue;
              const s2 = t2.paint.get(i2);
              if (!(s2 instanceof ni && xr(s2.property.specification)))
                continue;
              const a2 = Ds(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
              if ("constant" === o2.kind)
                this.binders[i2] = h2 ? new Ps(o2.value, a2) : new Cs(o2.value, a2, l2), n2.push(`/u_${i2}`);
              else if ("source" === o2.kind || h2) {
                const r3 = $s(i2, l2, "source");
                this.binders[i2] = h2 ? new Fs(o2, l2, u2, e3, r3, t2.id) : new Vs(o2, a2, l2, r3), n2.push(`/a_${i2}`);
              } else {
                const t3 = $s(i2, l2, "composite");
                this.binders[i2] = new Es(o2, a2, l2, u2, e3, t3), n2.push(`/z_${i2}`);
              }
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t2) {
            const e3 = this.binders[t2];
            return e3 instanceof Vs || e3 instanceof Es ? e3.maxValue : 0;
          }
          populatePaintArrays(t2, e3, r2, n2, i2) {
            for (const s2 in this.binders) {
              const a2 = this.binders[s2];
              (a2 instanceof Vs || a2 instanceof Es || a2 instanceof Fs) && a2.populatePaintArray(t2, e3, r2, n2, i2);
            }
          }
          setConstantPatternPositions(t2, e3) {
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              n2 instanceof Ps && n2.setConstantPatternPositions(t2, e3);
            }
          }
          updatePaintArrays(t2, e3, r2, n2, i2) {
            let s2 = false;
            for (const a2 in t2) {
              const o2 = e3.getPositions(a2);
              for (const e4 of o2) {
                const o3 = r2.feature(e4.index);
                for (const r3 in this.binders) {
                  const l2 = this.binders[r3];
                  if ((l2 instanceof Vs || l2 instanceof Es || l2 instanceof Fs) && true === l2.expression.isStateDependent) {
                    const u2 = n2.paint.get(r3);
                    l2.expression = u2.value, l2.updatePaintArray(e4.start, e4.end, o3, t2[a2], i2), s2 = true;
                  }
                }
              }
            }
            return s2;
          }
          defines() {
            const t2 = [];
            for (const e3 in this.binders) {
              const r2 = this.binders[e3];
              (r2 instanceof Cs || r2 instanceof Ps) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
            }
            return t2;
          }
          getBinderAttributes() {
            const t2 = [];
            for (const e3 in this.binders) {
              const r2 = this.binders[e3];
              if (r2 instanceof Vs || r2 instanceof Es)
                for (let e4 = 0; e4 < r2.paintVertexAttributes.length; e4++)
                  t2.push(r2.paintVertexAttributes[e4].name);
              else if (r2 instanceof Fs)
                for (let e4 = 0; e4 < fs.members.length; e4++)
                  t2.push(fs.members[e4].name);
            }
            return t2;
          }
          getBinderUniforms() {
            const t2 = [];
            for (const e3 in this.binders) {
              const r2 = this.binders[e3];
              if (r2 instanceof Cs || r2 instanceof Ps || r2 instanceof Es)
                for (const e4 of r2.uniformNames)
                  t2.push(e4);
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2, e3) {
            const r2 = [];
            for (const n2 in this.binders) {
              const i2 = this.binders[n2];
              if (i2 instanceof Cs || i2 instanceof Ps || i2 instanceof Es) {
                for (const s2 of i2.uniformNames)
                  if (e3[s2]) {
                    const a2 = i2.getBinding(t2, e3[s2], s2);
                    r2.push({ name: s2, property: n2, binding: a2 });
                  }
              }
            }
            return r2;
          }
          setUniforms(t2, e3, r2, n2) {
            for (const { name: t3, property: i2, binding: s2 } of e3)
              this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
          }
          updatePaintBuffers(t2) {
            this._buffers = [];
            for (const e3 in this.binders) {
              const r2 = this.binders[e3];
              if (t2 && r2 instanceof Fs) {
                const e4 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                e4 && this._buffers.push(e4);
              } else
                (r2 instanceof Vs || r2 instanceof Es) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
            }
          }
          upload(t2) {
            for (const e3 in this.binders) {
              const r2 = this.binders[e3];
              (r2 instanceof Vs || r2 instanceof Es || r2 instanceof Fs) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t2 in this.binders) {
              const e3 = this.binders[t2];
              (e3 instanceof Vs || e3 instanceof Es || e3 instanceof Fs) && e3.destroy();
            }
          }
        }
        class Ls {
          constructor(t2, e3, r2 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t2)
              this.programConfigurations[n2.id] = new Ts(n2, e3, r2);
            this.needsUpload = false, this._featureMap = new bs(), this._bufferOffset = 0;
          }
          populatePaintArrays(t2, e3, r2, n2, i2, s2) {
            for (const r3 in this.programConfigurations)
              this.programConfigurations[r3].populatePaintArrays(t2, e3, n2, i2, s2);
            void 0 !== e3.id && this._featureMap.add(e3.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
          }
          updatePaintArrays(t2, e3, r2, n2) {
            for (const i2 of r2)
              this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e3, i2, n2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (const e3 in this.programConfigurations)
                this.programConfigurations[e3].upload(t2);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t2 in this.programConfigurations)
              this.programConfigurations[t2].destroy();
          }
        }
        function Ds(t2, e3) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e3}-`, "").replace(/-/g, "_")];
        }
        function $s(t2, e3, r2) {
          const n2 = { color: { source: _i, composite: Ri }, number: { source: Fi, composite: _i } }, i2 = function(t3) {
            return { "line-pattern": { source: es, composite: es }, "fill-pattern": { source: es, composite: es }, "fill-extrusion-pattern": { source: es, composite: es } }[t3];
          }(t2);
          return i2 && i2[r2] || n2[e3][r2];
        }
        kn("ConstantBinder", Cs), kn("CrossFadedConstantBinder", Ps), kn("SourceExpressionBinder", Vs), kn("CrossFadedCompositeBinder", Fs), kn("CompositeExpressionBinder", Es), kn("ProgramConfiguration", Ts, { omit: ["_buffers"] }), kn("ProgramConfigurationSet", Ls);
        var Rs = 8192;
        const Us = Math.pow(2, 14) - 1, Os = -Us - 1;
        function qs(t2) {
          const e3 = Rs / t2.extent, r2 = t2.loadGeometry();
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n2 = r2[t3];
            for (let t4 = 0; t4 < n2.length; t4++) {
              const r3 = n2[t4], i2 = Math.round(r3.x * e3), a2 = Math.round(r3.y * e3);
              r3.x = s(i2, Os, Us), r3.y = s(a2, Os, Us), (i2 < r3.x || i2 > r3.x + 1 || a2 < r3.y || a2 > r3.y + 1) && d("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r2;
        }
        function js(t2, e3) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e3 ? qs(t2) : [] };
        }
        function Ns(t2, e3, r2, n2, i2) {
          t2.emplaceBack(2 * e3 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
        }
        class Ks {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Yi(), this.indexArray = new os(), this.segments = new hs(), this.programConfigurations = new Ls(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e3, r2) {
            const n2 = this.layers[0], i2 = [];
            let s2 = null, a2 = false;
            "circle" === n2.type && (s2 = n2.layout.get("circle-sort-key"), a2 = !s2.isConstant());
            for (const { feature: e4, id: n3, index: o2, sourceLayerIndex: l2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = js(e4, t3);
              if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), u2, r2))
                continue;
              const c2 = a2 ? s2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : qs(e4), patterns: {}, sortKey: c2 };
              i2.push(h2);
            }
            a2 && i2.sort((t3, e4) => t3.sortKey - e4.sortKey);
            for (const n3 of i2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o2 = t2[s3].feature;
              this.addFeature(n3, i3, s3, r2), e3.featureIndex.insert(o2, i3, s3, a3, this.index);
            }
          }
          update(t2, e3, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e3, r2, n2) {
            for (const r3 of e3)
              for (const e4 of r3) {
                const r4 = e4.x, n3 = e4.y;
                if (r4 < 0 || r4 >= Rs || n3 < 0 || n3 >= Rs)
                  continue;
                const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
                Ns(this.layoutVertexArray, r4, n3, -1, -1), Ns(this.layoutVertexArray, r4, n3, 1, -1), Ns(this.layoutVertexArray, r4, n3, 1, 1), Ns(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
          }
        }
        function Zs(t2, e3) {
          for (let r2 = 0; r2 < t2.length; r2++)
            if (ea(e3, t2[r2]))
              return true;
          for (let r2 = 0; r2 < e3.length; r2++)
            if (ea(t2, e3[r2]))
              return true;
          return !!Ys(t2, e3);
        }
        function Gs(t2, e3, r2) {
          return !!ea(t2, e3) || !!Ws(e3, t2, r2);
        }
        function Js(t2, e3) {
          if (1 === t2.length)
            return ta(e3, t2[0]);
          for (let r2 = 0; r2 < e3.length; r2++) {
            const n2 = e3[r2];
            for (let e4 = 0; e4 < n2.length; e4++)
              if (ea(t2, n2[e4]))
                return true;
          }
          for (let r2 = 0; r2 < t2.length; r2++)
            if (ta(e3, t2[r2]))
              return true;
          for (let r2 = 0; r2 < e3.length; r2++)
            if (Ys(t2, e3[r2]))
              return true;
          return false;
        }
        function Xs(t2, e3, r2) {
          if (t2.length > 1) {
            if (Ys(t2, e3))
              return true;
            for (let n2 = 0; n2 < e3.length; n2++)
              if (Ws(e3[n2], t2, r2))
                return true;
          }
          for (let n2 = 0; n2 < t2.length; n2++)
            if (Ws(t2[n2], e3, r2))
              return true;
          return false;
        }
        function Ys(t2, e3) {
          if (0 === t2.length || 0 === e3.length)
            return false;
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            const n2 = t2[r2], i2 = t2[r2 + 1];
            for (let t3 = 0; t3 < e3.length - 1; t3++)
              if (Hs(n2, i2, e3[t3], e3[t3 + 1]))
                return true;
          }
          return false;
        }
        function Hs(t2, e3, r2, n2) {
          return y(t2, r2, n2) !== y(e3, r2, n2) && y(t2, e3, r2) !== y(t2, e3, n2);
        }
        function Ws(t2, e3, r2) {
          const n2 = r2 * r2;
          if (1 === e3.length)
            return t2.distSqr(e3[0]) < n2;
          for (let r3 = 1; r3 < e3.length; r3++)
            if (Qs(t2, e3[r3 - 1], e3[r3]) < n2)
              return true;
          return false;
        }
        function Qs(t2, e3, r2) {
          const n2 = e3.distSqr(r2);
          if (0 === n2)
            return t2.distSqr(e3);
          const i2 = ((t2.x - e3.x) * (r2.x - e3.x) + (t2.y - e3.y) * (r2.y - e3.y)) / n2;
          return t2.distSqr(i2 < 0 ? e3 : i2 > 1 ? r2 : r2.sub(e3)._mult(i2)._add(e3));
        }
        function ta(t2, e3) {
          let r2, n2, i2, s2 = false;
          for (let a2 = 0; a2 < t2.length; a2++) {
            r2 = t2[a2];
            for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
              n2 = r2[t3], i2 = r2[a3], n2.y > e3.y != i2.y > e3.y && e3.x < (i2.x - n2.x) * (e3.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
          }
          return s2;
        }
        function ea(t2, e3) {
          let r2 = false;
          for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            const s2 = t2[n2], a2 = t2[i2];
            s2.y > e3.y != a2.y > e3.y && e3.x < (a2.x - s2.x) * (e3.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
          }
          return r2;
        }
        function ra(t2, e3, r2) {
          const n2 = r2[0], i2 = r2[2];
          if (t2.x < n2.x && e3.x < n2.x || t2.x > i2.x && e3.x > i2.x || t2.y < n2.y && e3.y < n2.y || t2.y > i2.y && e3.y > i2.y)
            return false;
          const s2 = y(t2, e3, r2[0]);
          return s2 !== y(t2, e3, r2[1]) || s2 !== y(t2, e3, r2[2]) || s2 !== y(t2, e3, r2[3]);
        }
        function na(t2, e3, r2) {
          const n2 = e3.paint.get(t2).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e3.id).getMaxValue(t2);
        }
        function ia(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function sa(t2, e3, r2, n2, i2) {
          if (!e3[0] && !e3[1])
            return t2;
          const s2 = S.convert(e3)._mult(i2);
          "viewport" === r2 && s2._rotate(-n2);
          const a2 = [];
          for (let e4 = 0; e4 < t2.length; e4++)
            a2.push(t2[e4].sub(s2));
          return a2;
        }
        kn("CircleBucket", Ks, { omit: ["layers"] });
        const aa = new ci({ "circle-sort-key": new ai(nt.layout_circle["circle-sort-key"]) });
        var oa = { paint: new ci({ "circle-radius": new ai(nt.paint_circle["circle-radius"]), "circle-color": new ai(nt.paint_circle["circle-color"]), "circle-blur": new ai(nt.paint_circle["circle-blur"]), "circle-opacity": new ai(nt.paint_circle["circle-opacity"]), "circle-translate": new si(nt.paint_circle["circle-translate"]), "circle-translate-anchor": new si(nt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new si(nt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new si(nt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ai(nt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ai(nt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ai(nt.paint_circle["circle-stroke-opacity"]) }), layout: aa }, la = "undefined" != typeof Float32Array ? Float32Array : Array;
        function ua(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function ca(t2, e3, r2) {
          var n2 = e3[0], i2 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h2 = e3[8], p2 = e3[9], f2 = e3[10], d2 = e3[11], y2 = e3[12], m2 = e3[13], g2 = e3[14], x2 = e3[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
          return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, e3 = arguments.length; e3--; )
            t2 += arguments[e3] * arguments[e3];
          return Math.sqrt(t2);
        });
        var ha, pa = ca;
        function fa(t2, e3, r2) {
          var n2 = e3[0], i2 = e3[1], s2 = e3[2], a2 = e3[3];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
        }
        function da(t2, e3) {
          const r2 = fa([], [t2.x, t2.y, 0, 1], e3);
          return new S(r2[0] / r2[3], r2[1] / r2[3]);
        }
        ha = new la(4), la != Float32Array && (ha[0] = 0, ha[1] = 0, ha[2] = 0, ha[3] = 0);
        class ya extends Ks {
        }
        kn("HeatmapBucket", ya, { omit: ["layers"] });
        var ma = { paint: new ci({ "heatmap-radius": new ai(nt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ai(nt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new si(nt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ui(nt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new si(nt.paint_heatmap["heatmap-opacity"]) }) };
        function ga(t2, { width: e3, height: r2 }, n2, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray)
              i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e3 * r2 * n2)
              throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e3 * r2 * n2}`);
          } else
            i2 = new Uint8Array(e3 * r2 * n2);
          return t2.width = e3, t2.height = r2, t2.data = i2, t2;
        }
        function xa(t2, { width: e3, height: r2 }, n2) {
          if (e3 === t2.width && r2 === t2.height)
            return;
          const i2 = ga({}, { width: e3, height: r2 }, n2);
          va(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e3), height: Math.min(t2.height, r2) }, n2), t2.width = e3, t2.height = r2, t2.data = i2.data;
        }
        function va(t2, e3, r2, n2, i2, s2) {
          if (0 === i2.width || 0 === i2.height)
            return e3;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e3.width || i2.height > e3.height || n2.x > e3.width - i2.width || n2.y > e3.height - i2.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const a2 = t2.data, o2 = e3.data;
          for (let l2 = 0; l2 < i2.height; l2++) {
            const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e3.width + n2.x) * s2;
            for (let t3 = 0; t3 < i2.width * s2; t3++)
              o2[c2 + t3] = a2[u2 + t3];
          }
          return e3;
        }
        class ba {
          constructor(t2, e3) {
            ga(this, t2, 1, e3);
          }
          resize(t2) {
            xa(this, t2, 1);
          }
          clone() {
            return new ba({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e3, r2, n2, i2) {
            va(t2, e3, r2, n2, i2, 1);
          }
        }
        class wa {
          constructor(t2, e3) {
            ga(this, t2, 4, e3);
          }
          resize(t2) {
            xa(this, t2, 4);
          }
          replace(t2, e3) {
            e3 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new wa({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e3, r2, n2, i2) {
            va(t2, e3, r2, n2, i2, 4);
          }
        }
        function _a2(t2) {
          const e3 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new wa({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
            e3[t2.evaluationKey] = s3;
            const a2 = t2.expression.evaluate(e3);
            i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
          };
          if (t2.clips)
            for (let e4 = 0, i3 = 0; e4 < n2; ++e4, i3 += 4 * r2)
              for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
                const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e4];
                s2(i3, a2, l2 * (1 - o2) + u2 * o2);
              }
          else
            for (let t3 = 0, e4 = 0; t3 < r2; t3++, e4 += 4)
              s2(0, e4, t3 / (r2 - 1));
          return i2;
        }
        kn("AlphaImage", ba), kn("RGBAImage", wa);
        var Aa = { paint: new ci({ "hillshade-illumination-direction": new si(nt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new si(nt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new si(nt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new si(nt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new si(nt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new si(nt.paint_hillshade["hillshade-accent-color"]) }) };
        const ka = mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Sa } = ka;
        var za = { exports: {} };
        function Ia(t2, e3, r2) {
          r2 = r2 || 2;
          var n2, i2, s2, a2, o2, l2, u2, c2 = e3 && e3.length, h2 = c2 ? e3[0] * r2 : t2.length, p2 = Ma(t2, 0, h2, r2, true), f2 = [];
          if (!p2 || p2.next === p2.prev)
            return f2;
          if (c2 && (p2 = function(t3, e4, r3, n3) {
            var i3, s3, a3, o3 = [];
            for (i3 = 0, s3 = e4.length; i3 < s3; i3++)
              (a3 = Ma(t3, e4[i3] * n3, i3 < s3 - 1 ? e4[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(Ra(a3));
            for (o3.sort(Ta), i3 = 0; i3 < o3.length; i3++)
              r3 = Ba(r3 = La(o3[i3], r3), r3.next);
            return r3;
          }(t2, e3, p2, r2)), t2.length > 80 * r2) {
            n2 = s2 = t2[0], i2 = a2 = t2[1];
            for (var d2 = r2; d2 < h2; d2 += r2)
              (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
            u2 = 0 !== (u2 = Math.max(s2 - n2, a2 - i2)) ? 1 / u2 : 0;
          }
          return Ca(p2, f2, r2, n2, i2, u2), f2;
        }
        function Ma(t2, e3, r2, n2, i2) {
          var s2, a2;
          if (i2 === Wa(t2, e3, r2, n2) > 0)
            for (s2 = e3; s2 < r2; s2 += n2)
              a2 = Xa(s2, t2[s2], t2[s2 + 1], a2);
          else
            for (s2 = r2 - n2; s2 >= e3; s2 -= n2)
              a2 = Xa(s2, t2[s2], t2[s2 + 1], a2);
          return a2 && ja(a2, a2.next) && (Ya(a2), a2 = a2.next), a2;
        }
        function Ba(t2, e3) {
          if (!t2)
            return t2;
          e3 || (e3 = t2);
          var r2, n2 = t2;
          do {
            if (r2 = false, n2.steiner || !ja(n2, n2.next) && 0 !== qa(n2.prev, n2, n2.next))
              n2 = n2.next;
            else {
              if (Ya(n2), (n2 = e3 = n2.prev) === n2.next)
                break;
              r2 = true;
            }
          } while (r2 || n2 !== e3);
          return e3;
        }
        function Ca(t2, e3, r2, n2, i2, s2, a2) {
          if (t2) {
            !a2 && s2 && function(t3, e4, r3, n3) {
              var i3 = t3;
              do {
                null === i3.z && (i3.z = $a(i3.x, i3.y, e4, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                var e5, r4, n4, i4, s3, a3, o3, l3, u3 = 1;
                do {
                  for (r4 = t4, t4 = null, s3 = null, a3 = 0; r4; ) {
                    for (a3++, n4 = r4, o3 = 0, e5 = 0; e5 < u3 && (o3++, n4 = n4.nextZ); e5++)
                      ;
                    for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                      0 !== o3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                    r4 = n4;
                  }
                  s3.nextZ = null, u3 *= 2;
                } while (a3 > 1);
              }(i3);
            }(t2, n2, i2, s2);
            for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
              if (o2 = t2.prev, l2 = t2.next, s2 ? Va(t2, n2, i2, s2) : Pa(t2))
                e3.push(o2.i / r2), e3.push(t2.i / r2), e3.push(l2.i / r2), Ya(t2), t2 = l2.next, u2 = l2.next;
              else if ((t2 = l2) === u2) {
                a2 ? 1 === a2 ? Ca(t2 = Ea(Ba(t2), e3, r2), e3, r2, n2, i2, s2, 2) : 2 === a2 && Fa(t2, e3, r2, n2, i2, s2) : Ca(Ba(t2), e3, r2, n2, i2, s2, 1);
                break;
              }
          }
        }
        function Pa(t2) {
          var e3 = t2.prev, r2 = t2, n2 = t2.next;
          if (qa(e3, r2, n2) >= 0)
            return false;
          for (var i2 = t2.next.next; i2 !== t2.prev; ) {
            if (Ua(e3.x, e3.y, r2.x, r2.y, n2.x, n2.y, i2.x, i2.y) && qa(i2.prev, i2, i2.next) >= 0)
              return false;
            i2 = i2.next;
          }
          return true;
        }
        function Va(t2, e3, r2, n2) {
          var i2 = t2.prev, s2 = t2, a2 = t2.next;
          if (qa(i2, s2, a2) >= 0)
            return false;
          for (var o2 = i2.x > s2.x ? i2.x > a2.x ? i2.x : a2.x : s2.x > a2.x ? s2.x : a2.x, l2 = i2.y > s2.y ? i2.y > a2.y ? i2.y : a2.y : s2.y > a2.y ? s2.y : a2.y, u2 = $a(i2.x < s2.x ? i2.x < a2.x ? i2.x : a2.x : s2.x < a2.x ? s2.x : a2.x, i2.y < s2.y ? i2.y < a2.y ? i2.y : a2.y : s2.y < a2.y ? s2.y : a2.y, e3, r2, n2), c2 = $a(o2, l2, e3, r2, n2), h2 = t2.prevZ, p2 = t2.nextZ; h2 && h2.z >= u2 && p2 && p2.z <= c2; ) {
            if (h2 !== t2.prev && h2 !== t2.next && Ua(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && qa(h2.prev, h2, h2.next) >= 0)
              return false;
            if (h2 = h2.prevZ, p2 !== t2.prev && p2 !== t2.next && Ua(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && qa(p2.prev, p2, p2.next) >= 0)
              return false;
            p2 = p2.nextZ;
          }
          for (; h2 && h2.z >= u2; ) {
            if (h2 !== t2.prev && h2 !== t2.next && Ua(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && qa(h2.prev, h2, h2.next) >= 0)
              return false;
            h2 = h2.prevZ;
          }
          for (; p2 && p2.z <= c2; ) {
            if (p2 !== t2.prev && p2 !== t2.next && Ua(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && qa(p2.prev, p2, p2.next) >= 0)
              return false;
            p2 = p2.nextZ;
          }
          return true;
        }
        function Ea(t2, e3, r2) {
          var n2 = t2;
          do {
            var i2 = n2.prev, s2 = n2.next.next;
            !ja(i2, s2) && Na(i2, n2, n2.next, s2) && Ga(i2, s2) && Ga(s2, i2) && (e3.push(i2.i / r2), e3.push(n2.i / r2), e3.push(s2.i / r2), Ya(n2), Ya(n2.next), n2 = t2 = s2), n2 = n2.next;
          } while (n2 !== t2);
          return Ba(n2);
        }
        function Fa(t2, e3, r2, n2, i2, s2) {
          var a2 = t2;
          do {
            for (var o2 = a2.next.next; o2 !== a2.prev; ) {
              if (a2.i !== o2.i && Oa(a2, o2)) {
                var l2 = Ja(a2, o2);
                return a2 = Ba(a2, a2.next), l2 = Ba(l2, l2.next), Ca(a2, e3, r2, n2, i2, s2), void Ca(l2, e3, r2, n2, i2, s2);
              }
              o2 = o2.next;
            }
            a2 = a2.next;
          } while (a2 !== t2);
        }
        function Ta(t2, e3) {
          return t2.x - e3.x;
        }
        function La(t2, e3) {
          var r2 = function(t3, e4) {
            var r3, n3 = e4, i3 = t3.x, s2 = t3.y, a2 = -1 / 0;
            do {
              if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
                var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                if (o2 <= i3 && o2 > a2) {
                  if (a2 = o2, o2 === i3) {
                    if (s2 === n3.y)
                      return n3;
                    if (s2 === n3.next.y)
                      return n3.next;
                  }
                  r3 = n3.x < n3.next.x ? n3 : n3.next;
                }
              }
              n3 = n3.next;
            } while (n3 !== e4);
            if (!r3)
              return null;
            if (i3 === a2)
              return r3;
            var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
            n3 = r3;
            do {
              i3 >= n3.x && n3.x >= c2 && i3 !== n3.x && Ua(s2 < h2 ? i3 : a2, s2, c2, h2, s2 < h2 ? a2 : i3, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (i3 - n3.x), Ga(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && Da(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
            } while (n3 !== u2);
            return r3;
          }(t2, e3);
          if (!r2)
            return e3;
          var n2 = Ja(r2, t2), i2 = Ba(r2, r2.next);
          return Ba(n2, n2.next), e3 === r2 ? i2 : e3;
        }
        function Da(t2, e3) {
          return qa(t2.prev, t2, e3.prev) < 0 && qa(e3.next, t2, t2.next) < 0;
        }
        function $a(t2, e3, r2, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - r2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = 32767 * (e3 - n2) * i2) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) << 1;
        }
        function Ra(t2) {
          var e3 = t2, r2 = t2;
          do {
            (e3.x < r2.x || e3.x === r2.x && e3.y < r2.y) && (r2 = e3), e3 = e3.next;
          } while (e3 !== t2);
          return r2;
        }
        function Ua(t2, e3, r2, n2, i2, s2, a2, o2) {
          return (i2 - a2) * (e3 - o2) - (t2 - a2) * (s2 - o2) >= 0 && (t2 - a2) * (n2 - o2) - (r2 - a2) * (e3 - o2) >= 0 && (r2 - a2) * (s2 - o2) - (i2 - a2) * (n2 - o2) >= 0;
        }
        function Oa(t2, e3) {
          return t2.next.i !== e3.i && t2.prev.i !== e3.i && !function(t3, e4) {
            var r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e4.i && r2.next.i !== e4.i && Na(r2, r2.next, t3, e4))
                return true;
              r2 = r2.next;
            } while (r2 !== t3);
            return false;
          }(t2, e3) && (Ga(t2, e3) && Ga(e3, t2) && function(t3, e4) {
            var r2 = t3, n2 = false, i2 = (t3.x + e4.x) / 2, s2 = (t3.y + e4.y) / 2;
            do {
              r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t3);
            return n2;
          }(t2, e3) && (qa(t2.prev, t2, e3.prev) || qa(t2, e3.prev, e3)) || ja(t2, e3) && qa(t2.prev, t2, t2.next) > 0 && qa(e3.prev, e3, e3.next) > 0);
        }
        function qa(t2, e3, r2) {
          return (e3.y - t2.y) * (r2.x - e3.x) - (e3.x - t2.x) * (r2.y - e3.y);
        }
        function ja(t2, e3) {
          return t2.x === e3.x && t2.y === e3.y;
        }
        function Na(t2, e3, r2, n2) {
          var i2 = Za(qa(t2, e3, r2)), s2 = Za(qa(t2, e3, n2)), a2 = Za(qa(r2, n2, t2)), o2 = Za(qa(r2, n2, e3));
          return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Ka(t2, r2, e3)) || !(0 !== s2 || !Ka(t2, n2, e3)) || !(0 !== a2 || !Ka(r2, t2, n2)) || !(0 !== o2 || !Ka(r2, e3, n2));
        }
        function Ka(t2, e3, r2) {
          return e3.x <= Math.max(t2.x, r2.x) && e3.x >= Math.min(t2.x, r2.x) && e3.y <= Math.max(t2.y, r2.y) && e3.y >= Math.min(t2.y, r2.y);
        }
        function Za(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function Ga(t2, e3) {
          return qa(t2.prev, t2, t2.next) < 0 ? qa(t2, e3, t2.next) >= 0 && qa(t2, t2.prev, e3) >= 0 : qa(t2, e3, t2.prev) < 0 || qa(t2, t2.next, e3) < 0;
        }
        function Ja(t2, e3) {
          var r2 = new Ha(t2.i, t2.x, t2.y), n2 = new Ha(e3.i, e3.x, e3.y), i2 = t2.next, s2 = e3.prev;
          return t2.next = e3, e3.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
        }
        function Xa(t2, e3, r2, n2) {
          var i2 = new Ha(t2, e3, r2);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function Ya(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function Ha(t2, e3, r2) {
          this.i = t2, this.x = e3, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Wa(t2, e3, r2, n2) {
          for (var i2 = 0, s2 = e3, a2 = r2 - n2; s2 < r2; s2 += n2)
            i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
          return i2;
        }
        za.exports = Ia, za.exports.default = Ia, Ia.deviation = function(t2, e3, r2, n2) {
          var i2 = e3 && e3.length, s2 = Math.abs(Wa(t2, 0, i2 ? e3[0] * r2 : t2.length, r2));
          if (i2)
            for (var a2 = 0, o2 = e3.length; a2 < o2; a2++)
              s2 -= Math.abs(Wa(t2, e3[a2] * r2, a2 < o2 - 1 ? e3[a2 + 1] * r2 : t2.length, r2));
          var l2 = 0;
          for (a2 = 0; a2 < n2.length; a2 += 3) {
            var u2 = n2[a2] * r2, c2 = n2[a2 + 1] * r2, h2 = n2[a2 + 2] * r2;
            l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
          }
          return 0 === s2 && 0 === l2 ? 0 : Math.abs((l2 - s2) / s2);
        }, Ia.flatten = function(t2) {
          for (var e3 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e3 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
            for (var s2 = 0; s2 < t2[i2].length; s2++)
              for (var a2 = 0; a2 < e3; a2++)
                r2.vertices.push(t2[i2][s2][a2]);
            i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
          }
          return r2;
        };
        var Qa = za.exports;
        function to(t2, e3, r2, n2, i2) {
          eo(t2, e3, r2 || 0, n2 || t2.length - 1, i2 || no);
        }
        function eo(t2, e3, r2, n2, i2) {
          for (; n2 > r2; ) {
            if (n2 - r2 > 600) {
              var s2 = n2 - r2 + 1, a2 = e3 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
              eo(t2, e3, Math.max(r2, Math.floor(e3 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e3 + (s2 - a2) * l2 / s2 + u2)), i2);
            }
            var c2 = t2[e3], h2 = r2, p2 = n2;
            for (ro(t2, r2, e3), i2(t2[n2], c2) > 0 && ro(t2, r2, n2); h2 < p2; ) {
              for (ro(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
                h2++;
              for (; i2(t2[p2], c2) > 0; )
                p2--;
            }
            0 === i2(t2[r2], c2) ? ro(t2, r2, p2) : ro(t2, ++p2, n2), p2 <= e3 && (r2 = p2 + 1), e3 <= p2 && (n2 = p2 - 1);
          }
        }
        function ro(t2, e3, r2) {
          var n2 = t2[e3];
          t2[e3] = t2[r2], t2[r2] = n2;
        }
        function no(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }
        function io(t2, e3) {
          const r2 = t2.length;
          if (r2 <= 1)
            return [t2];
          const n2 = [];
          let i2, s2;
          for (let e4 = 0; e4 < r2; e4++) {
            const r3 = m(t2[e4]);
            0 !== r3 && (t2[e4].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e4]]) : i2.push(t2[e4]));
          }
          if (i2 && n2.push(i2), e3 > 1)
            for (let t3 = 0; t3 < n2.length; t3++)
              n2[t3].length <= e3 || (to(n2[t3], e3, 1, n2[t3].length - 1, so), n2[t3] = n2[t3].slice(0, e3));
          return n2;
        }
        function so(t2, e3) {
          return e3.area - t2.area;
        }
        function ao(t2, e3, r2) {
          const n2 = r2.patternDependencies;
          let i2 = false;
          for (const r3 of e3) {
            const e4 = r3.paint.get(`${t2}-pattern`);
            e4.isConstant() || (i2 = true);
            const s2 = e4.constantOr(null);
            s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
          }
          return i2;
        }
        function oo(t2, e3, r2, n2, i2) {
          const s2 = i2.patternDependencies;
          for (const a2 of e3) {
            const e4 = a2.paint.get(`${t2}-pattern`).value;
            if ("constant" !== e4.kind) {
              let t3 = e4.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e4.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e4.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
            }
          }
          return r2;
        }
        class lo {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Hi(), this.indexArray = new os(), this.indexArray2 = new ls(), this.programConfigurations = new Ls(t2.layers, t2.zoom), this.segments = new hs(), this.segments2 = new hs(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e3, r2) {
            this.hasPattern = ao("fill", this.layers, e3);
            const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c2 = js(a2, t3);
              if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), c2, r2))
                continue;
              const h2 = i2 ? n2.evaluate(c2, {}, r2, e3.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : qs(a2), patterns: {}, sortKey: h2 };
              s2.push(p2);
            }
            i2 && s2.sort((t3, e4) => t3.sortKey - e4.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = oo("fill", this.layers, n3, this.zoom, e3);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n3, i3, s3, r2, {});
              e3.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e3, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e3, r2) {
            for (const t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e3, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Sa), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t2, e3, r2, n2, i2) {
            for (const t3 of io(e3, 500)) {
              let e4 = 0;
              for (const r4 of t3)
                e4 += r4.length;
              const r3 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s2 = [];
              for (const e5 of t3) {
                if (0 === e5.length)
                  continue;
                e5 !== t3[0] && s2.push(i3.length / 2);
                const r4 = this.segments2.prepareSegment(e5.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                this.layoutVertexArray.emplaceBack(e5[0].x, e5[0].y), this.indexArray2.emplaceBack(n4 + e5.length - 1, n4), i3.push(e5[0].x), i3.push(e5[0].y);
                for (let t4 = 1; t4 < e5.length; t4++)
                  this.layoutVertexArray.emplaceBack(e5[t4].x, e5[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e5[t4].x), i3.push(e5[t4].y);
                r4.vertexLength += e5.length, r4.primitiveLength += e5.length;
              }
              const a2 = Qa(i3, s2);
              for (let t4 = 0; t4 < a2.length; t4 += 3)
                this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
              r3.vertexLength += e4, r3.primitiveLength += a2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        kn("FillBucket", lo, { omit: ["layers", "patternFeatures"] });
        const uo = new ci({ "fill-sort-key": new ai(nt.layout_fill["fill-sort-key"]) });
        var co = { paint: new ci({ "fill-antialias": new si(nt.paint_fill["fill-antialias"]), "fill-opacity": new ai(nt.paint_fill["fill-opacity"]), "fill-color": new ai(nt.paint_fill["fill-color"]), "fill-outline-color": new ai(nt.paint_fill["fill-outline-color"]), "fill-translate": new si(nt.paint_fill["fill-translate"]), "fill-translate-anchor": new si(nt.paint_fill["fill-translate-anchor"]), "fill-pattern": new oi(nt.paint_fill["fill-pattern"]) }), layout: uo };
        const ho = mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), { members: po } = ho;
        var fo = {}, yo = S, mo = go;
        function go(t2, e3, r2, n2, i2) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(xo, this, e3);
        }
        function xo(t2, e3, r2) {
          1 == t2 ? e3.id = r2.readVarint() : 2 == t2 ? function(t3, e4) {
            for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = e4._keys[t3.readVarint()], i2 = e4._values[t3.readVarint()];
              e4.properties[n2] = i2;
            }
          }(r2, e3) : 3 == t2 ? e3.type = r2.readVarint() : 4 == t2 && (e3._geometry = r2.pos);
        }
        function vo(t2) {
          for (var e3, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
            n2 += ((r2 = t2[a2]).x - (e3 = t2[i2]).x) * (e3.y + r2.y);
          return n2;
        }
        go.types = ["Unknown", "Point", "LineString", "Polygon"], go.prototype.loadGeometry = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e3, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
            if (i2 <= 0) {
              var l2 = t2.readVarint();
              n2 = 7 & l2, i2 = l2 >> 3;
            }
            if (i2--, 1 === n2 || 2 === n2)
              s2 += t2.readSVarint(), a2 += t2.readSVarint(), 1 === n2 && (e3 && o2.push(e3), e3 = []), e3.push(new yo(s2, a2));
            else {
              if (7 !== n2)
                throw new Error("unknown command " + n2);
              e3 && e3.push(e3[0].clone());
            }
          }
          return e3 && o2.push(e3), o2;
        }, go.prototype.bbox = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e3 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e3; ) {
            if (n2 <= 0) {
              var c2 = t2.readVarint();
              r2 = 7 & c2, n2 = c2 >> 3;
            }
            if (n2--, 1 === r2 || 2 === r2)
              (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
            else if (7 !== r2)
              throw new Error("unknown command " + r2);
          }
          return [a2, l2, o2, u2];
        }, go.prototype.toGeoJSON = function(t2, e3, r2) {
          var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e3, l2 = this.loadGeometry(), u2 = go.types[this.type];
          function c2(t3) {
            for (var e4 = 0; e4 < t3.length; e4++) {
              var r3 = t3[e4];
              t3[e4] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n2 = 0; n2 < l2.length; n2++)
                h2[n2] = l2[n2][0];
              c2(l2 = h2);
              break;
            case 2:
              for (n2 = 0; n2 < l2.length; n2++)
                c2(l2[n2]);
              break;
            case 3:
              for (l2 = function(t3) {
                var e4 = t3.length;
                if (e4 <= 1)
                  return [t3];
                for (var r3, n3, i3 = [], s3 = 0; s3 < e4; s3++) {
                  var a3 = vo(t3[s3]);
                  0 !== a3 && (void 0 === n3 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
                }
                return r3 && i3.push(r3), i3;
              }(l2), n2 = 0; n2 < l2.length; n2++)
                for (i2 = 0; i2 < l2[n2].length; i2++)
                  c2(l2[n2][i2]);
          }
          1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
          var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
          return "id" in this && (p2.id = this.id), p2;
        };
        var bo = mo, wo = _o;
        function _o(t2, e3) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Ao, this, e3), this.length = this._features.length;
        }
        function Ao(t2, e3, r2) {
          15 === t2 ? e3.version = r2.readVarint() : 1 === t2 ? e3.name = r2.readString() : 5 === t2 ? e3.extent = r2.readVarint() : 2 === t2 ? e3._features.push(r2.pos) : 3 === t2 ? e3._keys.push(r2.readString()) : 4 === t2 && e3._values.push(function(t3) {
            for (var e4 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = t3.readVarint() >> 3;
              e4 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
            }
            return e4;
          }(r2));
        }
        _o.prototype.feature = function(t2) {
          if (t2 < 0 || t2 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t2];
          var e3 = this._pbf.readVarint() + this._pbf.pos;
          return new bo(this._pbf, e3, this.extent, this._keys, this._values);
        };
        var ko = wo;
        function So(t2, e3, r2) {
          if (3 === t2) {
            var n2 = new ko(r2, r2.readVarint() + r2.pos);
            n2.length && (e3[n2.name] = n2);
          }
        }
        fo.VectorTile = function(t2, e3) {
          this.layers = t2.readFields(So, {}, e3);
        }, fo.VectorTileFeature = mo, fo.VectorTileLayer = wo;
        const zo = fo.VectorTileFeature.types, Io = Math.pow(2, 13);
        function Mo(t2, e3, r2, n2, i2, s2, a2, o2) {
          t2.emplaceBack(e3, r2, 2 * Math.floor(n2 * Io) + a2, i2 * Io * 2, s2 * Io * 2, Math.round(o2));
        }
        class Bo {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Wi(), this.indexArray = new os(), this.programConfigurations = new Ls(t2.layers, t2.zoom), this.segments = new hs(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e3, r2) {
            this.features = [], this.hasPattern = ao("fill-extrusion", this.layers, e3);
            for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, o2 = js(n2, t3);
              if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), o2, r2))
                continue;
              const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : qs(n2), properties: n2.properties, type: n2.type, patterns: {} };
              this.hasPattern ? this.features.push(oo("fill-extrusion", this.layers, l2, this.zoom, e3)) : this.addFeature(l2, l2.geometry, s2, r2, {}), e3.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, true);
            }
          }
          addFeatures(t2, e3, r2) {
            for (const t3 of this.features) {
              const { geometry: n2 } = t3;
              this.addFeature(t3, n2, t3.index, e3, r2);
            }
          }
          update(t2, e3, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, po), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e3, r2, n2, i2) {
            for (const r3 of io(e3, 500)) {
              let e4 = 0;
              for (const t3 of r3)
                e4 += t3.length;
              let n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (const t3 of r3) {
                if (0 === t3.length)
                  continue;
                if (Po(t3))
                  continue;
                let e5 = 0;
                for (let r4 = 0; r4 < t3.length; r4++) {
                  const i4 = t3[r4];
                  if (r4 >= 1) {
                    const s3 = t3[r4 - 1];
                    if (!Co(i4, s3)) {
                      n3.vertexLength + 4 > hs.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      const t4 = i4.sub(s3)._perp()._unit(), r5 = s3.dist(i4);
                      e5 + r5 > 32768 && (e5 = 0), Mo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 0, e5), Mo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 1, e5), e5 += r5, Mo(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 0, e5), Mo(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 1, e5);
                      const a3 = n3.vertexLength;
                      this.indexArray.emplaceBack(a3, a3 + 2, a3 + 1), this.indexArray.emplaceBack(a3 + 1, a3 + 2, a3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                    }
                  }
                }
              }
              if (n3.vertexLength + e4 > hs.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray)), "Polygon" !== zo[t2.type])
                continue;
              const i3 = [], s2 = [], a2 = n3.vertexLength;
              for (const t3 of r3)
                if (0 !== t3.length) {
                  t3 !== r3[0] && s2.push(i3.length / 2);
                  for (let e5 = 0; e5 < t3.length; e5++) {
                    const r4 = t3[e5];
                    Mo(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), i3.push(r4.x), i3.push(r4.y);
                  }
                }
              const o2 = Qa(i3, s2);
              for (let t3 = 0; t3 < o2.length; t3 += 3)
                this.indexArray.emplaceBack(a2 + o2[t3], a2 + o2[t3 + 2], a2 + o2[t3 + 1]);
              n3.primitiveLength += o2.length / 3, n3.vertexLength += e4;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        function Co(t2, e3) {
          return t2.x === e3.x && (t2.x < 0 || t2.x > Rs) || t2.y === e3.y && (t2.y < 0 || t2.y > Rs);
        }
        function Po(t2) {
          return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > Rs) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > Rs);
        }
        kn("FillExtrusionBucket", Bo, { omit: ["layers", "features"] });
        var Vo = { paint: new ci({ "fill-extrusion-opacity": new si(nt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ai(nt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new si(nt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new si(nt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new oi(nt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ai(nt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ai(nt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new si(nt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
        function Eo(t2, e3) {
          return t2.x * e3.x + t2.y * e3.y;
        }
        function Fo(t2, e3) {
          if (1 === t2.length) {
            let r2 = 0;
            const n2 = e3[r2++];
            let i2;
            for (; !i2 || n2.equals(i2); )
              if (i2 = e3[r2++], !i2)
                return 1 / 0;
            for (; r2 < e3.length; r2++) {
              const s2 = e3[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Eo(o2, o2), h2 = Eo(o2, l2), p2 = Eo(l2, l2), f2 = Eo(u2, o2), d2 = Eo(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
              if (isFinite(x2))
                return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (const r2 of e3)
              t3 = Math.min(t3, r2.z);
            return t3;
          }
        }
        const To = mi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Lo } = To, Do = mi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: $o } = Do, Ro = fo.VectorTileFeature.types, Uo = Math.cos(Math.PI / 180 * 37.5), Oo = Math.pow(2, 14) / 0.5;
        class qo {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
              this.gradients[t3.id] = {};
            }), this.layoutVertexArray = new Qi(), this.layoutVertexArray2 = new ts(), this.indexArray = new os(), this.programConfigurations = new Ls(t2.layers, t2.zoom), this.segments = new hs(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e3, r2) {
            this.hasPattern = ao("line", this.layers, e3);
            const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: e4, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = js(e4, t3);
              if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), u2, r2))
                continue;
              const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: a2, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : qs(e4), patterns: {}, sortKey: c2 };
              s2.push(h2);
            }
            i2 && s2.sort((t3, e4) => t3.sortKey - e4.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = oo("line", this.layers, n3, this.zoom, e3);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n3, i3, s3, r2, {});
              e3.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e3, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e3, r2) {
            for (const t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e3, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, $o)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Lo), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2) {
            if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
              return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }
          addFeature(t2, e3, r2, n2, i2) {
            const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap"), l2 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (const r3 of e3)
              this.addLine(r3, t2, a2, o2, l2, u2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
          addLine(t2, e3, r2, n2, i2, s2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e4 = 0; e4 < t2.length - 1; e4++)
                this.totalDistance += t2[e4].dist(t2[e4 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a2 = "Polygon" === Ro[e3.type];
            let o2 = t2.length;
            for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
              o2--;
            let l2 = 0;
            for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
              l2++;
            if (o2 < (a2 ? 3 : 2))
              return;
            "bevel" === r2 && (i2 = 1.05);
            const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
            let h2, p2, f2, d2, y2;
            this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
            for (let e4 = l2; e4 < o2; e4++) {
              if (f2 = e4 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e4 + 1], f2 && t2[e4].equals(f2))
                continue;
              y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e4], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
              let m2 = d2.add(y2);
              0 === m2.x && 0 === m2.y || m2._unit();
              const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Uo && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
              if (w2 && e4 > l2) {
                const t3 = h2.dist(p2);
                if (t3 > 2 * u2) {
                  const e5 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                  this.updateDistance(p2, e5), this.addCurrentVertex(e5, d2, 0, 0, c2), p2 = e5;
                }
              }
              const A2 = p2 && f2;
              let k2 = A2 ? r2 : a2 ? "butt" : n2;
              if (A2 && "round" === k2 && (v2 < s2 ? k2 = "miter" : v2 <= 2 && (k2 = "fakeround")), "miter" === k2 && v2 > i2 && (k2 = "bevel"), "bevel" === k2 && (v2 > 2 && (k2 = "flipbevel"), v2 < i2 && (k2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === k2)
                m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("flipbevel" === k2) {
                if (v2 > 100)
                  m2 = y2.mult(-1);
                else {
                  const t3 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                  m2._perp()._mult(t3 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
              } else if ("bevel" === k2 || "fakeround" === k2) {
                const t3 = -Math.sqrt(v2 * v2 - 1), e5 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                if (p2 && this.addCurrentVertex(h2, d2, e5, r3, c2), "fakeround" === k2) {
                  const t4 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e6 = 1; e6 < t4; e6++) {
                    let r4 = e6 / t4;
                    if (0.5 !== r4) {
                      const t5 = r4 - 0.5;
                      r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                  }
                }
                f2 && this.addCurrentVertex(h2, y2, -e5, -r3, c2);
              } else if ("butt" === k2)
                this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("square" === k2) {
                const t3 = p2 ? 1 : -1;
                this.addCurrentVertex(h2, m2, t3, t3, c2);
              } else
                "round" === k2 && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
              if (w2 && e4 < o2 - 1) {
                const t3 = h2.dist(f2);
                if (t3 > 2 * u2) {
                  const e5 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                  this.updateDistance(h2, e5), this.addCurrentVertex(e5, y2, 0, 0, c2), h2 = e5;
                }
              }
            }
          }
          addCurrentVertex(t2, e3, r2, n2, i2, s2 = false) {
            const a2 = e3.y * n2 - e3.x, o2 = -e3.y - e3.x * n2;
            this.addHalfVertex(t2, e3.x + e3.y * r2, e3.y - e3.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Oo / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t2, e3, r2, n2, i2, s2));
          }
          addHalfVertex({ x: t2, y: e3 }, r2, n2, i2, s2, a2, o2) {
            const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Oo - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e3 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t2, e3) {
            this.distance += t2.dist(e3), this.updateScaledDistance();
          }
        }
        kn("LineBucket", qo, { omit: ["layers", "patternFeatures"] });
        const jo = new ci({ "line-cap": new si(nt.layout_line["line-cap"]), "line-join": new ai(nt.layout_line["line-join"]), "line-miter-limit": new si(nt.layout_line["line-miter-limit"]), "line-round-limit": new si(nt.layout_line["line-round-limit"]), "line-sort-key": new ai(nt.layout_line["line-sort-key"]) });
        var No = { paint: new ci({ "line-opacity": new ai(nt.paint_line["line-opacity"]), "line-color": new ai(nt.paint_line["line-color"]), "line-translate": new si(nt.paint_line["line-translate"]), "line-translate-anchor": new si(nt.paint_line["line-translate-anchor"]), "line-width": new ai(nt.paint_line["line-width"]), "line-gap-width": new ai(nt.paint_line["line-gap-width"]), "line-offset": new ai(nt.paint_line["line-offset"]), "line-blur": new ai(nt.paint_line["line-blur"]), "line-dasharray": new li(nt.paint_line["line-dasharray"]), "line-pattern": new oi(nt.paint_line["line-pattern"]), "line-gradient": new ui(nt.paint_line["line-gradient"]) }), layout: jo };
        const Ko = new class extends ai {
          possiblyEvaluate(t2, e3) {
            return e3 = new Yn(Math.floor(e3.zoom), { now: e3.now, fadeDuration: e3.fadeDuration, zoomHistory: e3.zoomHistory, transition: e3.transition }), super.possiblyEvaluate(t2, e3);
          }
          evaluate(t2, e3, r2, n2) {
            return e3 = o({}, e3, { zoom: Math.floor(e3.zoom) }), super.evaluate(t2, e3, r2, n2);
          }
        }(No.paint.properties["line-width"].specification);
        function Zo(t2, e3) {
          return e3 > 0 ? e3 + 2 * t2 : t2;
        }
        Ko.useIntegerZoom = true;
        const Go = mi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Jo = mi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        mi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Xo = mi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
        mi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Yo = mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Ho = mi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Wo(t2, e3, r2) {
          return t2.sections.forEach((t3) => {
            t3.text = function(t4, e4, r3) {
              const n2 = e4.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Xn.applyArabicShaping && (t4 = Xn.applyArabicShaping(t4)), t4;
            }(t3.text, e3, r2);
          }), t2;
        }
        mi([{ name: "triangle", components: 3, type: "Uint16" }]), mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), mi([{ type: "Float32", name: "offsetX" }]), mi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
        const Qo = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        var tl = 24, el = il, rl = function(t2, e3, r2, n2, i2) {
          var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e3 + h2];
          for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e3 + h2], h2 += p2, c2 -= 8)
            ;
          for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e3 + h2], h2 += p2, c2 -= 8)
            ;
          if (0 === s2)
            s2 = 1 - u2;
          else {
            if (s2 === l2)
              return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            a2 += Math.pow(2, n2), s2 -= u2;
          }
          return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
        }, nl = function(t2, e3, r2, n2, i2, s2) {
          var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
          for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (o2 = isNaN(e3) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e3) / Math.LN2), e3 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e3 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e3 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e3 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
            ;
          for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
            ;
          t2[r2 + f2 - d2] |= 128 * y2;
        };
        function il(t2) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        il.Varint = 0, il.Fixed64 = 1, il.Bytes = 2, il.Fixed32 = 5;
        var sl, al = 4294967296, ol = 1 / al, ll = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function ul(t2) {
          return t2.type === il.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
        }
        function cl(t2, e3, r2) {
          return r2 ? 4294967296 * e3 + (t2 >>> 0) : 4294967296 * (e3 >>> 0) + (t2 >>> 0);
        }
        function hl(t2, e3, r2) {
          var n2 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
          r2.realloc(n2);
          for (var i2 = r2.pos - 1; i2 >= t2; i2--)
            r2.buf[i2 + n2] = r2.buf[i2];
        }
        function pl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeVarint(t2[r2]);
        }
        function fl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeSVarint(t2[r2]);
        }
        function dl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeFloat(t2[r2]);
        }
        function yl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeDouble(t2[r2]);
        }
        function ml(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeBoolean(t2[r2]);
        }
        function gl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeFixed32(t2[r2]);
        }
        function xl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeSFixed32(t2[r2]);
        }
        function vl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeFixed64(t2[r2]);
        }
        function bl(t2, e3) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e3.writeSFixed64(t2[r2]);
        }
        function wl(t2, e3) {
          return (t2[e3] | t2[e3 + 1] << 8 | t2[e3 + 2] << 16) + 16777216 * t2[e3 + 3];
        }
        function _l(t2, e3, r2) {
          t2[r2] = e3, t2[r2 + 1] = e3 >>> 8, t2[r2 + 2] = e3 >>> 16, t2[r2 + 3] = e3 >>> 24;
        }
        function Al(t2, e3) {
          return (t2[e3] | t2[e3 + 1] << 8 | t2[e3 + 2] << 16) + (t2[e3 + 3] << 24);
        }
        function kl(t2, e3, r2) {
          1 === t2 && r2.readMessage(Sl, e3);
        }
        function Sl(t2, e3, r2) {
          if (3 === t2) {
            const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(zl, {});
            e3.push({ id: t3, bitmap: new ba({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
          }
        }
        function zl(t2, e3, r2) {
          1 === t2 ? e3.id = r2.readVarint() : 2 === t2 ? e3.bitmap = r2.readBytes() : 3 === t2 ? e3.width = r2.readVarint() : 4 === t2 ? e3.height = r2.readVarint() : 5 === t2 ? e3.left = r2.readSVarint() : 6 === t2 ? e3.top = r2.readSVarint() : 7 === t2 && (e3.advance = r2.readVarint());
        }
        function Il(t2) {
          let e3 = 0, r2 = 0;
          for (const n3 of t2)
            e3 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
          t2.sort((t3, e4) => e4.h - t3.h);
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e3 / 0.95)), r2), h: 1 / 0 }];
          let i2 = 0, s2 = 0;
          for (const e4 of t2)
            for (let t3 = n2.length - 1; t3 >= 0; t3--) {
              const r3 = n2[t3];
              if (!(e4.w > r3.w || e4.h > r3.h)) {
                if (e4.x = r3.x, e4.y = r3.y, s2 = Math.max(s2, e4.y + e4.h), i2 = Math.max(i2, e4.x + e4.w), e4.w === r3.w && e4.h === r3.h) {
                  const e5 = n2.pop();
                  t3 < n2.length && (n2[t3] = e5);
                } else
                  e4.h === r3.h ? (r3.x += e4.w, r3.w -= e4.w) : e4.w === r3.w ? (r3.y += e4.h, r3.h -= e4.h) : (n2.push({ x: r3.x + e4.w, y: r3.y, w: r3.w - e4.w, h: e4.h }), r3.y += e4.h, r3.h -= e4.h);
                break;
              }
            }
          return { w: i2, h: s2, fill: e3 / (i2 * s2) || 0 };
        }
        il.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t2, e3, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
            this.type = 7 & n2, t2(i2, e3, this), this.pos === s2 && this.skip(n2);
          }
          return e3;
        }, readMessage: function(t2, e3) {
          return this.readFields(t2, e3, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t2 = wl(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readSFixed32: function() {
          var t2 = Al(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readFixed64: function() {
          var t2 = wl(this.buf, this.pos) + wl(this.buf, this.pos + 4) * al;
          return this.pos += 8, t2;
        }, readSFixed64: function() {
          var t2 = wl(this.buf, this.pos) + Al(this.buf, this.pos + 4) * al;
          return this.pos += 8, t2;
        }, readFloat: function() {
          var t2 = rl(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t2;
        }, readDouble: function() {
          var t2 = rl(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t2;
        }, readVarint: function(t2) {
          var e3, r2, n2 = this.buf;
          return e3 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e3 : (e3 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e3 : (e3 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e3 : (e3 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e3 : function(t3, e4, r3) {
            var n3, i2, s2 = r3.buf;
            if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
              return cl(t3, n3, e4);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
              return cl(t3, n3, e4);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
              return cl(t3, n3, e4);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
              return cl(t3, n3, e4);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
              return cl(t3, n3, e4);
            if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
              return cl(t3, n3, e4);
            throw new Error("Expected varint not more than 10 bytes");
          }(e3 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t2 = this.readVarint() + this.pos, e3 = this.pos;
          return this.pos = t2, t2 - e3 >= 12 && ll ? function(t3, e4, r2) {
            return ll.decode(t3.subarray(e4, r2));
          }(this.buf, e3, t2) : function(t3, e4, r2) {
            for (var n2 = "", i2 = e4; i2 < r2; ) {
              var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i2 + c2 > r2)
                break;
              1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (s2 = t3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : 3 === c2 ? (a2 = t3[i2 + 2], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
            }
            return n2;
          }(this.buf, e3, t2);
        }, readBytes: function() {
          var t2 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e3;
        }, readPackedVarint: function(t2, e3) {
          if (this.type !== il.Bytes)
            return t2.push(this.readVarint(e3));
          var r2 = ul(this);
          for (t2 = t2 || []; this.pos < r2; )
            t2.push(this.readVarint(e3));
          return t2;
        }, readPackedSVarint: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readSVarint());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readSVarint());
          return t2;
        }, readPackedBoolean: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readBoolean());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readBoolean());
          return t2;
        }, readPackedFloat: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readFloat());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readFloat());
          return t2;
        }, readPackedDouble: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readDouble());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readDouble());
          return t2;
        }, readPackedFixed32: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readFixed32());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readFixed32());
          return t2;
        }, readPackedSFixed32: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readSFixed32());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readSFixed32());
          return t2;
        }, readPackedFixed64: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readFixed64());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readFixed64());
          return t2;
        }, readPackedSFixed64: function(t2) {
          if (this.type !== il.Bytes)
            return t2.push(this.readSFixed64());
          var e3 = ul(this);
          for (t2 = t2 || []; this.pos < e3; )
            t2.push(this.readSFixed64());
          return t2;
        }, skip: function(t2) {
          var e3 = 7 & t2;
          if (e3 === il.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e3 === il.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e3 === il.Fixed32)
            this.pos += 4;
          else {
            if (e3 !== il.Fixed64)
              throw new Error("Unimplemented type: " + e3);
            this.pos += 8;
          }
        }, writeTag: function(t2, e3) {
          this.writeVarint(t2 << 3 | e3);
        }, realloc: function(t2) {
          for (var e3 = this.length || 16; e3 < this.pos + t2; )
            e3 *= 2;
          if (e3 !== this.length) {
            var r2 = new Uint8Array(e3);
            r2.set(this.buf), this.buf = r2, this.length = e3;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t2) {
          this.realloc(4), _l(this.buf, t2, this.pos), this.pos += 4;
        }, writeSFixed32: function(t2) {
          this.realloc(4), _l(this.buf, t2, this.pos), this.pos += 4;
        }, writeFixed64: function(t2) {
          this.realloc(8), _l(this.buf, -1 & t2, this.pos), _l(this.buf, Math.floor(t2 * ol), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t2) {
          this.realloc(8), _l(this.buf, -1 & t2, this.pos), _l(this.buf, Math.floor(t2 * ol), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e3) {
            var r2, n2;
            if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e3.realloc(10), function(t4, e4, r3) {
              r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
            }(r2, 0, e3), function(t4, e4) {
              var r3 = (7 & t4) << 4;
              e4.buf[e4.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4)))));
            }(n2, e3);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        }, writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        }, writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        }, writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e3 = this.pos;
          this.pos = function(t3, e4, r3) {
            for (var n2, i2, s2 = 0; s2 < e4.length; s2++) {
              if ((n2 = e4.charCodeAt(s2)) > 55295 && n2 < 57344) {
                if (!i2) {
                  n2 > 56319 || s2 + 1 === e4.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                  continue;
                }
                n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
              } else
                i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
              n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t2, this.pos);
          var r2 = this.pos - e3;
          r2 >= 128 && hl(e3, r2, this), this.pos = e3 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t2) {
          this.realloc(4), nl(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t2) {
          this.realloc(8), nl(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t2) {
          var e3 = t2.length;
          this.writeVarint(e3), this.realloc(e3);
          for (var r2 = 0; r2 < e3; r2++)
            this.buf[this.pos++] = t2[r2];
        }, writeRawMessage: function(t2, e3) {
          this.pos++;
          var r2 = this.pos;
          t2(e3, this);
          var n2 = this.pos - r2;
          n2 >= 128 && hl(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t2, e3, r2) {
          this.writeTag(t2, il.Bytes), this.writeRawMessage(e3, r2);
        }, writePackedVarint: function(t2, e3) {
          e3.length && this.writeMessage(t2, pl, e3);
        }, writePackedSVarint: function(t2, e3) {
          e3.length && this.writeMessage(t2, fl, e3);
        }, writePackedBoolean: function(t2, e3) {
          e3.length && this.writeMessage(t2, ml, e3);
        }, writePackedFloat: function(t2, e3) {
          e3.length && this.writeMessage(t2, dl, e3);
        }, writePackedDouble: function(t2, e3) {
          e3.length && this.writeMessage(t2, yl, e3);
        }, writePackedFixed32: function(t2, e3) {
          e3.length && this.writeMessage(t2, gl, e3);
        }, writePackedSFixed32: function(t2, e3) {
          e3.length && this.writeMessage(t2, xl, e3);
        }, writePackedFixed64: function(t2, e3) {
          e3.length && this.writeMessage(t2, vl, e3);
        }, writePackedSFixed64: function(t2, e3) {
          e3.length && this.writeMessage(t2, bl, e3);
        }, writeBytesField: function(t2, e3) {
          this.writeTag(t2, il.Bytes), this.writeBytes(e3);
        }, writeFixed32Field: function(t2, e3) {
          this.writeTag(t2, il.Fixed32), this.writeFixed32(e3);
        }, writeSFixed32Field: function(t2, e3) {
          this.writeTag(t2, il.Fixed32), this.writeSFixed32(e3);
        }, writeFixed64Field: function(t2, e3) {
          this.writeTag(t2, il.Fixed64), this.writeFixed64(e3);
        }, writeSFixed64Field: function(t2, e3) {
          this.writeTag(t2, il.Fixed64), this.writeSFixed64(e3);
        }, writeVarintField: function(t2, e3) {
          this.writeTag(t2, il.Varint), this.writeVarint(e3);
        }, writeSVarintField: function(t2, e3) {
          this.writeTag(t2, il.Varint), this.writeSVarint(e3);
        }, writeStringField: function(t2, e3) {
          this.writeTag(t2, il.Bytes), this.writeString(e3);
        }, writeFloatField: function(t2, e3) {
          this.writeTag(t2, il.Fixed32), this.writeFloat(e3);
        }, writeDoubleField: function(t2, e3) {
          this.writeTag(t2, il.Fixed64), this.writeDouble(e3);
        }, writeBooleanField: function(t2, e3) {
          this.writeVarintField(t2, Boolean(e3));
        } };
        class Ml {
          constructor(t2, { pixelRatio: e3, version: r2, stretchX: n2, stretchY: i2, content: s2 }) {
            this.paddedRect = t2, this.pixelRatio = e3, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Bl {
          constructor(t2, e3) {
            const r2 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            const i2 = [];
            this.addImages(t2, r2, i2), this.addImages(e3, n2, i2);
            const { w: s2, h: a2 } = Il(i2), o2 = new wa({ width: s2 || 1, height: a2 || 1 });
            for (const e4 in t2) {
              const n3 = t2[e4], i3 = r2[e4].paddedRect;
              wa.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
            }
            for (const t3 in e3) {
              const r3 = e3[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
              wa.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), wa.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), wa.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), wa.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), wa.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
          }
          addImages(t2, e3, r2) {
            for (const n2 in t2) {
              const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
              r2.push(s2), e3[n2] = new Ml(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t2, e3) {
            t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r2 in t2.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e3), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e3);
          }
          patchUpdatedImage(t2, e3, r2) {
            if (!t2 || !e3)
              return;
            if (t2.version === e3.version)
              return;
            t2.version = e3.version;
            const [n2, i2] = t2.tl;
            r2.update(e3.data, void 0, { x: n2, y: i2 });
          }
        }
        kn("ImagePosition", Ml), kn("ImageAtlas", Bl), t.WritingMode = void 0, (sl = t.WritingMode || (t.WritingMode = {}))[sl.none = 0] = "none", sl[sl.horizontal = 1] = "horizontal", sl[sl.vertical = 2] = "vertical", sl[sl.horizontalOnly = 3] = "horizontalOnly";
        const Cl = -17;
        class Pl {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t2, e3) {
            const r2 = new Pl();
            return r2.scale = t2 || 1, r2.fontStack = e3, r2;
          }
          static forImage(t2) {
            const e3 = new Pl();
            return e3.imageName = t2, e3;
          }
        }
        class Vl {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t2, e3) {
            const r2 = new Vl();
            for (let n2 = 0; n2 < t2.sections.length; n2++) {
              const i2 = t2.sections[n2];
              i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e3);
            }
            return r2;
          }
          length() {
            return this.text.length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          getCharCode(t2) {
            return this.text.charCodeAt(t2);
          }
          verticalizePunctuation() {
            this.text = function(t2) {
              let e3 = "";
              for (let r2 = 0; r2 < t2.length; r2++) {
                const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                e3 += n2 && Fn(n2) && !Qo[t2[r2 + 1]] || i2 && Fn(i2) && !Qo[t2[r2 - 1]] || !Qo[t2[r2]] ? t2[r2] : Qo[t2[r2]];
              }
              return e3;
            }(this.text);
          }
          trim() {
            let t2 = 0;
            for (let e4 = 0; e4 < this.text.length && Fl[this.text.charCodeAt(e4)]; e4++)
              t2++;
            let e3 = this.text.length;
            for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && Fl[this.text.charCodeAt(r2)]; r2--)
              e3--;
            this.text = this.text.substring(t2, e3), this.sectionIndex = this.sectionIndex.slice(t2, e3);
          }
          substring(t2, e3) {
            const r2 = new Vl();
            return r2.text = this.text.substring(t2, e3), r2.sectionIndex = this.sectionIndex.slice(t2, e3), r2.sections = this.sections, r2;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t2, e3) => Math.max(t2, this.sections[e3].scale), 0);
          }
          addTextSection(t2, e3) {
            this.text += t2.text, this.sections.push(Pl.forText(t2.scale, t2.fontStack || e3));
            const r2 = this.sections.length - 1;
            for (let e4 = 0; e4 < t2.text.length; ++e4)
              this.sectionIndex.push(r2);
          }
          addImageSection(t2) {
            const e3 = t2.image ? t2.image.name : "";
            if (0 === e3.length)
              return void d("Can't add FormattedSection with an empty image.");
            const r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Pl.forImage(e3)), this.sectionIndex.push(this.sections.length - 1)) : d("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function El(e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
          const g2 = Vl.fromFeature(e3, s2);
          let x2;
          p2 === t.WritingMode.vertical && g2.verticalizePunctuation();
          const { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = Xn;
          if (v2 && 1 === g2.sections.length) {
            x2 = [];
            const t2 = v2(g2.toString(), Ol(g2, c2, a2, r2, i2, d2, y2));
            for (const e4 of t2) {
              const t3 = new Vl();
              t3.text = e4, t3.sections = g2.sections;
              for (let r3 = 0; r3 < e4.length; r3++)
                t3.sectionIndex.push(0);
              x2.push(t3);
            }
          } else if (b2) {
            x2 = [];
            const t2 = b2(g2.text, g2.sectionIndex, Ol(g2, c2, a2, r2, i2, d2, y2));
            for (const e4 of t2) {
              const t3 = new Vl();
              t3.text = e4[0], t3.sectionIndex = e4[1], t3.sections = g2.sections, x2.push(t3);
            }
          } else
            x2 = function(t2, e4) {
              const r3 = [], n3 = t2.text;
              let i3 = 0;
              for (const n4 of e4)
                r3.push(t2.substring(i3, n4)), i3 = n4;
              return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
            }(g2, Ol(g2, c2, a2, r2, i2, d2, y2));
          const w2 = [], _2 = { positionedLines: w2, text: g2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
          return function(e4, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3, p3) {
            let f3 = 0, d3 = Cl, y3 = 0, m3 = 0;
            const g3 = "right" === l3 ? 1 : "left" === l3 ? 0 : 0.5;
            let x3 = 0;
            for (const o4 of s3) {
              o4.trim();
              const s4 = o4.getMaxScale(), l4 = (s4 - 1) * tl, b4 = { positionedGlyphs: [], lineOffset: 0 };
              e4.positionedLines[x3] = b4;
              const w4 = b4.positionedGlyphs;
              let _4 = 0;
              if (!o4.length()) {
                d3 += a3, ++x3;
                continue;
              }
              for (let a4 = 0; a4 < o4.length(); a4++) {
                const y4 = o4.getSection(a4), m4 = o4.getSectionIndex(a4), g4 = o4.getCharCode(a4);
                let x4 = 0, b5 = null, A3 = null, k2 = null, S2 = tl;
                const z2 = !(u3 === t.WritingMode.horizontal || !h3 && !En(g4) || h3 && (Fl[g4] || (v3 = g4, Bn.Arabic(v3) || Bn["Arabic Supplement"](v3) || Bn["Arabic Extended-A"](v3) || Bn["Arabic Presentation Forms-A"](v3) || Bn["Arabic Presentation Forms-B"](v3))));
                if (y4.imageName) {
                  const t2 = i3[y4.imageName];
                  if (!t2)
                    continue;
                  k2 = y4.imageName, e4.iconsInText = e4.iconsInText || true, A3 = t2.paddedRect;
                  const r4 = t2.displaySize;
                  y4.scale = y4.scale * tl / p3, b5 = { width: r4[0], height: r4[1], left: 1, top: -3, advance: z2 ? r4[1] : r4[0] }, x4 = l4 + (tl - r4[1] * y4.scale), S2 = b5.advance;
                  const n4 = z2 ? r4[0] * y4.scale - tl * s4 : r4[1] * y4.scale - tl * s4;
                  n4 > 0 && n4 > _4 && (_4 = n4);
                } else {
                  const t2 = n3[y4.fontStack], e5 = t2 && t2[g4];
                  if (e5 && e5.rect)
                    A3 = e5.rect, b5 = e5.metrics;
                  else {
                    const t3 = r3[y4.fontStack], e6 = t3 && t3[g4];
                    if (!e6)
                      continue;
                    b5 = e6.metrics;
                  }
                  x4 = (s4 - y4.scale) * tl;
                }
                z2 ? (e4.verticalizable = true, w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x4, vertical: z2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += S2 * y4.scale + c3) : (w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x4, vertical: z2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += b5.advance * y4.scale + c3);
              }
              0 !== w4.length && (y3 = Math.max(f3 - c3, y3), jl(w4, 0, w4.length - 1, g3, _4)), f3 = 0;
              const A2 = a3 * s4 + _4;
              b4.lineOffset = Math.max(_4, l4), d3 += A2, m3 = Math.max(A2, m3), ++x3;
            }
            var v3;
            const b3 = d3 - Cl, { horizontalAlign: w3, verticalAlign: _3 } = ql(o3);
            (function(t2, e5, r4, n4, i4, s4, a4, o4, l4) {
              const u4 = (e5 - r4) * i4;
              let c4 = 0;
              c4 = s4 !== a4 ? -o4 * n4 - Cl : (-n4 * l4 + 0.5) * a4;
              for (const e6 of t2)
                for (const t3 of e6.positionedGlyphs)
                  t3.x += u4, t3.y += c4;
            })(e4.positionedLines, g3, w3, _3, y3, m3, a3, b3, s3.length), e4.top += -_3 * b3, e4.bottom = e4.top + b3, e4.left += -w3 * y3, e4.right = e4.left + y3;
          }(_2, r2, n2, i2, x2, o2, l2, u2, p2, c2, f2, m2), !function(t2) {
            for (const e4 of t2)
              if (0 !== e4.positionedGlyphs.length)
                return false;
            return true;
          }(w2) && _2;
        }
        const Fl = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Tl = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Ll(t2, e3, r2, n2, i2, s2) {
          if (e3.imageName) {
            const t3 = n2[e3.imageName];
            return t3 ? t3.displaySize[0] * e3.scale * tl / s2 + i2 : 0;
          }
          {
            const n3 = r2[e3.fontStack], s3 = n3 && n3[t2];
            return s3 ? s3.metrics.advance * e3.scale + i2 : 0;
          }
        }
        function Dl(t2, e3, r2, n2) {
          const i2 = Math.pow(t2 - e3, 2);
          return n2 ? t2 < e3 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function $l(t2, e3, r2) {
          let n2 = 0;
          return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e3 && 65289 !== e3 || (n2 += 50), n2;
        }
        function Rl(t2, e3, r2, n2, i2, s2) {
          let a2 = null, o2 = Dl(e3, r2, i2, s2);
          for (const t3 of n2) {
            const n3 = Dl(e3 - t3.x, r2, i2, s2) + t3.badness;
            n3 <= o2 && (a2 = t3, o2 = n3);
          }
          return { index: t2, x: e3, priorBreak: a2, badness: o2 };
        }
        function Ul(t2) {
          return t2 ? Ul(t2.priorBreak).concat(t2.index) : [];
        }
        function Ol(t2, e3, r2, n2, i2, s2, a2) {
          if ("point" !== s2)
            return [];
          if (!t2)
            return [];
          const o2 = [], l2 = function(t3, e4, r3, n3, i3, s3) {
            let a3 = 0;
            for (let r4 = 0; r4 < t3.length(); r4++) {
              const o3 = t3.getSection(r4);
              a3 += Ll(t3.getCharCode(r4), o3, n3, i3, e4, s3);
            }
            return a3 / Math.max(1, Math.ceil(a3 / r3));
          }(t2, e3, r2, n2, i2, a2), u2 = t2.text.indexOf("") >= 0;
          let c2 = 0;
          for (let r3 = 0; r3 < t2.length(); r3++) {
            const s3 = t2.getSection(r3), p2 = t2.getCharCode(r3);
            if (Fl[p2] || (c2 += Ll(p2, s3, n2, i2, e3, a2)), r3 < t2.length() - 1) {
              const e4 = !((h2 = p2) < 11904 || !(Bn["Bopomofo Extended"](h2) || Bn.Bopomofo(h2) || Bn["CJK Compatibility Forms"](h2) || Bn["CJK Compatibility Ideographs"](h2) || Bn["CJK Compatibility"](h2) || Bn["CJK Radicals Supplement"](h2) || Bn["CJK Strokes"](h2) || Bn["CJK Symbols and Punctuation"](h2) || Bn["CJK Unified Ideographs Extension A"](h2) || Bn["CJK Unified Ideographs"](h2) || Bn["Enclosed CJK Letters and Months"](h2) || Bn["Halfwidth and Fullwidth Forms"](h2) || Bn.Hiragana(h2) || Bn["Ideographic Description Characters"](h2) || Bn["Kangxi Radicals"](h2) || Bn["Katakana Phonetic Extensions"](h2) || Bn.Katakana(h2) || Bn["Vertical Forms"](h2) || Bn["Yi Radicals"](h2) || Bn["Yi Syllables"](h2)));
              (Tl[p2] || e4 || s3.imageName) && o2.push(Rl(r3 + 1, c2, l2, o2, $l(p2, t2.getCharCode(r3 + 1), e4 && u2), false));
            }
          }
          var h2;
          return Ul(Rl(t2.length(), c2, l2, o2, 0, true));
        }
        function ql(t2) {
          let e3 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e3 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e3 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e3, verticalAlign: r2 };
        }
        function jl(t2, e3, r2, n2, i2) {
          if (!n2 && !i2)
            return;
          const s2 = t2[r2], a2 = (t2[r2].x + s2.metrics.advance * s2.scale) * n2;
          for (let n3 = e3; n3 <= r2; n3++)
            t2[n3].x -= a2, t2[n3].y += i2;
        }
        function Nl(t2, e3, r2) {
          const { horizontalAlign: n2, verticalAlign: i2 } = ql(r2), s2 = e3[0] - t2.displaySize[0] * n2, a2 = e3[1] - t2.displaySize[1] * i2;
          return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
        }
        function Kl(t2, e3, r2, n2, i2, s2) {
          const a2 = t2.image;
          let o2;
          if (a2.content) {
            const t3 = a2.content, e4 = a2.pixelRatio || 1;
            o2 = [t3[0] / e4, t3[1] / e4, a2.displaySize[0] - t3[2] / e4, a2.displaySize[1] - t3[3] / e4];
          }
          const l2 = e3.left * s2, u2 = e3.right * s2;
          let c2, h2, p2, f2;
          "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
          const d2 = e3.top * s2, y2 = e3.bottom * s2;
          return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
        }
        const Zl = 128;
        function Gl(t2, e3) {
          const { expression: r2 } = e3;
          if ("constant" === r2.kind)
            return { kind: "constant", layoutSize: r2.evaluate(new Yn(t2 + 1)) };
          if ("source" === r2.kind)
            return { kind: "source" };
          {
            const { zoomStops: e4, interpolationType: n2 } = r2;
            let i2 = 0;
            for (; i2 < e4.length && e4[i2] <= t2; )
              i2++;
            i2 = Math.max(0, i2 - 1);
            let s2 = i2;
            for (; s2 < e4.length && e4[s2] < t2 + 1; )
              s2++;
            s2 = Math.min(e4.length - 1, s2);
            const a2 = e4[i2], o2 = e4[s2];
            return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new Yn(a2)), maxSize: r2.evaluate(new Yn(o2)), interpolationType: n2 };
          }
        }
        class Jl extends S {
          constructor(t2, e3, r2, n2) {
            super(t2, e3), this.angle = r2, void 0 !== n2 && (this.segment = n2);
          }
          clone() {
            return new Jl(this.x, this.y, this.angle, this.segment);
          }
        }
        function Xl(t2, e3, r2, n2, i2) {
          if (void 0 === e3.segment)
            return true;
          let s2 = e3, a2 = e3.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (a2--, a2 < 0)
              return false;
            o2 -= t2[a2].dist(s2), s2 = t2[a2];
          }
          o2 += t2[a2].dist(t2[a2 + 1]), a2++;
          const l2 = [];
          let u2 = 0;
          for (; o2 < r2 / 2; ) {
            const e4 = t2[a2], r3 = t2[a2 + 1];
            if (!r3)
              return false;
            let s3 = t2[a2 - 1].angleTo(e4) - e4.angleTo(r3);
            for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
              u2 -= l2.shift().angleDelta;
            if (u2 > i2)
              return false;
            a2++, o2 += e4.dist(r3);
          }
          return true;
        }
        function Yl(t2) {
          let e3 = 0;
          for (let r2 = 0; r2 < t2.length - 1; r2++)
            e3 += t2[r2].dist(t2[r2 + 1]);
          return e3;
        }
        function Hl(t2, e3, r2) {
          return t2 ? 0.6 * e3 * r2 : 0;
        }
        function Wl(t2, e3) {
          return Math.max(t2 ? t2.right - t2.left : 0, e3 ? e3.right - e3.left : 0);
        }
        function Ql(t2, e3, r2, n2, i2, s2) {
          const a2 = Hl(r2, i2, s2), o2 = Wl(r2, n2) * s2;
          let l2 = 0;
          const u2 = Yl(t2) / 2;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
            if (l2 + s3 > u2) {
              const c2 = (u2 - l2) / s3, h2 = Se(n3.x, i3.x, c2), p2 = Se(n3.y, i3.y, c2), f2 = new Jl(h2, p2, i3.angleTo(n3), r3);
              return f2._round(), !a2 || Xl(t2, f2, o2, a2, e3) ? f2 : void 0;
            }
            l2 += s3;
          }
        }
        function tu(t2, e3, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = Hl(n2, s2, a2), c2 = Wl(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
          return e3 - h2 < e3 / 4 && (e3 = h2 + e3 / 4), eu(t2, p2 ? e3 / 2 * o2 % e3 : (c2 / 2 + 2 * s2) * a2 * o2 % e3, e3, u2, r2, h2, p2, false, l2);
        }
        function eu(t2, e3, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = s2 / 2, c2 = Yl(t2);
          let h2 = 0, p2 = e3 - r2, f2 = [];
          for (let e4 = 0; e4 < t2.length - 1; e4++) {
            const a3 = t2[e4], o3 = t2[e4 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
            for (; p2 + r2 < h2 + d2; ) {
              p2 += r2;
              const m2 = (p2 - h2) / d2, g2 = Se(a3.x, o3.x, m2), x2 = Se(a3.y, o3.y, m2);
              if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r3 = new Jl(g2, x2, y2, e4);
                r3._round(), n2 && !Xl(t2, r3, s2, n2, i2) || f2.push(r3);
              }
            }
            h2 += d2;
          }
          return o2 || f2.length || a2 || (f2 = eu(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
        }
        function ru(t2, e3, r2, n2, i2) {
          const s2 = [];
          for (let a2 = 0; a2 < t2.length; a2++) {
            const o2 = t2[a2];
            let l2;
            for (let t3 = 0; t3 < o2.length - 1; t3++) {
              let a3 = o2[t3], u2 = o2[t3 + 1];
              a3.x < e3 && u2.x < e3 || (a3.x < e3 ? a3 = new S(e3, a3.y + (e3 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x < e3 && (u2 = new S(e3, a3.y + (e3 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y < r2 && u2.y < r2 || (a3.y < r2 ? a3 = new S(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round() : u2.y < r2 && (u2 = new S(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round()), a3.x >= n2 && u2.x >= n2 || (a3.x >= n2 ? a3 = new S(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x >= n2 && (u2 = new S(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y >= i2 && u2.y >= i2 || (a3.y >= i2 ? a3 = new S(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round() : u2.y >= i2 && (u2 = new S(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round()), l2 && a3.equals(l2[l2.length - 1]) || (l2 = [a3], s2.push(l2)), l2.push(u2)))));
            }
          }
          return s2;
        }
        function nu(t2, e3, r2, n2) {
          const i2 = [], s2 = t2.image, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2, l2 = s2.paddedRect.h - 2, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, l2]], f2 = (t3, e4) => t3 + e4[1] - e4[0], d2 = h2.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = o2 - d2, g2 = l2 - y2;
          let x2 = 0, v2 = d2, b2 = 0, w2 = y2, _2 = 0, A2 = m2, k2 = 0, z2 = g2;
          if (s2.content && n2) {
            const t3 = s2.content;
            x2 = iu(h2, 0, t3[0]), b2 = iu(p2, 0, t3[1]), v2 = iu(h2, t3[0], t3[2]), w2 = iu(p2, t3[1], t3[3]), _2 = t3[0] - x2, k2 = t3[1] - b2, A2 = t3[2] - t3[0] - v2, z2 = t3[3] - t3[1] - w2;
          }
          const I2 = (n3, i3, o3, l3) => {
            const h3 = au(n3.stretch - x2, v2, u2, t2.left), p3 = ou(n3.fixed - _2, A2, n3.stretch, d2), f3 = au(i3.stretch - b2, w2, c2, t2.top), m3 = ou(i3.fixed - k2, z2, i3.stretch, y2), g3 = au(o3.stretch - x2, v2, u2, t2.left), I3 = ou(o3.fixed - _2, A2, o3.stretch, d2), M2 = au(l3.stretch - b2, w2, c2, t2.top), B2 = ou(l3.fixed - k2, z2, l3.stretch, y2), C2 = new S(h3, f3), P2 = new S(g3, f3), V2 = new S(g3, M2), E2 = new S(h3, M2), F2 = new S(p3 / a2, m3 / a2), T2 = new S(I3 / a2, B2 / a2), L2 = e3 * Math.PI / 180;
            if (L2) {
              const t3 = Math.sin(L2), e4 = Math.cos(L2), r3 = [e4, -t3, t3, e4];
              C2._matMult(r3), P2._matMult(r3), E2._matMult(r3), V2._matMult(r3);
            }
            const D2 = n3.stretch + n3.fixed, $2 = i3.stretch + i3.fixed;
            return { tl: C2, tr: P2, bl: E2, br: V2, tex: { x: s2.paddedRect.x + 1 + D2, y: s2.paddedRect.y + 1 + $2, w: o3.stretch + o3.fixed - D2, h: l3.stretch + l3.fixed - $2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: T2, minFontScaleX: A2 / a2 / u2, minFontScaleY: z2 / a2 / c2, isSDF: r2 };
          };
          if (n2 && (s2.stretchX || s2.stretchY)) {
            const t3 = su(h2, m2, d2), e4 = su(p2, g2, y2);
            for (let r3 = 0; r3 < t3.length - 1; r3++) {
              const n3 = t3[r3], s3 = t3[r3 + 1];
              for (let t4 = 0; t4 < e4.length - 1; t4++)
                i2.push(I2(n3, e4[t4], s3, e4[t4 + 1]));
            }
          } else
            i2.push(I2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
          return i2;
        }
        function iu(t2, e3, r2) {
          let n2 = 0;
          for (const i2 of t2)
            n2 += Math.max(e3, Math.min(r2, i2[1])) - Math.max(e3, Math.min(r2, i2[0]));
          return n2;
        }
        function su(t2, e3, r2) {
          const n2 = [{ fixed: -1, stretch: 0 }];
          for (const [e4, r3] of t2) {
            const t3 = n2[n2.length - 1];
            n2.push({ fixed: e4 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e4 - t3.stretch, stretch: t3.stretch + (r3 - e4) });
          }
          return n2.push({ fixed: e3 + 1, stretch: r2 }), n2;
        }
        function au(t2, e3, r2, n2) {
          return t2 / e3 * r2 + n2;
        }
        function ou(t2, e3, r2, n2) {
          return t2 - e3 * r2 / n2;
        }
        kn("Anchor", Jl);
        class lu {
          constructor(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2) {
            if (this.boxStartIndex = t2.length, l2) {
              let t3 = s2.top, e4 = s2.bottom;
              const r3 = s2.collisionPadding;
              r3 && (t3 -= r3[1], e4 += r3[3]);
              let n3 = e4 - t3;
              n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
            } else {
              let l3 = s2.top * a2 - o2, c2 = s2.bottom * a2 + o2, h2 = s2.left * a2 - o2, p2 = s2.right * a2 + o2;
              const f2 = s2.collisionPadding;
              if (f2 && (h2 -= f2[0] * a2, l3 -= f2[1] * a2, p2 += f2[2] * a2, c2 += f2[3] * a2), u2) {
                const t3 = new S(h2, l3), e4 = new S(p2, l3), r3 = new S(h2, c2), n3 = new S(p2, c2), i3 = u2 * Math.PI / 180;
                t3._rotate(i3), e4._rotate(i3), r3._rotate(i3), n3._rotate(i3), h2 = Math.min(t3.x, e4.x, r3.x, n3.x), p2 = Math.max(t3.x, e4.x, r3.x, n3.x), l3 = Math.min(t3.y, e4.y, r3.y, n3.y), c2 = Math.max(t3.y, e4.y, r3.y, n3.y);
              }
              t2.emplaceBack(e3.x, e3.y, h2, l3, p2, c2, r2, n2, i2);
            }
            this.boxEndIndex = t2.length;
          }
        }
        class uu {
          constructor(t2 = [], e3 = cu) {
            if (this.data = t2, this.length = this.data.length, this.compare = e3, this.length > 0)
              for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length)
              return;
            const t2 = this.data[0], e3 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e3, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e3, compare: r2 } = this, n2 = e3[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e3[i2];
              if (r2(n2, s2) >= 0)
                break;
              e3[t2] = s2, t2 = i2;
            }
            e3[t2] = n2;
          }
          _down(t2) {
            const { data: e3, compare: r2 } = this, n2 = this.length >> 1, i2 = e3[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1), s2 = e3[n3];
              const a2 = n3 + 1;
              if (a2 < this.length && r2(e3[a2], s2) < 0 && (n3 = a2, s2 = e3[a2]), r2(s2, i2) >= 0)
                break;
              e3[t2] = s2, t2 = n3;
            }
            e3[t2] = i2;
          }
        }
        function cu(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }
        function hu(t2, e3 = 1, r2 = false) {
          let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          const o2 = t2[0];
          for (let t3 = 0; t3 < o2.length; t3++) {
            const e4 = o2[t3];
            (!t3 || e4.x < n2) && (n2 = e4.x), (!t3 || e4.y < i2) && (i2 = e4.y), (!t3 || e4.x > s2) && (s2 = e4.x), (!t3 || e4.y > a2) && (a2 = e4.y);
          }
          const l2 = Math.min(s2 - n2, a2 - i2);
          let u2 = l2 / 2;
          const c2 = new uu([], pu);
          if (0 === l2)
            return new S(n2, i2);
          for (let e4 = n2; e4 < s2; e4 += l2)
            for (let r3 = i2; r3 < a2; r3 += l2)
              c2.push(new fu(e4 + u2, r3 + u2, u2, t2));
          let h2 = function(t3) {
            let e4 = 0, r3 = 0, n3 = 0;
            const i3 = t3[0];
            for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
              const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
              r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e4 += 3 * l3;
            }
            return new fu(r3 / e4, n3 / e4, 0, t3);
          }(t2), p2 = c2.length;
          for (; c2.length; ) {
            const n3 = c2.pop();
            (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e3 || (u2 = n3.h / 2, c2.push(new fu(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new fu(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new fu(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new fu(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
          }
          return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
        }
        function pu(t2, e3) {
          return e3.max - t2.max;
        }
        function fu(t2, e3, r2, n2) {
          this.p = new S(t2, e3), this.h = r2, this.d = function(t3, e4) {
            let r3 = false, n3 = 1 / 0;
            for (let i2 = 0; i2 < e4.length; i2++) {
              const s2 = e4[i2];
              for (let e5 = 0, i3 = s2.length, a2 = i3 - 1; e5 < i3; a2 = e5++) {
                const i4 = s2[e5], o2 = s2[a2];
                i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Qs(t3, i4, o2));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        const du = Number.POSITIVE_INFINITY;
        function yu(t2, e3) {
          return e3[1] !== du ? function(t3, e4, r2) {
            let n2 = 0, i2 = 0;
            switch (e4 = Math.abs(e4), r2 = Math.abs(r2), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = 7 - r2;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e4;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e4;
            }
            return [n2, i2];
          }(t2, e3[0], e3[1]) : function(t3, e4) {
            let r2 = 0, n2 = 0;
            e4 < 0 && (e4 = 0);
            const i2 = e4 / Math.sqrt(2);
            switch (t3) {
              case "top-right":
              case "top-left":
                n2 = i2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = 7 - i2;
                break;
              case "bottom":
                n2 = 7 - e4;
                break;
              case "top":
                n2 = e4 - 7;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                r2 = -i2;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i2;
                break;
              case "left":
                r2 = e4;
                break;
              case "right":
                r2 = -e4;
            }
            return [r2, n2];
          }(t2, e3[0]);
        }
        function mu(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function gu(e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
          let p2 = a2.textMaxSize.evaluate(r2, {});
          void 0 === p2 && (p2 = o2);
          const f2 = e3.layers[0].layout, y2 = f2.get("icon-offset").evaluate(r2, {}, h2), m2 = bu(n2.horizontal), g2 = o2 / 24, x2 = e3.tilePixelRatio * g2, v2 = e3.tilePixelRatio * p2 / 24, b2 = e3.tilePixelRatio * l2, w2 = e3.tilePixelRatio * f2.get("symbol-spacing"), _2 = f2.get("text-padding") * e3.tilePixelRatio, A2 = f2.get("icon-padding") * e3.tilePixelRatio, k2 = f2.get("text-max-angle") / 180 * Math.PI, S2 = "viewport" !== f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), z2 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), I2 = f2.get("symbol-placement"), M2 = w2 / 2, B2 = f2.get("icon-text-fit");
          let C2;
          i2 && "none" !== B2 && (e3.allowVerticalPlacement && n2.vertical && (C2 = Kl(i2, n2.vertical, B2, f2.get("icon-text-fit-padding"), y2, g2)), m2 && (i2 = Kl(i2, m2, B2, f2.get("icon-text-fit-padding"), y2, g2)));
          const P2 = (l3, p3) => {
            p3.x < 0 || p3.x >= Rs || p3.y < 0 || p3.y >= Rs || function(e4, r3, n3, i3, s3, a3, o3, l4, u3, c3, h3, p4, f3, y3, m3, g3, x3, v3, b3, w3, _3, A3, k3, S3, z3) {
              const I3 = e4.addToLineVertexArray(r3, n3);
              let M3, B3, C3, P3, V2 = 0, E2 = 0, F2 = 0, T2 = 0, L2 = -1, D2 = -1;
              const $2 = {};
              let R2 = vs(""), U2 = 0, O2 = 0;
              if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset") ? [U2, O2] = l4.layout.get("text-offset").evaluate(_3, {}, S3).map((t2) => t2 * tl) : (U2 = l4.layout.get("text-radial-offset").evaluate(_3, {}, S3) * tl, O2 = du), e4.allowVerticalPlacement && i3.vertical) {
                const t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3) + 90;
                C3 = new lu(u3, r3, c3, h3, p4, i3.vertical, f3, y3, m3, t2), o3 && (P3 = new lu(u3, r3, c3, h3, p4, o3, x3, v3, m3, t2));
              }
              if (s3) {
                const n4 = l4.layout.get("icon-rotate").evaluate(_3, {}), i4 = "none" !== l4.layout.get("icon-text-fit"), a4 = nu(s3, n4, k3, i4), f4 = o3 ? nu(o3, n4, k3, i4) : void 0;
                B3 = new lu(u3, r3, c3, h3, p4, s3, x3, v3, false, n4), V2 = 4 * a4.length;
                const y4 = e4.iconSizeData;
                let m4 = null;
                "source" === y4.kind ? (m4 = [Zl * l4.layout.get("icon-size").evaluate(_3, {})], m4[0] > xu && d(`${e4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === y4.kind && (m4 = [Zl * A3.compositeIconSizes[0].evaluate(_3, {}, S3), Zl * A3.compositeIconSizes[1].evaluate(_3, {}, S3)], (m4[0] > xu || m4[1] > xu) && d(`${e4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e4.addSymbols(e4.icon, a4, m4, w3, b3, _3, t.WritingMode.none, r3, I3.lineStartIndex, I3.lineLength, -1, S3), L2 = e4.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e4.addSymbols(e4.icon, f4, m4, w3, b3, _3, t.WritingMode.vertical, r3, I3.lineStartIndex, I3.lineLength, -1, S3), D2 = e4.icon.placedSymbolArray.length - 1);
              }
              const q2 = Object.keys(i3.horizontal);
              for (const n4 of q2) {
                const s4 = i3.horizontal[n4];
                if (!M3) {
                  R2 = vs(s4.text);
                  const t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3);
                  M3 = new lu(u3, r3, c3, h3, p4, s4, f3, y3, m3, t2);
                }
                const o4 = 1 === s4.positionedLines.length;
                if (F2 += vu(e4, r3, s4, a3, l4, m3, _3, g3, I3, i3.vertical ? t.WritingMode.horizontal : t.WritingMode.horizontalOnly, o4 ? q2 : [n4], $2, L2, A3, S3), o4)
                  break;
              }
              i3.vertical && (T2 += vu(e4, r3, i3.vertical, a3, l4, m3, _3, g3, I3, t.WritingMode.vertical, ["vertical"], $2, D2, A3, S3));
              const j2 = M3 ? M3.boxStartIndex : e4.collisionBoxArray.length, N2 = M3 ? M3.boxEndIndex : e4.collisionBoxArray.length, K2 = C3 ? C3.boxStartIndex : e4.collisionBoxArray.length, Z2 = C3 ? C3.boxEndIndex : e4.collisionBoxArray.length, G2 = B3 ? B3.boxStartIndex : e4.collisionBoxArray.length, J2 = B3 ? B3.boxEndIndex : e4.collisionBoxArray.length, X2 = P3 ? P3.boxStartIndex : e4.collisionBoxArray.length, Y2 = P3 ? P3.boxEndIndex : e4.collisionBoxArray.length;
              let H2 = -1;
              const W2 = (t2, e5) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e5) : e5;
              H2 = W2(M3, H2), H2 = W2(C3, H2), H2 = W2(B3, H2), H2 = W2(P3, H2);
              const Q2 = H2 > -1 ? 1 : 0;
              Q2 && (H2 *= z3 / tl), e4.glyphOffsetArray.length >= Bu.MAX_GLYPHS && d("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== _3.sortKey && e4.addToSortKeyRanges(e4.symbolInstances.length, _3.sortKey), e4.symbolInstances.emplaceBack(r3.x, r3.y, $2.right >= 0 ? $2.right : -1, $2.center >= 0 ? $2.center : -1, $2.left >= 0 ? $2.left : -1, $2.vertical || -1, L2, D2, R2, j2, N2, K2, Z2, G2, J2, X2, Y2, c3, F2, T2, V2, E2, Q2, 0, f3, U2, O2, H2);
            }(e3, p3, l3, n2, i2, s2, C2, e3.layers[0], e3.collisionBoxArray, r2.index, r2.sourceLayerIndex, e3.index, x2, _2, S2, u2, b2, A2, z2, y2, r2, a2, c2, h2, o2);
          };
          if ("line" === I2)
            for (const t2 of ru(r2.geometry, 0, 0, Rs, Rs)) {
              const r3 = tu(t2, w2, k2, n2.vertical || m2, i2, 24, v2, e3.overscaling, Rs);
              for (const n3 of r3) {
                const r4 = m2;
                r4 && wu(e3, r4.text, M2, n3) || P2(t2, n3);
              }
            }
          else if ("line-center" === I2) {
            for (const t2 of r2.geometry)
              if (t2.length > 1) {
                const e4 = Ql(t2, k2, n2.vertical || m2, i2, 24, v2);
                e4 && P2(t2, e4);
              }
          } else if ("Polygon" === r2.type)
            for (const t2 of io(r2.geometry, 0)) {
              const e4 = hu(t2, 16);
              P2(t2[0], new Jl(e4.x, e4.y, 0));
            }
          else if ("LineString" === r2.type)
            for (const t2 of r2.geometry)
              P2(t2, new Jl(t2[0].x, t2[0].y, 0));
          else if ("Point" === r2.type)
            for (const t2 of r2.geometry)
              for (const e4 of t2)
                P2([e4], new Jl(e4.x, e4.y, 0));
        }
        const xu = 32640;
        function vu(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, y2) {
          const m2 = function(t3, e4, r3, n3, i3, s3, a3, o3) {
            const l3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, u3 = [];
            for (const t4 of e4.positionedLines)
              for (const n4 of t4.positionedGlyphs) {
                if (!n4.rect)
                  continue;
                const s4 = n4.rect || {};
                let c3 = 4, h3 = true, p3 = 1, f3 = 0;
                const d2 = (i3 || o3) && n4.vertical, y3 = n4.metrics.advance * n4.scale / 2;
                if (o3 && e4.verticalizable) {
                  const e5 = (n4.scale - 1) * tl, r4 = (tl - n4.metrics.width * n4.scale) / 2;
                  f3 = t4.lineOffset / 2 - (n4.imageName ? -r4 : e5);
                }
                if (n4.imageName) {
                  const t5 = a3[n4.imageName];
                  h3 = t5.sdf, p3 = t5.pixelRatio, c3 = 1 / p3;
                }
                const m3 = i3 ? [n4.x + y3, n4.y] : [0, 0];
                let g3 = i3 ? [0, 0] : [n4.x + y3 + r3[0], n4.y + r3[1] - f3], x3 = [0, 0];
                d2 && (x3 = g3, g3 = [0, 0]);
                const v2 = (n4.metrics.left - c3) * n4.scale - y3 + g3[0], b2 = (-n4.metrics.top - c3) * n4.scale + g3[1], w2 = v2 + s4.w * n4.scale / p3, _2 = b2 + s4.h * n4.scale / p3, A2 = new S(v2, b2), k2 = new S(w2, b2), z2 = new S(v2, _2), I2 = new S(w2, _2);
                if (d2) {
                  const t5 = new S(-y3, y3 - Cl), e5 = -Math.PI / 2, r4 = 12 - y3, i4 = new S(22 - r4, -(n4.imageName ? r4 : 0)), s5 = new S(...x3);
                  A2._rotateAround(e5, t5)._add(i4)._add(s5), k2._rotateAround(e5, t5)._add(i4)._add(s5), z2._rotateAround(e5, t5)._add(i4)._add(s5), I2._rotateAround(e5, t5)._add(i4)._add(s5);
                }
                if (l3) {
                  const t5 = Math.sin(l3), e5 = Math.cos(l3), r4 = [e5, -t5, t5, e5];
                  A2._matMult(r4), k2._matMult(r4), z2._matMult(r4), I2._matMult(r4);
                }
                const M2 = new S(0, 0), B2 = new S(0, 0);
                u3.push({ tl: A2, tr: k2, bl: z2, br: I2, tex: s4, writingMode: e4.writingMode, glyphOffset: m3, sectionIndex: n4.sectionIndex, isSDF: h3, pixelOffsetTL: M2, pixelOffsetBR: B2, minFontScaleX: 0, minFontScaleY: 0 });
              }
            return u3;
          }(0, r2, o2, i2, s2, a2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
          let x2 = null;
          "source" === g2.kind ? (x2 = [Zl * i2.layout.get("text-size").evaluate(a2, {})], x2[0] > xu && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g2.kind && (x2 = [Zl * f2.compositeTextSizes[0].evaluate(a2, {}, y2), Zl * f2.compositeTextSizes[1].evaluate(a2, {}, y2)], (x2[0] > xu || x2[1] > xu) && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, o2, s2, a2, u2, e3, l2.lineStartIndex, l2.lineLength, p2, y2);
          for (const e4 of c2)
            h2[e4] = t2.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function bu(t2) {
          for (const e3 in t2)
            return t2[e3];
          return null;
        }
        function wu(t2, e3, r2, n2) {
          const i2 = t2.compareText;
          if (e3 in i2) {
            const t3 = i2[e3];
            for (let e4 = t3.length - 1; e4 >= 0; e4--)
              if (n2.dist(t3[e4]) < r2)
                return true;
          } else
            i2[e3] = [];
          return i2[e3].push(n2), false;
        }
        const _u = fo.VectorTileFeature.types, Au = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function ku(t2, e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const f2 = o2 ? Math.min(xu, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(xu, Math.round(o2[1])) : 0;
          t2.emplaceBack(e3, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function Su(t2, e3, r2) {
          t2.emplaceBack(e3.x, e3.y, r2), t2.emplaceBack(e3.x, e3.y, r2), t2.emplaceBack(e3.x, e3.y, r2), t2.emplaceBack(e3.x, e3.y, r2);
        }
        function zu(t2) {
          for (const e3 of t2.sections)
            if (Dn(e3.text))
              return true;
          return false;
        }
        class Iu {
          constructor(t2) {
            this.layoutVertexArray = new rs(), this.indexArray = new os(), this.programConfigurations = t2, this.segments = new hs(), this.dynamicLayoutVertexArray = new ns(), this.opacityVertexArray = new is(), this.placedSymbolArray = new ji();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t2, e3, r2, n2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Go.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e3), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Jo.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Au, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        kn("SymbolBuffers", Iu);
        class Mu {
          constructor(t2, e3, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e3, this.indexArray = new r2(), this.segments = new hs(), this.collisionVertexArray = new as();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Xo.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        kn("CollisionBuffers", Mu);
        class Bu {
          constructor(e3) {
            this.collisionBoxArray = e3.collisionBoxArray, this.zoom = e3.zoom, this.overscaling = e3.overscaling, this.layers = e3.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e3.index, this.pixelRatio = e3.pixelRatio, this.sourceLayerIndex = e3.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ua([]), this.placementViewportMatrix = ua([]);
            const r2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Gl(this.zoom, r2["text-size"]), this.iconSizeData = Gl(this.zoom, r2["icon-size"]);
            const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
            this.canOverlap = "never" !== Fu(n2, "text-overlap", "text-allow-overlap") || "never" !== Fu(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s2 && !i2.isConstant(), this.sortFeaturesByY = ("viewport-y" === s2 || "auto" === s2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map((e4) => t.WritingMode[e4])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e3.sourceID;
          }
          createArrays() {
            this.text = new Iu(new Ls(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new Iu(new Ls(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Zi(), this.lineVertexArray = new Gi(), this.symbolInstances = new Ki();
          }
          calculateGlyphDependencies(t2, e3, r2, n2, i2) {
            for (let s2 = 0; s2 < t2.length; s2++)
              if (e3[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
                const r3 = Qo[t2.charAt(s2)];
                r3 && (e3[r3.charCodeAt(0)] = true);
              }
          }
          populate(e3, r2, n2) {
            const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l2 = s2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof Lt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), c2 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = s2.get("symbol-sort-key");
            if (this.features = [], !u2 && !c2)
              return;
            const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y2 = new Yn(this.zoom);
            for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e3) {
              const e4 = i2._featureFilter.needGeometry, g2 = js(r3, e4);
              if (!i2._featureFilter.filter(y2, g2, n2))
                continue;
              let x2, v2;
              if (e4 || (g2.geometry = qs(r3)), u2) {
                const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e5 = Lt.factory(t2);
                zu(e5) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Gn() || this.hasRTLText && Xn.isParsed()) && (x2 = Wo(e5, i2, g2));
              }
              if (c2) {
                const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
                v2 = t2 instanceof Dt ? t2 : Dt.fromString(t2);
              }
              if (!x2 && !v2)
                continue;
              const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
              if (this.features.push({ id: o3, text: x2, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: _u[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x2) {
                const e5 = a2.evaluate(g2, {}, n2).join(","), r4 = "viewport" !== s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.WritingMode.vertical) >= 0;
                for (const t2 of x2.sections)
                  if (t2.image)
                    p2[t2.image.name] = true;
                  else {
                    const n3 = Cn(x2.toString()), i3 = t2.fontStack || e5, s3 = f2[i3] = f2[i3] || {};
                    this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                  }
              }
            }
            "line" === s2.get("symbol-placement") && (this.features = function(t2) {
              const e4 = {}, r3 = {}, n3 = [];
              let i3 = 0;
              function s3(e5) {
                n3.push(t2[e5]), i3++;
              }
              function a3(t3, e5, i4) {
                const s4 = r3[t3];
                return delete r3[t3], r3[e5] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
              }
              function o3(t3, r4, i4) {
                const s4 = e4[r4];
                return delete e4[r4], e4[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
              }
              function l3(t3, e5, r4) {
                const n4 = r4 ? e5[0][e5[0].length - 1] : e5[0][0];
                return `${t3}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t2.length; u3++) {
                const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  s3(u3);
                  continue;
                }
                const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                if (f3 in r3 && d3 in e4 && r3[f3] !== e4[d3]) {
                  const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                  delete e4[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
                } else
                  f3 in r3 ? a3(f3, d3, h3) : d3 in e4 ? o3(f3, d3, h3) : (s3(u3), e4[f3] = i3 - 1, r3[d3] = i3 - 1);
              }
              return n3.filter((t3) => t3.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e4) => t2.sortKey - e4.sortKey);
          }
          update(t2, e3, r2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e3, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e3, this.layers, r2));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e3) {
            const r2 = this.lineVertexArray.length;
            if (void 0 !== t2.segment) {
              let r3 = t2.dist(e3[t2.segment + 1]), n2 = t2.dist(e3[t2.segment]);
              const i2 = {};
              for (let n3 = t2.segment + 1; n3 < e3.length; n3++)
                i2[n3] = { x: e3[n3].x, y: e3[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e3.length - 1 && (r3 += e3[n3 + 1].dist(e3[n3]));
              for (let r4 = t2.segment || 0; r4 >= 0; r4--)
                i2[r4] = { x: e3[r4].x, y: e3[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e3[r4 - 1].dist(e3[r4]));
              for (let t3 = 0; t3 < e3.length; t3++) {
                const e4 = i2[t3];
                this.lineVertexArray.emplaceBack(e4.x, e4.y, e4.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(e3, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = e3.indexArray, d2 = e3.layoutVertexArray, y2 = e3.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.WritingMode.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
            for (let t2 = 0; t2 < r2.length; t2++) {
              const { tl: i3, tr: s3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t2], k2 = y2.vertexLength, S2 = w2[1];
              ku(d2, l2.x, l2.y, i3.x, S2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), ku(d2, l2.x, l2.y, s3.x, S2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), ku(d2, l2.x, l2.y, o3.x, S2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), ku(d2, l2.x, l2.y, u3.x, S2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), Su(e3.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(k2, k2 + 1, k2 + 2), f2.emplaceBack(k2 + 1, k2 + 2, k2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e3.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v2 && v2[A2]);
            }
            e3.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
          }
          _addCollisionDebugVertex(t2, e3, r2, n2, i2, s2) {
            return e3.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
          }
          addCollisionDebugVertices(t2, e3, r2, n2, i2, s2, a2) {
            const o2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), l2 = o2.vertexLength, u2 = i2.layoutVertexArray, c2 = i2.collisionVertexArray, h2 = a2.anchorX, p2 = a2.anchorY;
            this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(t2, e3)), this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(r2, e3)), this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(r2, n2)), this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(t2, n2)), o2.vertexLength += 4;
            const f2 = i2.indexArray;
            f2.emplaceBack(l2, l2 + 1), f2.emplaceBack(l2 + 1, l2 + 2), f2.emplaceBack(l2 + 2, l2 + 3), f2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t2, e3, r2, n2) {
            for (let i2 = t2; i2 < e3; i2++) {
              const t3 = this.collisionBoxArray.get(i2);
              this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Mu(ss, Yo.members, ls), this.iconCollisionBox = new Mu(ss, Yo.members, ls);
            for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
              const e3 = this.symbolInstances.get(t2);
              this.addDebugCollisionBoxes(e3.textBoxStartIndex, e3.textBoxEndIndex, e3, true), this.addDebugCollisionBoxes(e3.verticalTextBoxStartIndex, e3.verticalTextBoxEndIndex, e3, true), this.addDebugCollisionBoxes(e3.iconBoxStartIndex, e3.iconBoxEndIndex, e3, false), this.addDebugCollisionBoxes(e3.verticalIconBoxStartIndex, e3.verticalIconBoxEndIndex, e3, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t2, e3, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = {};
            for (let n3 = e3; n3 < r2; n3++) {
              const e4 = t2.get(n3);
              u2.textBox = { x1: e4.x1, y1: e4.y1, x2: e4.x2, y2: e4.y2, anchorPointX: e4.anchorPointX, anchorPointY: e4.anchorPointY }, u2.textFeatureIndex = e4.featureIndex;
              break;
            }
            for (let e4 = n2; e4 < i2; e4++) {
              const r3 = t2.get(e4);
              u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e4 = s2; e4 < a2; e4++) {
              const r3 = t2.get(e4);
              u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e4 = o2; e4 < l2; e4++) {
              const r3 = t2.get(e4);
              u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
              break;
            }
            return u2;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e3 = 0; e3 < this.symbolInstances.length; e3++) {
              const r2 = this.symbolInstances.get(e3);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t2, e3) {
            const r2 = t2.placedSymbolArray.get(e3), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e4 = r2.vertexStartIndex; e4 < n2; e4 += 4)
              t2.indexArray.emplaceBack(e4, e4 + 1, e4 + 2), t2.indexArray.emplaceBack(e4 + 1, e4 + 2, e4 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            const e3 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              s2.push(t3);
              const a2 = this.symbolInstances.get(t3);
              n2.push(0 | Math.round(e3 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
            }
            return s2.sort((t3, e4) => n2[t3] - n2[e4] || i2[e4] - i2[t3]), s2;
          }
          addToSortKeyRanges(t2, e3) {
            const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e3 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e3, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t3 of this.symbolInstanceIndexes) {
                const e3 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e3.featureIndex), [e3.rightJustifiedTextSymbolIndex, e3.centerJustifiedTextSymbolIndex, e3.leftJustifiedTextSymbolIndex].forEach((t4, e4, r2) => {
                  t4 >= 0 && r2.indexOf(t4) === e4 && this.addIndicesForPlacedSymbol(this.text, t4);
                }), e3.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e3.verticalPlacedTextSymbolIndex), e3.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.placedIconSymbolIndex), e3.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        kn("SymbolBucket", Bu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Bu.MAX_GLYPHS = 65535, Bu.addDynamicAttributes = Su;
        const Cu = new ci({ "symbol-placement": new si(nt.layout_symbol["symbol-placement"]), "symbol-spacing": new si(nt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new si(nt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ai(nt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new si(nt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new si(nt.layout_symbol["icon-allow-overlap"]), "icon-overlap": new si(nt.layout_symbol["icon-overlap"]), "icon-ignore-placement": new si(nt.layout_symbol["icon-ignore-placement"]), "icon-optional": new si(nt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new si(nt.layout_symbol["icon-rotation-alignment"]), "icon-size": new ai(nt.layout_symbol["icon-size"]), "icon-text-fit": new si(nt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new si(nt.layout_symbol["icon-text-fit-padding"]), "icon-image": new ai(nt.layout_symbol["icon-image"]), "icon-rotate": new ai(nt.layout_symbol["icon-rotate"]), "icon-padding": new si(nt.layout_symbol["icon-padding"]), "icon-keep-upright": new si(nt.layout_symbol["icon-keep-upright"]), "icon-offset": new ai(nt.layout_symbol["icon-offset"]), "icon-anchor": new ai(nt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new si(nt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new si(nt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new si(nt.layout_symbol["text-rotation-alignment"]), "text-field": new ai(nt.layout_symbol["text-field"]), "text-font": new ai(nt.layout_symbol["text-font"]), "text-size": new ai(nt.layout_symbol["text-size"]), "text-max-width": new ai(nt.layout_symbol["text-max-width"]), "text-line-height": new si(nt.layout_symbol["text-line-height"]), "text-letter-spacing": new ai(nt.layout_symbol["text-letter-spacing"]), "text-justify": new ai(nt.layout_symbol["text-justify"]), "text-radial-offset": new ai(nt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new si(nt.layout_symbol["text-variable-anchor"]), "text-anchor": new ai(nt.layout_symbol["text-anchor"]), "text-max-angle": new si(nt.layout_symbol["text-max-angle"]), "text-writing-mode": new si(nt.layout_symbol["text-writing-mode"]), "text-rotate": new ai(nt.layout_symbol["text-rotate"]), "text-padding": new si(nt.layout_symbol["text-padding"]), "text-keep-upright": new si(nt.layout_symbol["text-keep-upright"]), "text-transform": new ai(nt.layout_symbol["text-transform"]), "text-offset": new ai(nt.layout_symbol["text-offset"]), "text-allow-overlap": new si(nt.layout_symbol["text-allow-overlap"]), "text-overlap": new si(nt.layout_symbol["text-overlap"]), "text-ignore-placement": new si(nt.layout_symbol["text-ignore-placement"]), "text-optional": new si(nt.layout_symbol["text-optional"]) });
        var Pu = { paint: new ci({ "icon-opacity": new ai(nt.paint_symbol["icon-opacity"]), "icon-color": new ai(nt.paint_symbol["icon-color"]), "icon-halo-color": new ai(nt.paint_symbol["icon-halo-color"]), "icon-halo-width": new ai(nt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ai(nt.paint_symbol["icon-halo-blur"]), "icon-translate": new si(nt.paint_symbol["icon-translate"]), "icon-translate-anchor": new si(nt.paint_symbol["icon-translate-anchor"]), "text-opacity": new ai(nt.paint_symbol["text-opacity"]), "text-color": new ai(nt.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new ai(nt.paint_symbol["text-halo-color"]), "text-halo-width": new ai(nt.paint_symbol["text-halo-width"]), "text-halo-blur": new ai(nt.paint_symbol["text-halo-blur"]), "text-translate": new si(nt.paint_symbol["text-translate"]), "text-translate-anchor": new si(nt.paint_symbol["text-translate-anchor"]) }), layout: Cu };
        class Vu {
          constructor(t2) {
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ht, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              const e3 = this.defaultValue.property.overrides;
              if (e3 && e3.hasOverride(t2.formattedSection))
                return e3.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        kn("FormatSectionOverride", Vu, { omit: ["defaultValue"] });
        class Eu extends pi {
          constructor(t2) {
            super(t2, Pu);
          }
          recalculate(t2, e3) {
            if (super.recalculate(t2, e3), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t3 = this.layout.get("text-writing-mode");
              if (t3) {
                const e4 = [];
                for (const r2 of t3)
                  e4.indexOf(r2) < 0 && e4.push(r2);
                this.layout._values["text-writing-mode"] = e4;
              } else
                this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t2, e3, r2, n2) {
            const i2 = this.layout.get(t2).evaluate(e3, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
            return s2.isDataDriven() || Pr(s2.value) || !i2 ? i2 : function(t3, e4) {
              return e4.replace(/{([^{}]+)}/g, (e5, r3) => r3 in t3 ? String(t3[r3]) : "");
            }(e3.properties, i2);
          }
          createBucket(t2) {
            return new Bu(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t2 of Pu.paint.overridableProperties) {
              if (!Eu.hasPaintOverride(this.layout, t2))
                continue;
              const e3 = this.paint.get(t2), r2 = new Vu(e3), n2 = new Cr(r2, e3.property.specification);
              let i2 = null;
              i2 = "constant" === e3.value.kind || "source" === e3.value.kind ? new Er("source", n2) : new Fr("composite", n2, e3.value.zoomStops, e3.value._interpolationType), this.paint._values[t2] = new ni(e3.property, i2, e3.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e3, r2) {
            return !(!this.layout || e3.isDataDriven() || r2.isDataDriven()) && Eu.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e3) {
            const r2 = t2.get("text-field"), n2 = Pu.paint.properties[e3];
            let i2 = false;
            const s2 = (t3) => {
              for (const e4 of t3)
                if (n2.overrides && n2.overrides.hasOverride(e4))
                  return void (i2 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof Lt)
              s2(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              const t3 = (e5) => {
                i2 || (e5 instanceof qt && Ut(e5.value) === vt ? s2(e5.value.sections) : e5 instanceof Zt ? s2(e5.sections) : e5.eachChild(t3));
              }, e4 = r2.value;
              e4._styleExpression && t3(e4._styleExpression.expression);
            }
            return i2;
          }
        }
        function Fu(t2, e3, r2) {
          let n2 = "never";
          const i2 = t2.get(e3);
          return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
        }
        var Tu = { paint: new ci({ "background-color": new si(nt.paint_background["background-color"]), "background-pattern": new li(nt.paint_background["background-pattern"]), "background-opacity": new si(nt.paint_background["background-opacity"]) }) }, Lu = { paint: new ci({ "raster-opacity": new si(nt.paint_raster["raster-opacity"]), "raster-hue-rotate": new si(nt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new si(nt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new si(nt.paint_raster["raster-brightness-max"]), "raster-saturation": new si(nt.paint_raster["raster-saturation"]), "raster-contrast": new si(nt.paint_raster["raster-contrast"]), "raster-resampling": new si(nt.paint_raster["raster-resampling"]), "raster-fade-duration": new si(nt.paint_raster["raster-fade-duration"]) }) };
        class Du extends pi {
          constructor(t2) {
            super(t2, {}), this.onAdd = (t3) => {
              this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
            }, this.onRemove = (t3) => {
              this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
            }, this.implementation = t2;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
          }
        }
        const $u = { circle: class extends pi {
          constructor(t2) {
            super(t2, oa);
          }
          createBucket(t2) {
            return new Ks(t2);
          }
          queryRadius(t2) {
            const e3 = t2;
            return na("circle-radius", this, e3) + na("circle-stroke-width", this, e3) + ia(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t2, e3, r2, n2, i2, s2, a2, o2) {
            const l2 = sa(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, a2), u2 = this.paint.get("circle-radius").evaluate(e3, r2) + this.paint.get("circle-stroke-width").evaluate(e3, r2), c2 = "map" === this.paint.get("circle-pitch-alignment"), h2 = c2 ? l2 : function(t3, e4) {
              return t3.map((t4) => da(t4, e4));
            }(l2, o2), p2 = c2 ? u2 * a2 : u2;
            for (const t3 of n2)
              for (const e4 of t3) {
                const t4 = c2 ? e4 : da(e4, o2);
                let r3 = p2;
                const n3 = fa([], [e4.x, e4.y, 0, 1], o2);
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= n3[3] / s2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= s2.cameraToCenterDistance / n3[3]), Gs(h2, t4, r3))
                  return true;
              }
            return false;
          }
        }, heatmap: class extends pi {
          constructor(t2) {
            super(t2, ma), this._updateColorRamp();
          }
          createBucket(t2) {
            return new ya(t2);
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "heatmap-color" === t2 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = _a2({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }, hillshade: class extends pi {
          constructor(t2) {
            super(t2, Aa);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }, fill: class extends pi {
          constructor(t2) {
            super(t2, co);
          }
          recalculate(t2, e3) {
            super.recalculate(t2, e3);
            const r2 = this.paint._values["fill-outline-color"];
            "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new lo(t2);
          }
          queryRadius() {
            return ia(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t2, e3, r2, n2, i2, s2, a2) {
            return Js(sa(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, a2), n2);
          }
          isTileClipped() {
            return true;
          }
        }, "fill-extrusion": class extends pi {
          constructor(t2) {
            super(t2, Vo);
          }
          createBucket(t2) {
            return new Bo(t2);
          }
          queryRadius() {
            return ia(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature(t2, e3, r2, n2, i2, s2, a2, o2) {
            const l2 = sa(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, a2), u2 = this.paint.get("fill-extrusion-height").evaluate(e3, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e3, r2), h2 = function(t3, e4, r3, n3) {
              const i3 = [];
              for (const r4 of t3) {
                const t4 = [r4.x, r4.y, 0, 1];
                fa(t4, t4, e4), i3.push(new S(t4[0] / t4[3], t4[1] / t4[3]));
              }
              return i3;
            }(l2, o2), p2 = function(t3, e4, r3, n3) {
              const i3 = [], s3 = [], a3 = n3[8] * e4, o3 = n3[9] * e4, l3 = n3[10] * e4, u3 = n3[11] * e4, c3 = n3[8] * r3, h3 = n3[9] * r3, p3 = n3[10] * r3, f2 = n3[11] * r3;
              for (const e5 of t3) {
                const t4 = [], r4 = [];
                for (const i4 of e5) {
                  const e6 = i4.x, s4 = i4.y, d2 = n3[0] * e6 + n3[4] * s4 + n3[12], y2 = n3[1] * e6 + n3[5] * s4 + n3[13], m2 = n3[2] * e6 + n3[6] * s4 + n3[14], g2 = n3[3] * e6 + n3[7] * s4 + n3[15], x2 = m2 + l3, v2 = g2 + u3, b2 = d2 + c3, w2 = y2 + h3, _2 = m2 + p3, A2 = g2 + f2, k2 = new S((d2 + a3) / v2, (y2 + o3) / v2);
                  k2.z = x2 / v2, t4.push(k2);
                  const z2 = new S(b2 / A2, w2 / A2);
                  z2.z = _2 / A2, r4.push(z2);
                }
                i3.push(t4), s3.push(r4);
              }
              return [i3, s3];
            }(n2, c2, u2, o2);
            return function(t3, e4, r3) {
              let n3 = 1 / 0;
              Js(r3, e4) && (n3 = Fo(r3, e4[0]));
              for (let i3 = 0; i3 < e4.length; i3++) {
                const s3 = e4[i3], a3 = t3[i3];
                for (let t4 = 0; t4 < s3.length - 1; t4++) {
                  const e5 = s3[t4], i4 = [e5, s3[t4 + 1], a3[t4 + 1], a3[t4], e5];
                  Zs(r3, i4) && (n3 = Math.min(n3, Fo(r3, i4)));
                }
              }
              return n3 !== 1 / 0 && n3;
            }(p2[0], p2[1], h2);
          }
        }, line: class extends pi {
          constructor(t2) {
            super(t2, No), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "line-gradient" === t2 && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof ke, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t2, e3) {
            super.recalculate(t2, e3), this.paint._values["line-floorwidth"] = Ko.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new qo(t2);
          }
          queryRadius(t2) {
            const e3 = t2, r2 = Zo(na("line-width", this, e3), na("line-gap-width", this, e3)), n2 = na("line-offset", this, e3);
            return r2 / 2 + Math.abs(n2) + ia(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t2, e3, r2, n2, i2, s2, a2) {
            const o2 = sa(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, a2), l2 = a2 / 2 * Zo(this.paint.get("line-width").evaluate(e3, r2), this.paint.get("line-gap-width").evaluate(e3, r2)), u2 = this.paint.get("line-offset").evaluate(e3, r2);
            return u2 && (n2 = function(t3, e4) {
              const r3 = [];
              for (let n3 = 0; n3 < t3.length; n3++) {
                const i3 = t3[n3], s3 = [];
                for (let t4 = 0; t4 < i3.length; t4++) {
                  const r4 = i3[t4 - 1], n4 = i3[t4], a3 = i3[t4 + 1], o3 = 0 === t4 ? new S(0, 0) : n4.sub(r4)._unit()._perp(), l3 = t4 === i3.length - 1 ? new S(0, 0) : a3.sub(n4)._unit()._perp(), u3 = o3._add(l3)._unit(), c2 = u3.x * l3.x + u3.y * l3.y;
                  0 !== c2 && u3._mult(1 / c2), s3.push(u3._mult(e4)._add(n4));
                }
                r3.push(s3);
              }
              return r3;
            }(n2, u2 * a2)), function(t3, e4, r3) {
              for (let n3 = 0; n3 < e4.length; n3++) {
                const i3 = e4[n3];
                if (t3.length >= 3) {
                  for (let e5 = 0; e5 < i3.length; e5++)
                    if (ea(t3, i3[e5]))
                      return true;
                }
                if (Xs(t3, i3, r3))
                  return true;
              }
              return false;
            }(o2, n2, l2);
          }
          isTileClipped() {
            return true;
          }
        }, symbol: Eu, background: class extends pi {
          constructor(t2) {
            super(t2, Tu);
          }
        }, raster: class extends pi {
          constructor(t2) {
            super(t2, Lu);
          }
        } };
        class Ru {
          constructor(t2) {
            this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            delete this._channel, this._callback = () => {
            };
          }
        }
        const Uu = 63710088e-1;
        class Ou {
          constructor(t2, e3) {
            if (isNaN(t2) || isNaN(e3))
              throw new Error(`Invalid LngLat object: (${t2}, ${e3})`);
            if (this.lng = +t2, this.lat = +e3, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Ou(a(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t2) {
            const e3 = Math.PI / 180, r2 = this.lat * e3, n2 = t2.lat * e3, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e3);
            return Uu * Math.acos(Math.min(i2, 1));
          }
          toBounds(t2 = 0) {
            const e3 = 360 * t2 / 40075017, r2 = e3 / Math.cos(Math.PI / 180 * this.lat);
            return new qu(new Ou(this.lng - r2, this.lat - e3), new Ou(this.lng + r2, this.lat + e3));
          }
          static convert(t2) {
            if (t2 instanceof Ou)
              return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
              return new Ou(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
              return new Ou(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        class qu {
          constructor(t2, e3) {
            t2 && (e3 ? this.setSouthWest(t2).setNorthEast(e3) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
          }
          setNorthEast(t2) {
            return this._ne = t2 instanceof Ou ? new Ou(t2.lng, t2.lat) : Ou.convert(t2), this;
          }
          setSouthWest(t2) {
            return this._sw = t2 instanceof Ou ? new Ou(t2.lng, t2.lat) : Ou.convert(t2), this;
          }
          extend(t2) {
            const e3 = this._sw, r2 = this._ne;
            let n2, i2;
            if (t2 instanceof Ou)
              n2 = t2, i2 = t2;
            else {
              if (!(t2 instanceof qu))
                return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(qu.convert(t2)) : this.extend(Ou.convert(t2)) : this;
              if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
                return this;
            }
            return e3 || r2 ? (e3.lng = Math.min(n2.lng, e3.lng), e3.lat = Math.min(n2.lat, e3.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Ou(n2.lng, n2.lat), this._ne = new Ou(i2.lng, i2.lat)), this;
          }
          getCenter() {
            return new Ou((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new Ou(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new Ou(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t2) {
            const { lng: e3, lat: r2 } = Ou.convert(t2);
            let n2 = this._sw.lng <= e3 && e3 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e3 && e3 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
          }
          static convert(t2) {
            return t2 instanceof qu ? t2 : t2 ? new qu(t2) : t2;
          }
        }
        const ju = 2 * Math.PI * Uu;
        function Nu(t2) {
          return ju * Math.cos(t2 * Math.PI / 180);
        }
        function Ku(t2) {
          return (180 + t2) / 360;
        }
        function Zu(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function Gu(t2, e3) {
          return t2 / Nu(e3);
        }
        function Ju(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        class Xu {
          constructor(t2, e3, r2 = 0) {
            this.x = +t2, this.y = +e3, this.z = +r2;
          }
          static fromLngLat(t2, e3 = 0) {
            const r2 = Ou.convert(t2);
            return new Xu(Ku(r2.lng), Zu(r2.lat), Gu(e3, r2.lat));
          }
          toLngLat() {
            return new Ou(360 * this.x - 180, Ju(this.y));
          }
          toAltitude() {
            return this.z * Nu(Ju(this.y));
          }
          meterInMercatorCoordinateUnits() {
            return 1 / ju * (t2 = Ju(this.y), 1 / Math.cos(t2 * Math.PI / 180));
            var t2;
          }
        }
        function Yu(t2, e3, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e3 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class Hu {
          constructor(t2, e3, r2) {
            this.z = t2, this.x = e3, this.y = r2, this.key = tc(0, t2, t2, e3, r2);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          url(t2, e3, r2) {
            const n2 = (s2 = this.y, a2 = this.z, o2 = Yu(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l2 = Yu(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
            var i2, s2, a2, o2, l2;
            const u2 = function(t3, e4, r3) {
              let n3, i3 = "";
              for (let s3 = t3; s3 > 0; s3--)
                n3 = 1 << s3 - 1, i3 += (e4 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e3 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
          }
          getTilePoint(t2) {
            const e3 = Math.pow(2, this.z);
            return new S((t2.x * e3 - this.x) * Rs, (t2.y * e3 - this.y) * Rs);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Wu {
          constructor(t2, e3) {
            this.wrap = t2, this.canonical = e3, this.key = tc(t2, e3.z, e3.z, e3.x, e3.y);
          }
        }
        class Qu {
          constructor(t2, e3, r2, n2, i2) {
            this.overscaledZ = t2, this.wrap = e3, this.canonical = new Hu(r2, +n2, +i2), this.key = tc(e3, t2, r2, n2, i2);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            const e3 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new Qu(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Qu(t2, this.wrap, t2, this.canonical.x >> e3, this.canonical.y >> e3);
          }
          calculateScaledKey(t2, e3) {
            const r2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? tc(this.wrap * +e3, t2, this.canonical.z, this.canonical.x, this.canonical.y) : tc(this.wrap * +e3, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap)
              return false;
            const e3 = this.canonical.z - t2.canonical.z;
            return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e3 && t2.canonical.y === this.canonical.y >> e3;
          }
          children(t2) {
            if (this.overscaledZ >= t2)
              return [new Qu(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e3 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new Qu(e3, this.wrap, e3, r2, n2), new Qu(e3, this.wrap, e3, r2 + 1, n2), new Qu(e3, this.wrap, e3, r2, n2 + 1), new Qu(e3, this.wrap, e3, r2 + 1, n2 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new Qu(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new Qu(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Wu(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t2) {
            return this.canonical.getTilePoint(new Xu(t2.x - this.wrap, t2.y));
          }
        }
        function tc(t2, e3, r2, n2, i2) {
          (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
          const s2 = 1 << r2;
          return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e3.toString(36);
        }
        kn("CanonicalTileID", Hu), kn("OverscaledTileID", Qu, { omit: ["posMatrix"] });
        class ec {
          constructor(t2, e3, r2) {
            if (this.uid = t2, e3.height !== e3.width)
              throw new RangeError("DEM tiles must be square");
            if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
              return void d(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e3.height;
            const n2 = this.dim = e3.height - 2;
            this.data = new Uint32Array(e3.data.buffer), this.encoding = r2 || "mapbox";
            for (let t3 = 0; t3 < n2; t3++)
              this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(n2, t3)] = this.data[this._idx(n2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, n2)] = this.data[this._idx(t3, n2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)];
          }
          get(t2, e3) {
            const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e3);
            return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
          }
          getUnpackVector() {
            return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
          }
          _idx(t2, e3) {
            if (t2 < -1 || t2 >= this.dim + 1 || e3 < -1 || e3 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e3 + 1) * this.stride + (t2 + 1);
          }
          _unpackMapbox(t2, e3, r2) {
            return (256 * t2 * 256 + 256 * e3 + r2) / 10 - 1e4;
          }
          _unpackTerrarium(t2, e3, r2) {
            return 256 * t2 + e3 + r2 / 256 - 32768;
          }
          getPixels() {
            return new wa({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t2, e3, r2) {
            if (this.dim !== t2.dim)
              throw new Error("dem dimension mismatch");
            let n2 = e3 * this.dim, i2 = e3 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
            switch (e3) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r2) {
              case -1:
                s2 = a2 - 1;
                break;
              case 1:
                a2 = s2 + 1;
            }
            const o2 = -e3 * this.dim, l2 = -r2 * this.dim;
            for (let e4 = s2; e4 < a2; e4++)
              for (let r3 = n2; r3 < i2; r3++)
                this.data[this._idx(r3, e4)] = t2.data[this._idx(r3 + o2, e4 + l2)];
          }
        }
        kn("DEMData", ec);
        class rc {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r2 = t2[e3];
              this._stringToNumber[r2] = e3, this._numberToString[e3] = r2;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            return this._numberToString[t2];
          }
        }
        class nc {
          constructor(t2, e3, r2, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, t2._z = e3, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            const t2 = { geometry: this.geometry };
            for (const e3 in this)
              "_geometry" !== e3 && "_vectorTileFeature" !== e3 && (t2[e3] = this[e3]);
            return t2;
          }
        }
        class ic {
          constructor(t2, e3) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new _n(Rs, 16, 0), this.grid3D = new _n(Rs, 16, 0), this.featureIndexArray = new Xi(), this.promoteId = e3;
          }
          insert(t2, e3, r2, n2, i2, s2) {
            const a2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i2);
            const o2 = s2 ? this.grid3D : this.grid;
            for (let t3 = 0; t3 < e3.length; t3++) {
              const r3 = e3[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r3.length; t4++) {
                const e4 = r3[t4];
                n3[0] = Math.min(n3[0], e4.x), n3[1] = Math.min(n3[1], e4.y), n3[2] = Math.max(n3[2], e4.x), n3[3] = Math.max(n3[3], e4.y);
              }
              n3[0] < Rs && n3[1] < Rs && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new fo.VectorTile(new el(this.rawTileData)).layers, this.sourceLayerCoder = new rc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t2, e3, r2, n2) {
            this.loadVTLayers();
            const i2 = t2.params || {}, s2 = Rs / t2.tileSize / t2.scale, a2 = Zr(i2.filter), o2 = t2.queryGeometry, l2 = t2.queryPadding * s2, u2 = ac(o2), c2 = this.grid.query(u2.minX - l2, u2.minY - l2, u2.maxX + l2, u2.maxY + l2), h2 = ac(t2.cameraQueryGeometry), p2 = this.grid3D.query(h2.minX - l2, h2.minY - l2, h2.maxX + l2, h2.maxY + l2, (e4, r3, n3, i3) => function(t3, e5, r4, n4, i4) {
              for (const s4 of t3)
                if (e5 <= s4.x && r4 <= s4.y && n4 >= s4.x && i4 >= s4.y)
                  return true;
              const s3 = [new S(e5, r4), new S(e5, i4), new S(n4, i4), new S(n4, r4)];
              if (t3.length > 2) {
                for (const e6 of s3)
                  if (ea(t3, e6))
                    return true;
              }
              for (let e6 = 0; e6 < t3.length - 1; e6++)
                if (ra(t3[e6], t3[e6 + 1], s3))
                  return true;
              return false;
            }(t2.cameraQueryGeometry, e4 - l2, r3 - l2, n3 + l2, i3 + l2));
            for (const t3 of p2)
              c2.push(t3);
            c2.sort(oc);
            const f2 = {};
            let d2;
            for (let l3 = 0; l3 < c2.length; l3++) {
              const u3 = c2[l3];
              if (u3 === d2)
                continue;
              d2 = u3;
              const h3 = this.featureIndexArray.get(u3);
              let p3 = null;
              this.loadMatchingFeature(f2, h3.bucketIndex, h3.sourceLayerIndex, h3.featureIndex, a2, i2.layers, i2.availableImages, e3, r2, n2, (e4, r3, n3) => (p3 || (p3 = qs(e4)), r3.queryIntersectsFeature(o2, e4, n3, p3, this.z, t2.transform, s2, t2.pixelPosMatrix)));
            }
            return f2;
          }
          loadMatchingFeature(t2, e3, r2, n2, i2, s2, a2, l2, u2, c2, h2) {
            const p2 = this.bucketLayerIDs[e3];
            if (s2 && !function(t3, e4) {
              for (let r3 = 0; r3 < t3.length; r3++)
                if (e4.indexOf(t3[r3]) >= 0)
                  return true;
              return false;
            }(s2, p2))
              return;
            const f2 = this.sourceLayerCoder.decode(r2), d2 = this.vtLayers[f2].feature(n2);
            if (i2.needGeometry) {
              const t3 = js(d2, true);
              if (!i2.filter(new Yn(this.tileID.overscaledZ), t3, this.tileID.canonical))
                return;
            } else if (!i2.filter(new Yn(this.tileID.overscaledZ), d2))
              return;
            const y2 = this.getId(d2, f2);
            for (let e4 = 0; e4 < p2.length; e4++) {
              const r3 = p2[e4];
              if (s2 && s2.indexOf(r3) < 0)
                continue;
              const i3 = l2[r3];
              if (!i3)
                continue;
              let f3 = {};
              y2 && c2 && (f3 = c2.getState(i3.sourceLayer || "_geojsonTileLayer", y2));
              const m2 = o({}, u2[r3]);
              m2.paint = sc(m2.paint, i3.paint, d2, f3, a2), m2.layout = sc(m2.layout, i3.layout, d2, f3, a2);
              const g2 = !h2 || h2(d2, i3, f3);
              if (!g2)
                continue;
              const x2 = new nc(d2, this.z, this.x, this.y, y2);
              x2.layer = m2;
              let v2 = t2[r3];
              void 0 === v2 && (v2 = t2[r3] = []), v2.push({ featureIndex: n2, feature: x2, intersectionZ: g2 });
            }
          }
          lookupSymbolFeatures(t2, e3, r2, n2, i2, s2, a2, o2) {
            const l2 = {};
            this.loadVTLayers();
            const u2 = Zr(i2);
            for (const i3 of t2)
              this.loadMatchingFeature(l2, r2, n2, i3, u2, s2, a2, o2, e3);
            return l2;
          }
          hasLayer(t2) {
            for (const e3 of this.bucketLayerIDs)
              for (const r2 of e3)
                if (t2 === r2)
                  return true;
            return false;
          }
          getId(t2, e3) {
            let r2 = t2.id;
            return this.promoteId && (r2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e3]], "boolean" == typeof r2 && (r2 = Number(r2))), r2;
          }
        }
        function sc(t2, e3, r2, n2, i2) {
          return c(t2, (t3, s2) => {
            const a2 = e3 instanceof ii ? e3.get(s2) : null;
            return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
          });
        }
        function ac(t2) {
          let e3 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (const s2 of t2)
            e3 = Math.min(e3, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          return { minX: e3, minY: r2, maxX: n2, maxY: i2 };
        }
        function oc(t2, e3) {
          return e3 - t2;
        }
        var lc;
        kn("FeatureIndex", ic, { omit: ["rawTileData", "sourceLayerCoder"] }), t.PerformanceMarkers = void 0, (lc = t.PerformanceMarkers || (t.PerformanceMarkers = {})).create = "create", lc.load = "load", lc.fullLoad = "fullLoad";
        let uc = null, cc = [];
        const hc = 1e3 / 30, pc = { mark(t2) {
          performance.mark(t2);
        }, frame(t2) {
          const e3 = t2;
          null != uc && cc.push(e3 - uc), uc = e3;
        }, clearMetrics() {
          uc = null, cc = [], performance.clearMeasures("loadTime"), performance.clearMeasures("fullLoadTime");
          for (const e3 in t.PerformanceMarkers)
            performance.clearMarks(t.PerformanceMarkers[e3]);
        }, getPerformanceMetrics() {
          performance.measure("loadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.load), performance.measure("fullLoadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.fullLoad);
          const e3 = performance.getEntriesByName("loadTime")[0].duration, r2 = performance.getEntriesByName("fullLoadTime")[0].duration, n2 = cc.length, i2 = 1 / (cc.reduce((t2, e4) => t2 + e4, 0) / n2 / 1e3), s2 = cc.filter((t2) => t2 > hc).reduce((t2, e4) => t2 + (e4 - hc) / hc, 0);
          return { loadTime: e3, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100 };
        } };
        t.AJAXError = q, t.ARRAY_TYPE = la, t.Actor = class {
          constructor(t2, e3, r2) {
            this.target = t2, this.parent = e3, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, u(["receive", "process"], this), this.invoker = new Ru(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = g() ? t2 : window;
          }
          send(t2, e3, r2, n2, i2 = false) {
            const s2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r2 && (this.callbacks[s2] = r2);
            const a2 = _(this.globalScope) ? void 0 : [];
            return this.target.postMessage({ id: s2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: zn(e3, a2) }, a2), { cancel: () => {
              r2 && delete this.callbacks[s2], this.target.postMessage({ id: s2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
            } };
          }
          receive(t2) {
            const e3 = t2.data, r2 = e3.id;
            if (r2 && (!e3.targetMapId || this.mapId === e3.targetMapId))
              if ("<cancel>" === e3.type) {
                delete this.tasks[r2];
                const t3 = this.cancelCallbacks[r2];
                delete this.cancelCallbacks[r2], t3 && t3();
              } else
                g() || e3.mustQueue ? (this.tasks[r2] = e3, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e3);
          }
          process() {
            if (!this.taskQueue.length)
              return;
            const t2 = this.taskQueue.shift(), e3 = this.tasks[t2];
            delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), e3 && this.processTask(t2, e3);
          }
          processTask(t2, e3) {
            if ("<response>" === e3.type) {
              const r2 = this.callbacks[t2];
              delete this.callbacks[t2], r2 && (e3.error ? r2(In(e3.error)) : r2(null, In(e3.data)));
            } else {
              let r2 = false;
              const n2 = _(this.globalScope) ? void 0 : [], i2 = e3.hasCallback ? (e4, i3) => {
                r2 = true, delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e4 ? zn(e4) : null, data: zn(i3, n2) }, n2);
              } : (t3) => {
                r2 = true;
              };
              let s2 = null;
              const a2 = In(e3.data);
              if (this.parent[e3.type])
                s2 = this.parent[e3.type](e3.sourceMapId, a2, i2);
              else if (this.parent.getWorkerSource) {
                const t3 = e3.type.split(".");
                s2 = this.parent.getWorkerSource(e3.sourceMapId, t3[0], a2.source)[t3[1]](a2, i2);
              } else
                i2(new Error(`Could not find function ${e3.type}`));
              !r2 && s2 && s2.cancel && (this.cancelCallbacks[t2] = s2.cancel);
            }
          }
          remove() {
            this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }, t.AlphaImage = ba, t.CanonicalTileID = Hu, t.CollisionBoxArray = Oi, t.CollisionCircleLayoutArray = class extends Bi {
        }, t.Color = Et, t.DEMData = ec, t.DataConstantProperty = si, t.DictionaryCoder = rc, t.EXTENT = Rs, t.ErrorEvent = et, t.EvaluationParameters = Yn, t.Event = tt, t.Evented = rt, t.FeatureIndex = ic, t.FillBucket = lo, t.FillExtrusionBucket = Bo, t.GeoJSONFeature = nc, t.ImageAtlas = Bl, t.ImagePosition = Ml, t.LineBucket = qo, t.LineStripIndexArray = class extends $i {
        }, t.LngLat = Ou, t.LngLatBounds = qu, t.MercatorCoordinate = Xu, t.ONE_EM = tl, t.OverscaledTileID = Qu, t.PerformanceUtils = pc, t.PosArray = class extends xi {
        }, t.Properties = ci, t.QuadTriangleArray = class extends Pi {
        }, t.RGBAImage = wa, t.RasterBoundsArray = class extends vi {
        }, t.RequestPerformance = class {
          constructor(t2) {
            this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t2 = performance.getEntriesByName(this._marks.measure);
            return 0 === t2.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
          }
        }, t.ResourceType = O, t.SegmentVector = hs, t.SymbolBucket = Bu, t.Transitionable = Qn, t.TriangleIndexArray = os, t.Uniform1f = Ss, t.Uniform1i = class extends ks {
          constructor(t2, e3) {
            super(t2, e3), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
          }
        }, t.Uniform2f = class extends ks {
          constructor(t2, e3) {
            super(t2, e3), this.current = [0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
          }
        }, t.Uniform3f = class extends ks {
          constructor(t2, e3) {
            super(t2, e3), this.current = [0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
          }
        }, t.Uniform4f = zs, t.UniformColor = Is, t.UniformMatrix4f = class extends ks {
          constructor(t2, e3) {
            super(t2, e3), this.current = Ms;
          }
          set(t2) {
            if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
              return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
            for (let e3 = 1; e3 < 16; e3++)
              if (t2[e3] !== this.current[e3]) {
                this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
                break;
              }
          }
        }, t.UnwrappedTileID = Wu, t.ValidationError = it, t.ZoomHistory = Mn, t.addDynamicAttributes = Su, t.asyncAll = function(t2, e3, r2) {
          if (!t2.length)
            return r2(null, []);
          let n2 = t2.length;
          const i2 = new Array(t2.length);
          let s2 = null;
          t2.forEach((t3, a2) => {
            e3(t3, (t4, e4) => {
              t4 && (s2 = t4), i2[a2] = e4, 0 == --n2 && r2(s2, i2);
            });
          });
        }, t.bezier = n, t.bindAll = u, t.cacheEntryPossiblyAdded = function(t2) {
          F++, F > V && (t2.getActor().send("enforceCacheSizeLimit", P), F = 0);
        }, t.clamp = s, t.clearTileCache = function(t2) {
          const e3 = caches.delete(M);
          t2 && e3.catch(t2).then(() => t2());
        }, t.clipLine = ru, t.clone = function(t2) {
          var e3 = new la(16);
          return e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11], e3[12] = t2[12], e3[13] = t2[13], e3[14] = t2[14], e3[15] = t2[15], e3;
        }, t.clone$1 = p, t.collisionCircleLayout = Ho, t.config = I, t.create = function() {
          var t2 = new la(16);
          return la != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.createExpression = Vr, t.createFilter = Zr, t.createLayout = mi, t.createStyleLayer = function(t2) {
          return "custom" === t2.type ? new Du(t2) : new $u[t2.type](t2);
        }, t.dot = function(t2, e3) {
          return t2[0] * e3[0] + t2[1] * e3[1] + t2[2] * e3[2] + t2[3] * e3[3];
        }, t.ease = i, t.emitValidationErrors = wn, t.enforceCacheSizeLimit = function(t2) {
          E(), B && B.then((e3) => {
            e3.keys().then((r2) => {
              for (let n2 = 0; n2 < r2.length - t2; n2++)
                e3.delete(r2[n2]);
            });
          });
        }, t.evaluateSizeForFeature = function(t2, { uSize: e3, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
          return "source" === t2.kind ? n2 / Zl : "composite" === t2.kind ? Se(n2 / Zl, i2 / Zl, r2) : e3;
        }, t.evaluateSizeForZoom = function(t2, e3) {
          let r2 = 0, n2 = 0;
          if ("constant" === t2.kind)
            n2 = t2.layoutSize;
          else if ("source" !== t2.kind) {
            const { interpolationType: i2, minZoom: a2, maxZoom: o2 } = t2, l2 = i2 ? s(Ne.interpolationFactor(i2, e3, a2, o2), 0, 1) : 0;
            "camera" === t2.kind ? n2 = Se(t2.minSize, t2.maxSize, l2) : r2 = l2;
          }
          return { uSizeT: r2, uSize: n2 };
        }, t.evaluateVariableOffset = yu, t.evented = Zn, t.exported = k, t.exported$1 = T, t.extend = o, t.filterObject = h, t.getAnchorAlignment = ql, t.getAnchorJustification = mu, t.getArrayBuffer = Z, t.getImage = H, t.getJSON = function(t2, e3) {
          return K(o(t2, { type: "json" }), e3);
        }, t.getOverlapMode = Fu, t.getRTLTextPluginStatus = Gn, t.getReferrer = j, t.getVideo = function(t2, e3) {
          const r2 = window.document.createElement("video");
          r2.muted = true, r2.onloadstart = function() {
            e3(null, r2);
          };
          for (let e4 = 0; e4 < t2.length; e4++) {
            const n2 = window.document.createElement("source");
            G(t2[e4]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e4], r2.appendChild(n2);
          }
          return { cancel: () => {
          } };
        }, t.identity = ua, t.invert = function(t2, e3) {
          var r2 = e3[0], n2 = e3[1], i2 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c2 = e3[8], h2 = e3[9], p2 = e3[10], f2 = e3[11], d2 = e3[12], y2 = e3[13], m2 = e3[14], g2 = e3[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, k2 = c2 * y2 - h2 * d2, S2 = c2 * m2 - p2 * d2, z2 = c2 * g2 - f2 * d2, I2 = h2 * m2 - p2 * y2, M2 = h2 * g2 - f2 * y2, B2 = p2 * g2 - f2 * m2, C2 = x2 * B2 - v2 * M2 + b2 * I2 + w2 * z2 - _2 * S2 + A2 * k2;
          return C2 ? (t2[0] = (o2 * B2 - l2 * M2 + u2 * I2) * (C2 = 1 / C2), t2[1] = (i2 * M2 - n2 * B2 - s2 * I2) * C2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * C2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C2, t2[4] = (l2 * z2 - a2 * B2 - u2 * S2) * C2, t2[5] = (r2 * B2 - i2 * z2 + s2 * S2) * C2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * C2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * C2, t2[8] = (a2 * M2 - o2 * z2 + u2 * k2) * C2, t2[9] = (n2 * z2 - r2 * M2 - s2 * k2) * C2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * C2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C2, t2[12] = (o2 * S2 - a2 * I2 - l2 * k2) * C2, t2[13] = (r2 * I2 - n2 * S2 + i2 * k2) * C2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * C2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * C2, t2) : null;
        }, t.isImageBitmap = A, t.isSafari = _, t.keysDifference = function(t2, e3) {
          const r2 = [];
          for (const n2 in t2)
            n2 in e3 || r2.push(n2);
          return r2;
        }, t.lazyLoadRTLTextPlugin = function() {
          Xn.isLoading() || Xn.isLoaded() || "deferred" !== Gn() || Jn();
        }, t.makeRequest = K, t.mapObject = c, t.mercatorXfromLng = Ku, t.mercatorYfromLat = Zu, t.mercatorZfromAltitude = Gu, t.mul = pa, t.multiply = ca, t.nextPowerOfTwo = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
        }, t.number = Se, t.ortho = function(t2, e3, r2, n2, i2, s2, a2) {
          var o2 = 1 / (e3 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e3 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
        }, t.parseCacheControl = x, t.parseGlyphPBF = function(t2) {
          return new el(t2).readFields(kl, []);
        }, t.pbf = el, t.performSymbolLayout = function(e3, r2, n2, i2, s2, a2, o2) {
          e3.createArrays(), e3.tilePixelRatio = Rs / (512 * e3.overscaling), e3.compareText = {}, e3.iconsNeedLinear = false;
          const l2 = e3.layers[0].layout, u2 = e3.layers[0]._unevaluatedLayout._values, c2 = { layoutIconSize: u2["icon-size"].possiblyEvaluate(new Yn(e3.zoom + 1), o2), layoutTextSize: u2["text-size"].possiblyEvaluate(new Yn(e3.zoom + 1), o2), textMaxSize: u2["text-size"].possiblyEvaluate(new Yn(18)) };
          if ("composite" === e3.textSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e3.textSizeData;
            c2.compositeTextSizes = [u2["text-size"].possiblyEvaluate(new Yn(t2), o2), u2["text-size"].possiblyEvaluate(new Yn(r3), o2)];
          }
          if ("composite" === e3.iconSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e3.iconSizeData;
            c2.compositeIconSizes = [u2["icon-size"].possiblyEvaluate(new Yn(t2), o2), u2["icon-size"].possiblyEvaluate(new Yn(r3), o2)];
          }
          const h2 = l2.get("text-line-height") * tl, p2 = "viewport" !== l2.get("text-rotation-alignment") && "point" !== l2.get("symbol-placement"), f2 = l2.get("text-keep-upright"), y2 = l2.get("text-size");
          for (const a3 of e3.features) {
            const u3 = l2.get("text-font").evaluate(a3, {}, o2).join(","), m2 = y2.evaluate(a3, {}, o2), g2 = c2.layoutTextSize.evaluate(a3, {}, o2), x2 = c2.layoutIconSize.evaluate(a3, {}, o2), v2 = { horizontal: {}, vertical: void 0 }, b2 = a3.text;
            let w2, _2 = [0, 0];
            if (b2) {
              const i3 = b2.toString(), c3 = l2.get("text-letter-spacing").evaluate(a3, {}, o2) * tl, d2 = Pn(i3) ? c3 : 0, y3 = l2.get("text-anchor").evaluate(a3, {}, o2), x3 = l2.get("text-variable-anchor");
              if (!x3) {
                const t2 = l2.get("text-radial-offset").evaluate(a3, {}, o2);
                _2 = t2 ? yu(y3, [t2 * tl, du]) : l2.get("text-offset").evaluate(a3, {}, o2).map((t3) => t3 * tl);
              }
              let w3 = p2 ? "center" : l2.get("text-justify").evaluate(a3, {}, o2);
              const A3 = l2.get("symbol-placement"), k3 = "point" === A3 ? l2.get("text-max-width").evaluate(a3, {}, o2) * tl : 0, S2 = () => {
                e3.allowVerticalPlacement && Cn(i3) && (v2.vertical = El(b2, r2, n2, s2, u3, k3, h2, y3, "left", d2, _2, t.WritingMode.vertical, true, A3, g2, m2));
              };
              if (!p2 && x3) {
                const e4 = "auto" === w3 ? x3.map((t2) => mu(t2)) : [w3];
                let i4 = false;
                for (let a4 = 0; a4 < e4.length; a4++) {
                  const o3 = e4[a4];
                  if (!v2.horizontal[o3])
                    if (i4)
                      v2.horizontal[o3] = v2.horizontal[0];
                    else {
                      const e5 = El(b2, r2, n2, s2, u3, k3, h2, "center", o3, d2, _2, t.WritingMode.horizontal, false, A3, g2, m2);
                      e5 && (v2.horizontal[o3] = e5, i4 = 1 === e5.positionedLines.length);
                    }
                }
                S2();
              } else {
                "auto" === w3 && (w3 = mu(y3));
                const e4 = El(b2, r2, n2, s2, u3, k3, h2, y3, w3, d2, _2, t.WritingMode.horizontal, false, A3, g2, m2);
                e4 && (v2.horizontal[w3] = e4), S2(), Cn(i3) && p2 && f2 && (v2.vertical = El(b2, r2, n2, s2, u3, k3, h2, y3, w3, d2, _2, t.WritingMode.vertical, false, A3, g2, m2));
              }
            }
            let A2 = false;
            if (a3.icon && a3.icon.name) {
              const t2 = i2[a3.icon.name];
              t2 && (w2 = Nl(s2[a3.icon.name], l2.get("icon-offset").evaluate(a3, {}, o2), l2.get("icon-anchor").evaluate(a3, {}, o2)), A2 = !!t2.sdf, void 0 === e3.sdfIcons ? e3.sdfIcons = A2 : e3.sdfIcons !== A2 && d("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e3.pixelRatio || 0 !== l2.get("icon-rotate").constantOr(1)) && (e3.iconsNeedLinear = true));
            }
            const k2 = bu(v2.horizontal) || v2.vertical;
            e3.iconsInText = !!k2 && k2.iconsInText, (k2 || w2) && gu(e3, a3, v2, w2, i2, c2, g2, x2, _2, A2, o2);
          }
          a2 && e3.generateCollisionDebugBuffers();
        }, t.perspective = function(t2, e3, r2, n2, i2) {
          var s2, a2 = 1 / Math.tan(e3 / 2);
          return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
        }, t.pick = function(t2, e3) {
          const r2 = {};
          for (let n2 = 0; n2 < e3.length; n2++) {
            const i2 = e3[n2];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.plugin = Xn, t.pointGeometry = S, t.polygonIntersectsPolygon = Zs, t.potpack = Il, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = kn, t.registerForPluginStateChange = function(t2) {
          return t2({ pluginStatus: qn, pluginURL: jn }), Zn.on("pluginStateChange", t2), t2;
        }, t.renderColorRamp = _a2, t.rotateX = function(t2, e3, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e3[4], a2 = e3[5], o2 = e3[6], l2 = e3[7], u2 = e3[8], c2 = e3[9], h2 = e3[10], p2 = e3[11];
          return e3 !== t2 && (t2[0] = e3[0], t2[1] = e3[1], t2[2] = e3[2], t2[3] = e3[3], t2[12] = e3[12], t2[13] = e3[13], t2[14] = e3[14], t2[15] = e3[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
        }, t.rotateZ = function(t2, e3, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e3[0], a2 = e3[1], o2 = e3[2], l2 = e3[3], u2 = e3[4], c2 = e3[5], h2 = e3[6], p2 = e3[7];
          return e3 !== t2 && (t2[8] = e3[8], t2[9] = e3[9], t2[10] = e3[10], t2[11] = e3[11], t2[12] = e3[12], t2[13] = e3[13], t2[14] = e3[14], t2[15] = e3[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
        }, t.scale = function(t2, e3, r2) {
          var n2 = r2[0], i2 = r2[1], s2 = r2[2];
          return t2[0] = e3[0] * n2, t2[1] = e3[1] * n2, t2[2] = e3[2] * n2, t2[3] = e3[3] * n2, t2[4] = e3[4] * i2, t2[5] = e3[5] * i2, t2[6] = e3[6] * i2, t2[7] = e3[7] * i2, t2[8] = e3[8] * s2, t2[9] = e3[9] * s2, t2[10] = e3[10] * s2, t2[11] = e3[11] * s2, t2[12] = e3[12], t2[13] = e3[13], t2[14] = e3[14], t2[15] = e3[15], t2;
        }, t.scale$1 = function(t2, e3, r2) {
          return t2[0] = e3[0] * r2, t2[1] = e3[1] * r2, t2[2] = e3[2] * r2, t2[3] = e3[3] * r2, t2;
        }, t.setCacheLimits = function(t2, e3) {
          P = t2, V = e3;
        }, t.setRTLTextPlugin = function(t2, e3, r2 = false) {
          if (qn === $n || qn === Rn || qn === Un)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          jn = k.resolveURL(t2), qn = $n, On = e3, Kn(), r2 || Jn();
        }, t.spec = nt, t.sphericalToCartesian = function([t2, e3, r2]) {
          return e3 += 90, e3 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e3) * Math.sin(r2), y: t2 * Math.sin(e3) * Math.sin(r2), z: t2 * Math.cos(r2) };
        }, t.toEvaluationFeature = js, t.transformMat4 = fa, t.translate = function(t2, e3, r2) {
          var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
          return e3 === t2 ? (t2[12] = e3[0] * y2 + e3[4] * m2 + e3[8] * g2 + e3[12], t2[13] = e3[1] * y2 + e3[5] * m2 + e3[9] * g2 + e3[13], t2[14] = e3[2] * y2 + e3[6] * m2 + e3[10] * g2 + e3[14], t2[15] = e3[3] * y2 + e3[7] * m2 + e3[11] * g2 + e3[15]) : (i2 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h2 = e3[8], p2 = e3[9], f2 = e3[10], d2 = e3[11], t2[0] = n2 = e3[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e3[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e3[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e3[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e3[15]), t2;
        }, t.triggerPluginCompletionEvent = Nn, t.unicodeBlockLookup = Bn, t.uniqueId = function() {
          return l++;
        }, t.validateCustomStyleLayer = function(t2) {
          const e3 = [], r2 = t2.id;
          return void 0 === r2 && e3.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e3.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e3.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e3;
        }, t.validateLight = xn, t.validateStyle = gn, t.vectorTile = fo, t.warnOnce = d, t.wrap = a;
      });
      define2(["./shared"], function(e2) {
        "use strict";
        function t(e3) {
          const o2 = typeof e3;
          if ("number" === o2 || "boolean" === o2 || "string" === o2 || null == e3)
            return JSON.stringify(e3);
          if (Array.isArray(e3)) {
            let o3 = "[";
            for (const i3 of e3)
              o3 += `${t(i3)},`;
            return `${o3}]`;
          }
          const i2 = Object.keys(e3).sort();
          let r2 = "{";
          for (let o3 = 0; o3 < i2.length; o3++)
            r2 += `${JSON.stringify(i2[o3])}:${t(e3[i2[o3]])},`;
          return `${r2}}`;
        }
        function o(o2) {
          let i2 = "";
          for (const r2 of e2.refProperties)
            i2 += `/${t(o2[r2])}`;
          return i2;
        }
        class i {
          constructor(e3) {
            this.keyCache = {}, e3 && this.replace(e3);
          }
          replace(e3) {
            this._layerConfigs = {}, this._layers = {}, this.update(e3, []);
          }
          update(t2, i2) {
            for (const o2 of t2) {
              this._layerConfigs[o2.id] = o2;
              const t3 = this._layers[o2.id] = e2.createStyleLayer(o2);
              t3._featureFilter = e2.createFilter(t3.filter), this.keyCache[o2.id] && delete this.keyCache[o2.id];
            }
            for (const e3 of i2)
              delete this.keyCache[e3], delete this._layerConfigs[e3], delete this._layers[e3];
            this.familiesBySource = {};
            const r2 = function(e3, t3) {
              const i3 = {};
              for (let r4 = 0; r4 < e3.length; r4++) {
                const n2 = t3 && t3[e3[r4].id] || o(e3[r4]);
                t3 && (t3[e3[r4].id] = n2);
                let s2 = i3[n2];
                s2 || (s2 = i3[n2] = []), s2.push(e3[r4]);
              }
              const r3 = [];
              for (const e4 in i3)
                r3.push(i3[e4]);
              return r3;
            }(Object.values(this._layerConfigs), this.keyCache);
            for (const e3 of r2) {
              const t3 = e3.map((e4) => this._layers[e4.id]), o2 = t3[0];
              if ("none" === o2.visibility)
                continue;
              const i3 = o2.source || "";
              let r3 = this.familiesBySource[i3];
              r3 || (r3 = this.familiesBySource[i3] = {});
              const n2 = o2.sourceLayer || "_geojsonTileLayer";
              let s2 = r3[n2];
              s2 || (s2 = r3[n2] = []), s2.push(t3);
            }
          }
        }
        class r {
          constructor(t2) {
            const o2 = {}, i2 = [];
            for (const e3 in t2) {
              const r3 = t2[e3], n3 = o2[e3] = {};
              for (const e4 in r3) {
                const t3 = r3[+e4];
                if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height)
                  continue;
                const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                i2.push(o3), n3[e4] = { rect: o3, metrics: t3.metrics };
              }
            }
            const { w: r2, h: n2 } = e2.potpack(i2), s2 = new e2.AlphaImage({ width: r2 || 1, height: n2 || 1 });
            for (const i3 in t2) {
              const r3 = t2[i3];
              for (const t3 in r3) {
                const n3 = r3[+t3];
                if (!n3 || 0 === n3.bitmap.width || 0 === n3.bitmap.height)
                  continue;
                const a2 = o2[i3][t3].rect;
                e2.AlphaImage.copy(n3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, n3.bitmap);
              }
            }
            this.image = s2, this.positions = o2;
          }
        }
        e2.register("GlyphAtlas", r);
        class n {
          constructor(t2) {
            this.tileID = new e2.OverscaledTileID(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId;
          }
          parse(t2, o2, i2, n2, a2) {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new e2.CollisionBoxArray();
            const l2 = new e2.DictionaryCoder(Object.keys(t2.layers).sort()), c2 = new e2.FeatureIndex(this.tileID, this.promoteId);
            c2.bucketLayerIDs = [];
            const u2 = {}, h2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i2 }, p2 = o2.familiesBySource[this.source];
            for (const o3 in p2) {
              const r2 = t2.layers[o3];
              if (!r2)
                continue;
              1 === r2.version && e2.warnOnce(`Vector tile source "${this.source}" layer "${o3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const n3 = l2.encode(o3), a3 = [];
              for (let e3 = 0; e3 < r2.length; e3++) {
                const t3 = r2.feature(e3), i3 = c2.getId(t3, o3);
                a3.push({ feature: t3, id: i3, index: e3, sourceLayerIndex: n3 });
              }
              for (const e3 of p2[o3]) {
                const t3 = e3[0];
                t3.minzoom && this.zoom < Math.floor(t3.minzoom) || t3.maxzoom && this.zoom >= t3.maxzoom || "none" !== t3.visibility && (s(e3, this.zoom, i2), (u2[t3.id] = t3.createBucket({ index: c2.bucketLayerIDs.length, layers: e3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(a3, h2, this.tileID.canonical), c2.bucketLayerIDs.push(e3.map((e4) => e4.id)));
              }
            }
            let f2, d2, g2, m2;
            const y2 = e2.mapObject(h2.glyphDependencies, (e3) => Object.keys(e3).map(Number));
            Object.keys(y2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: y2 }, (e3, t3) => {
              f2 || (f2 = e3, d2 = t3, w2.call(this));
            }) : d2 = {};
            const v2 = Object.keys(h2.iconDependencies);
            v2.length ? n2.send("getImages", { icons: v2, source: this.source, tileID: this.tileID, type: "icons" }, (e3, t3) => {
              f2 || (f2 = e3, g2 = t3, w2.call(this));
            }) : g2 = {};
            const x2 = Object.keys(h2.patternDependencies);
            function w2() {
              if (f2)
                return a2(f2);
              if (d2 && g2 && m2) {
                const t3 = new r(d2), o3 = new e2.ImageAtlas(g2, m2);
                for (const r2 in u2) {
                  const n3 = u2[r2];
                  n3 instanceof e2.SymbolBucket ? (s(n3.layers, this.zoom, i2), e2.performSymbolLayout(n3, d2, t3.positions, g2, o3.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : n3.hasPattern && (n3 instanceof e2.LineBucket || n3 instanceof e2.FillBucket || n3 instanceof e2.FillExtrusionBucket) && (s(n3.layers, this.zoom, i2), n3.addFeatures(h2, this.tileID.canonical, o3.patternPositions));
                }
                this.status = "done", a2(null, { buckets: Object.values(u2).filter((e3) => !e3.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, imageAtlas: o3, glyphMap: this.returnDependencies ? d2 : null, iconMap: this.returnDependencies ? g2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
              }
            }
            x2.length ? n2.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "patterns" }, (e3, t3) => {
              f2 || (f2 = e3, m2 = t3, w2.call(this));
            }) : m2 = {}, w2.call(this);
          }
        }
        function s(t2, o2, i2) {
          const r2 = new e2.EvaluationParameters(o2);
          for (const e3 of t2)
            e3.recalculate(r2, i2);
        }
        function a(t2, o2) {
          const i2 = e2.getArrayBuffer(t2.request, (t3, i3, r2, n2) => {
            t3 ? o2(t3) : i3 && o2(null, { vectorTile: new e2.vectorTile.VectorTile(new e2.pbf(i3)), rawData: i3, cacheControl: r2, expires: n2 });
          });
          return () => {
            i2.cancel(), o2();
          };
        }
        class l {
          constructor(e3, t2, o2, i2) {
            this.actor = e3, this.layerIndex = t2, this.availableImages = o2, this.loadVectorData = i2 || a, this.loading = {}, this.loaded = {};
          }
          loadTile(t2, o2) {
            const i2 = t2.uid;
            this.loading || (this.loading = {});
            const r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e2.RequestPerformance(t2.request), s2 = this.loading[i2] = new n(t2);
            s2.abort = this.loadVectorData(t2, (t3, n2) => {
              if (delete this.loading[i2], t3 || !n2)
                return s2.status = "done", this.loaded[i2] = s2, o2(t3);
              const a2 = n2.rawData, l2 = {};
              n2.expires && (l2.expires = n2.expires), n2.cacheControl && (l2.cacheControl = n2.cacheControl);
              const c2 = {};
              if (r2) {
                const e3 = r2.finish();
                e3 && (c2.resourceTiming = JSON.parse(JSON.stringify(e3)));
              }
              s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, i3) => {
                if (t4 || !i3)
                  return o2(t4);
                o2(null, e2.extend({ rawTileData: a2.slice(0) }, i3, l2, c2));
              }), this.loaded = this.loaded || {}, this.loaded[i2] = s2;
            });
          }
          reloadTile(e3, t2) {
            const o2 = this.loaded, i2 = e3.uid, r2 = this;
            if (o2 && o2[i2]) {
              const n2 = o2[i2];
              n2.showCollisionBoxes = e3.showCollisionBoxes;
              const s2 = (e4, o3) => {
                const i3 = n2.reloadCallback;
                i3 && (delete n2.reloadCallback, n2.parse(n2.vectorTile, r2.layerIndex, this.availableImages, r2.actor, i3)), t2(e4, o3);
              };
              "parsing" === n2.status ? n2.reloadCallback = s2 : "done" === n2.status && (n2.vectorTile ? n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
            }
          }
          abortTile(e3, t2) {
            const o2 = this.loading, i2 = e3.uid;
            o2 && o2[i2] && o2[i2].abort && (o2[i2].abort(), delete o2[i2]), t2();
          }
          removeTile(e3, t2) {
            const o2 = this.loaded, i2 = e3.uid;
            o2 && o2[i2] && delete o2[i2], t2();
          }
        }
        class c {
          constructor() {
            this.loaded = {};
          }
          loadTile(t2, o2) {
            const { uid: i2, encoding: r2, rawImageData: n2 } = t2, s2 = e2.isImageBitmap(n2) ? this.getImageData(n2) : n2, a2 = new e2.DEMData(i2, s2, r2);
            this.loaded = this.loaded || {}, this.loaded[i2] = a2, o2(null, a2);
          }
          getImageData(t2) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
            const o2 = this.offscreenCanvasContext.getImageData(-1, -1, t2.width + 2, t2.height + 2);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e2.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
          }
          removeTile(e3) {
            const t2 = this.loaded, o2 = e3.uid;
            t2 && t2[o2] && delete t2[o2];
          }
        }
        var u = function e3(t2, o2) {
          var i2, r2 = t2 && t2.type;
          if ("FeatureCollection" === r2)
            for (i2 = 0; i2 < t2.features.length; i2++)
              e3(t2.features[i2], o2);
          else if ("GeometryCollection" === r2)
            for (i2 = 0; i2 < t2.geometries.length; i2++)
              e3(t2.geometries[i2], o2);
          else if ("Feature" === r2)
            e3(t2.geometry, o2);
          else if ("Polygon" === r2)
            h(t2.coordinates, o2);
          else if ("MultiPolygon" === r2)
            for (i2 = 0; i2 < t2.coordinates.length; i2++)
              h(t2.coordinates[i2], o2);
          return t2;
        };
        function h(e3, t2) {
          if (0 !== e3.length) {
            p(e3[0], t2);
            for (var o2 = 1; o2 < e3.length; o2++)
              p(e3[o2], !t2);
          }
        }
        function p(e3, t2) {
          for (var o2 = 0, i2 = 0, r2 = 0, n2 = e3.length, s2 = n2 - 1; r2 < n2; s2 = r2++) {
            var a2 = (e3[r2][0] - e3[s2][0]) * (e3[s2][1] + e3[r2][1]), l2 = o2 + a2;
            i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
          }
          o2 + i2 >= 0 != !!t2 && e3.reverse();
        }
        const f = e2.vectorTile.VectorTileFeature.prototype.toGeoJSON;
        class d {
          constructor(t2) {
            this._feature = t2, this.extent = e2.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
          }
          loadGeometry() {
            if (1 === this._feature.type) {
              const t2 = [];
              for (const o2 of this._feature.geometry)
                t2.push([new e2.pointGeometry(o2[0], o2[1])]);
              return t2;
            }
            {
              const t2 = [];
              for (const o2 of this._feature.geometry) {
                const i2 = [];
                for (const t3 of o2)
                  i2.push(new e2.pointGeometry(t3[0], t3[1]));
                t2.push(i2);
              }
              return t2;
            }
          }
          toGeoJSON(e3, t2, o2) {
            return f.call(this, e3, t2, o2);
          }
        }
        class g {
          constructor(t2) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e2.EXTENT, this.length = t2.length, this._features = t2;
          }
          feature(e3) {
            return new d(this._features[e3]);
          }
        }
        var m = { exports: {} }, y = e2.pointGeometry, v = e2.vectorTile.VectorTileFeature, x = w;
        function w(e3, t2) {
          this.options = t2 || {}, this.features = e3, this.length = e3.length;
        }
        function S(e3, t2) {
          this.id = "number" == typeof e3.id ? e3.id : void 0, this.type = e3.type, this.rawGeometry = 1 === e3.type ? [e3.geometry] : e3.geometry, this.properties = e3.tags, this.extent = t2 || 4096;
        }
        w.prototype.feature = function(e3) {
          return new S(this.features[e3], this.options.extent);
        }, S.prototype.loadGeometry = function() {
          var e3 = this.rawGeometry;
          this.geometry = [];
          for (var t2 = 0; t2 < e3.length; t2++) {
            for (var o2 = e3[t2], i2 = [], r2 = 0; r2 < o2.length; r2++)
              i2.push(new y(o2[r2][0], o2[r2][1]));
            this.geometry.push(i2);
          }
          return this.geometry;
        }, S.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e3 = this.geometry, t2 = 1 / 0, o2 = -1 / 0, i2 = 1 / 0, r2 = -1 / 0, n2 = 0; n2 < e3.length; n2++)
            for (var s2 = e3[n2], a2 = 0; a2 < s2.length; a2++) {
              var l2 = s2[a2];
              t2 = Math.min(t2, l2.x), o2 = Math.max(o2, l2.x), i2 = Math.min(i2, l2.y), r2 = Math.max(r2, l2.y);
            }
          return [t2, i2, o2, r2];
        }, S.prototype.toGeoJSON = v.prototype.toGeoJSON;
        var I = e2.pbf, M = x;
        function b(e3) {
          var t2 = new I();
          return function(e4, t3) {
            for (var o2 in e4.layers)
              t3.writeMessage(3, k, e4.layers[o2]);
          }(e3, t2), t2.finish();
        }
        function k(e3, t2) {
          var o2;
          t2.writeVarintField(15, e3.version || 1), t2.writeStringField(1, e3.name || ""), t2.writeVarintField(5, e3.extent || 4096);
          var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (o2 = 0; o2 < e3.length; o2++)
            i2.feature = e3.feature(o2), t2.writeMessage(2, _, i2);
          var r2 = i2.keys;
          for (o2 = 0; o2 < r2.length; o2++)
            t2.writeStringField(3, r2[o2]);
          var n2 = i2.values;
          for (o2 = 0; o2 < n2.length; o2++)
            t2.writeMessage(4, L, n2[o2]);
        }
        function _(e3, t2) {
          var o2 = e3.feature;
          void 0 !== o2.id && t2.writeVarintField(1, o2.id), t2.writeMessage(2, P, e3), t2.writeVarintField(3, o2.type), t2.writeMessage(4, D, o2);
        }
        function P(e3, t2) {
          var o2 = e3.feature, i2 = e3.keys, r2 = e3.values, n2 = e3.keycache, s2 = e3.valuecache;
          for (var a2 in o2.properties) {
            var l2 = o2.properties[a2], c2 = n2[a2];
            if (null !== l2) {
              void 0 === c2 && (i2.push(a2), n2[a2] = c2 = i2.length - 1), t2.writeVarint(c2);
              var u2 = typeof l2;
              "string" !== u2 && "boolean" !== u2 && "number" !== u2 && (l2 = JSON.stringify(l2));
              var h2 = u2 + ":" + l2, p2 = s2[h2];
              void 0 === p2 && (r2.push(l2), s2[h2] = p2 = r2.length - 1), t2.writeVarint(p2);
            }
          }
        }
        function T(e3, t2) {
          return (t2 << 3) + (7 & e3);
        }
        function C(e3) {
          return e3 << 1 ^ e3 >> 31;
        }
        function D(e3, t2) {
          for (var o2 = e3.loadGeometry(), i2 = e3.type, r2 = 0, n2 = 0, s2 = o2.length, a2 = 0; a2 < s2; a2++) {
            var l2 = o2[a2], c2 = 1;
            1 === i2 && (c2 = l2.length), t2.writeVarint(T(1, c2));
            for (var u2 = 3 === i2 ? l2.length - 1 : l2.length, h2 = 0; h2 < u2; h2++) {
              1 === h2 && 1 !== i2 && t2.writeVarint(T(2, u2 - 1));
              var p2 = l2[h2].x - r2, f2 = l2[h2].y - n2;
              t2.writeVarint(C(p2)), t2.writeVarint(C(f2)), r2 += p2, n2 += f2;
            }
            3 === i2 && t2.writeVarint(T(7, 1));
          }
        }
        function L(e3, t2) {
          var o2 = typeof e3;
          "string" === o2 ? t2.writeStringField(1, e3) : "boolean" === o2 ? t2.writeBooleanField(7, e3) : "number" === o2 && (e3 % 1 != 0 ? t2.writeDoubleField(3, e3) : e3 < 0 ? t2.writeSVarintField(6, e3) : t2.writeVarintField(5, e3));
        }
        m.exports = b, m.exports.fromVectorTileJs = b, m.exports.fromGeojsonVt = function(e3, t2) {
          t2 = t2 || {};
          var o2 = {};
          for (var i2 in e3)
            o2[i2] = new M(e3[i2].features, t2), o2[i2].name = i2, o2[i2].version = t2.version, o2[i2].extent = t2.extent;
          return b({ layers: o2 });
        }, m.exports.GeoJSONWrapper = M;
        var z = m.exports;
        function O(e3, t2, o2, i2, r2, n2) {
          if (r2 - i2 <= o2)
            return;
          const s2 = i2 + r2 >> 1;
          E(e3, t2, s2, i2, r2, n2 % 2), O(e3, t2, o2, i2, s2 - 1, n2 + 1), O(e3, t2, o2, s2 + 1, r2, n2 + 1);
        }
        function E(e3, t2, o2, i2, r2, n2) {
          for (; r2 > i2; ) {
            if (r2 - i2 > 600) {
              const s3 = r2 - i2 + 1, a3 = o2 - i2 + 1, l3 = Math.log(s3), c2 = 0.5 * Math.exp(2 * l3 / 3), u2 = 0.5 * Math.sqrt(l3 * c2 * (s3 - c2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
              E(e3, t2, o2, Math.max(i2, Math.floor(o2 - a3 * c2 / s3 + u2)), Math.min(r2, Math.floor(o2 + (s3 - a3) * c2 / s3 + u2)), n2);
            }
            const s2 = t2[2 * o2 + n2];
            let a2 = i2, l2 = r2;
            for (F(e3, t2, i2, o2), t2[2 * r2 + n2] > s2 && F(e3, t2, i2, r2); a2 < l2; ) {
              for (F(e3, t2, a2, l2), a2++, l2--; t2[2 * a2 + n2] < s2; )
                a2++;
              for (; t2[2 * l2 + n2] > s2; )
                l2--;
            }
            t2[2 * i2 + n2] === s2 ? F(e3, t2, i2, l2) : (l2++, F(e3, t2, l2, r2)), l2 <= o2 && (i2 = l2 + 1), o2 <= l2 && (r2 = l2 - 1);
          }
        }
        function F(e3, t2, o2, i2) {
          N(e3, o2, i2), N(t2, 2 * o2, 2 * i2), N(t2, 2 * o2 + 1, 2 * i2 + 1);
        }
        function N(e3, t2, o2) {
          const i2 = e3[t2];
          e3[t2] = e3[o2], e3[o2] = i2;
        }
        function A(e3, t2, o2, i2) {
          const r2 = e3 - o2, n2 = t2 - i2;
          return r2 * r2 + n2 * n2;
        }
        const G = (e3) => e3[0], J = (e3) => e3[1];
        class Z {
          constructor(e3, t2 = G, o2 = J, i2 = 64, r2 = Float64Array) {
            this.nodeSize = i2, this.points = e3;
            const n2 = e3.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new n2(e3.length), a2 = this.coords = new r2(2 * e3.length);
            for (let i3 = 0; i3 < e3.length; i3++)
              s2[i3] = i3, a2[2 * i3] = t2(e3[i3]), a2[2 * i3 + 1] = o2(e3[i3]);
            O(s2, a2, i2, 0, s2.length - 1, 0);
          }
          range(e3, t2, o2, i2) {
            return function(e4, t3, o3, i3, r2, n2, s2) {
              const a2 = [0, e4.length - 1, 0], l2 = [];
              let c2, u2;
              for (; a2.length; ) {
                const h2 = a2.pop(), p2 = a2.pop(), f2 = a2.pop();
                if (p2 - f2 <= s2) {
                  for (let s3 = f2; s3 <= p2; s3++)
                    c2 = t3[2 * s3], u2 = t3[2 * s3 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e4[s3]);
                  continue;
                }
                const d2 = Math.floor((f2 + p2) / 2);
                c2 = t3[2 * d2], u2 = t3[2 * d2 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e4[d2]);
                const g2 = (h2 + 1) % 2;
                (0 === h2 ? o3 <= c2 : i3 <= u2) && (a2.push(f2), a2.push(d2 - 1), a2.push(g2)), (0 === h2 ? r2 >= c2 : n2 >= u2) && (a2.push(d2 + 1), a2.push(p2), a2.push(g2));
              }
              return l2;
            }(this.ids, this.coords, e3, t2, o2, i2, this.nodeSize);
          }
          within(e3, t2, o2) {
            return function(e4, t3, o3, i2, r2, n2) {
              const s2 = [0, e4.length - 1, 0], a2 = [], l2 = r2 * r2;
              for (; s2.length; ) {
                const c2 = s2.pop(), u2 = s2.pop(), h2 = s2.pop();
                if (u2 - h2 <= n2) {
                  for (let r3 = h2; r3 <= u2; r3++)
                    A(t3[2 * r3], t3[2 * r3 + 1], o3, i2) <= l2 && a2.push(e4[r3]);
                  continue;
                }
                const p2 = Math.floor((h2 + u2) / 2), f2 = t3[2 * p2], d2 = t3[2 * p2 + 1];
                A(f2, d2, o3, i2) <= l2 && a2.push(e4[p2]);
                const g2 = (c2 + 1) % 2;
                (0 === c2 ? o3 - r2 <= f2 : i2 - r2 <= d2) && (s2.push(h2), s2.push(p2 - 1), s2.push(g2)), (0 === c2 ? o3 + r2 >= f2 : i2 + r2 >= d2) && (s2.push(p2 + 1), s2.push(u2), s2.push(g2));
              }
              return a2;
            }(this.ids, this.coords, e3, t2, o2, this.nodeSize);
          }
        }
        const B = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e3) => e3 }, j = Math.fround || (Y = new Float32Array(1), (e3) => (Y[0] = +e3, Y[0]));
        var Y;
        class V {
          constructor(e3) {
            this.options = K(Object.create(B), e3), this.trees = new Array(this.options.maxZoom + 1);
          }
          load(e3) {
            const { log: t2, minZoom: o2, maxZoom: i2, nodeSize: r2 } = this.options;
            t2 && console.time("total time");
            const n2 = `prepare ${e3.length} points`;
            t2 && console.time(n2), this.points = e3;
            let s2 = [];
            for (let t3 = 0; t3 < e3.length; t3++)
              e3[t3].geometry && s2.push(W(e3[t3], t3));
            this.trees[i2 + 1] = new Z(s2, Q, ee, r2, Float32Array), t2 && console.timeEnd(n2);
            for (let e4 = i2; e4 >= o2; e4--) {
              const o3 = +Date.now();
              s2 = this._cluster(s2, e4), this.trees[e4] = new Z(s2, Q, ee, r2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e4, s2.length, +Date.now() - o3);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e3, t2) {
            let o2 = ((e3[0] + 180) % 360 + 360) % 360 - 180;
            const i2 = Math.max(-90, Math.min(90, e3[1]));
            let r2 = 180 === e3[2] ? 180 : ((e3[2] + 180) % 360 + 360) % 360 - 180;
            const n2 = Math.max(-90, Math.min(90, e3[3]));
            if (e3[2] - e3[0] >= 360)
              o2 = -180, r2 = 180;
            else if (o2 > r2) {
              const e4 = this.getClusters([o2, i2, 180, n2], t2), s3 = this.getClusters([-180, i2, r2, n2], t2);
              return e4.concat(s3);
            }
            const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range(q(o2), U(n2), q(r2), U(i2)), l2 = [];
            for (const e4 of a2) {
              const t3 = s2.points[e4];
              l2.push(t3.numPoints ? R(t3) : this.points[t3.index]);
            }
            return l2;
          }
          getChildren(e3) {
            const t2 = this._getOriginId(e3), o2 = this._getOriginZoom(e3), i2 = "No cluster with the specified id.", r2 = this.trees[o2];
            if (!r2)
              throw new Error(i2);
            const n2 = r2.points[t2];
            if (!n2)
              throw new Error(i2);
            const s2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = r2.within(n2.x, n2.y, s2), l2 = [];
            for (const t3 of a2) {
              const o3 = r2.points[t3];
              o3.parentId === e3 && l2.push(o3.numPoints ? R(o3) : this.points[o3.index]);
            }
            if (0 === l2.length)
              throw new Error(i2);
            return l2;
          }
          getLeaves(e3, t2, o2) {
            const i2 = [];
            return this._appendLeaves(i2, e3, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
          }
          getTile(e3, t2, o2) {
            const i2 = this.trees[this._limitZoom(e3)], r2 = Math.pow(2, e3), { extent: n2, radius: s2 } = this.options, a2 = s2 / n2, l2 = (o2 - a2) / r2, c2 = (o2 + 1 + a2) / r2, u2 = { features: [] };
            return this._addTileFeatures(i2.range((t2 - a2) / r2, l2, (t2 + 1 + a2) / r2, c2), i2.points, t2, o2, r2, u2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / r2, l2, 1, c2), i2.points, r2, o2, r2, u2), t2 === r2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / r2, c2), i2.points, -1, o2, r2, u2), u2.features.length ? u2 : null;
          }
          getClusterExpansionZoom(e3) {
            let t2 = this._getOriginZoom(e3) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              const o2 = this.getChildren(e3);
              if (t2++, 1 !== o2.length)
                break;
              e3 = o2[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e3, t2, o2, i2, r2) {
            const n2 = this.getChildren(t2);
            for (const t3 of n2) {
              const n3 = t3.properties;
              if (n3 && n3.cluster ? r2 + n3.point_count <= i2 ? r2 += n3.point_count : r2 = this._appendLeaves(e3, n3.cluster_id, o2, i2, r2) : r2 < i2 ? r2++ : e3.push(t3), e3.length === o2)
                break;
            }
            return r2;
          }
          _addTileFeatures(e3, t2, o2, i2, r2, n2) {
            for (const s2 of e3) {
              const e4 = t2[s2], a2 = e4.numPoints;
              let l2, c2, u2;
              if (a2)
                l2 = $(e4), c2 = e4.x, u2 = e4.y;
              else {
                const t3 = this.points[e4.index];
                l2 = t3.properties, c2 = q(t3.geometry.coordinates[0]), u2 = U(t3.geometry.coordinates[1]);
              }
              const h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * r2 - o2)), Math.round(this.options.extent * (u2 * r2 - i2))]], tags: l2 };
              let p2;
              a2 ? p2 = e4.id : this.options.generateId ? p2 = e4.index : this.points[e4.index].id && (p2 = this.points[e4.index].id), void 0 !== p2 && (h2.id = p2), n2.features.push(h2);
            }
          }
          _limitZoom(e3) {
            return Math.max(this.options.minZoom, Math.min(+e3, this.options.maxZoom + 1));
          }
          _cluster(e3, t2) {
            const o2 = [], { radius: i2, extent: r2, reduce: n2, minPoints: s2 } = this.options, a2 = i2 / (r2 * Math.pow(2, t2));
            for (let i3 = 0; i3 < e3.length; i3++) {
              const r3 = e3[i3];
              if (r3.zoom <= t2)
                continue;
              r3.zoom = t2;
              const l2 = this.trees[t2 + 1], c2 = l2.within(r3.x, r3.y, a2), u2 = r3.numPoints || 1;
              let h2 = u2;
              for (const e4 of c2) {
                const o3 = l2.points[e4];
                o3.zoom > t2 && (h2 += o3.numPoints || 1);
              }
              if (h2 > u2 && h2 >= s2) {
                let e4 = r3.x * u2, s3 = r3.y * u2, a3 = n2 && u2 > 1 ? this._map(r3, true) : null;
                const p2 = (i3 << 5) + (t2 + 1) + this.points.length;
                for (const o3 of c2) {
                  const i4 = l2.points[o3];
                  if (i4.zoom <= t2)
                    continue;
                  i4.zoom = t2;
                  const c3 = i4.numPoints || 1;
                  e4 += i4.x * c3, s3 += i4.y * c3, i4.parentId = p2, n2 && (a3 || (a3 = this._map(r3, true)), n2(a3, this._map(i4)));
                }
                r3.parentId = p2, o2.push(X(e4 / h2, s3 / h2, p2, h2, a3));
              } else if (o2.push(r3), h2 > 1)
                for (const e4 of c2) {
                  const i4 = l2.points[e4];
                  i4.zoom <= t2 || (i4.zoom = t2, o2.push(i4));
                }
            }
            return o2;
          }
          _getOriginId(e3) {
            return e3 - this.points.length >> 5;
          }
          _getOriginZoom(e3) {
            return (e3 - this.points.length) % 32;
          }
          _map(e3, t2) {
            if (e3.numPoints)
              return t2 ? K({}, e3.properties) : e3.properties;
            const o2 = this.points[e3.index].properties, i2 = this.options.map(o2);
            return t2 && i2 === o2 ? K({}, i2) : i2;
          }
        }
        function X(e3, t2, o2, i2, r2) {
          return { x: j(e3), y: j(t2), zoom: 1 / 0, id: o2, parentId: -1, numPoints: i2, properties: r2 };
        }
        function W(e3, t2) {
          const [o2, i2] = e3.geometry.coordinates;
          return { x: j(q(o2)), y: j(U(i2)), zoom: 1 / 0, index: t2, parentId: -1 };
        }
        function R(e3) {
          return { type: "Feature", id: e3.id, properties: $(e3), geometry: { type: "Point", coordinates: [(t2 = e3.x, 360 * (t2 - 0.5)), H(e3.y)] } };
          var t2;
        }
        function $(e3) {
          const t2 = e3.numPoints, o2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
          return K(K({}, e3.properties), { cluster: true, cluster_id: e3.id, point_count: t2, point_count_abbreviated: o2 });
        }
        function q(e3) {
          return e3 / 360 + 0.5;
        }
        function U(e3) {
          const t2 = Math.sin(e3 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function H(e3) {
          const t2 = (180 - 360 * e3) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function K(e3, t2) {
          for (const o2 in t2)
            e3[o2] = t2[o2];
          return e3;
        }
        function Q(e3) {
          return e3.x;
        }
        function ee(e3) {
          return e3.y;
        }
        function te(e3, t2, o2, i2) {
          for (var r2, n2 = i2, s2 = o2 - t2 >> 1, a2 = o2 - t2, l2 = e3[t2], c2 = e3[t2 + 1], u2 = e3[o2], h2 = e3[o2 + 1], p2 = t2 + 3; p2 < o2; p2 += 3) {
            var f2 = oe(e3[p2], e3[p2 + 1], l2, c2, u2, h2);
            if (f2 > n2)
              r2 = p2, n2 = f2;
            else if (f2 === n2) {
              var d2 = Math.abs(p2 - s2);
              d2 < a2 && (r2 = p2, a2 = d2);
            }
          }
          n2 > i2 && (r2 - t2 > 3 && te(e3, t2, r2, i2), e3[r2 + 2] = n2, o2 - r2 > 3 && te(e3, r2, o2, i2));
        }
        function oe(e3, t2, o2, i2, r2, n2) {
          var s2 = r2 - o2, a2 = n2 - i2;
          if (0 !== s2 || 0 !== a2) {
            var l2 = ((e3 - o2) * s2 + (t2 - i2) * a2) / (s2 * s2 + a2 * a2);
            l2 > 1 ? (o2 = r2, i2 = n2) : l2 > 0 && (o2 += s2 * l2, i2 += a2 * l2);
          }
          return (s2 = e3 - o2) * s2 + (a2 = t2 - i2) * a2;
        }
        function ie(e3, t2, o2, i2) {
          var r2 = { id: void 0 === e3 ? null : e3, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e4) {
            var t3 = e4.geometry, o3 = e4.type;
            if ("Point" === o3 || "MultiPoint" === o3 || "LineString" === o3)
              re(e4, t3);
            else if ("Polygon" === o3 || "MultiLineString" === o3)
              for (var i3 = 0; i3 < t3.length; i3++)
                re(e4, t3[i3]);
            else if ("MultiPolygon" === o3)
              for (i3 = 0; i3 < t3.length; i3++)
                for (var r3 = 0; r3 < t3[i3].length; r3++)
                  re(e4, t3[i3][r3]);
          }(r2), r2;
        }
        function re(e3, t2) {
          for (var o2 = 0; o2 < t2.length; o2 += 3)
            e3.minX = Math.min(e3.minX, t2[o2]), e3.minY = Math.min(e3.minY, t2[o2 + 1]), e3.maxX = Math.max(e3.maxX, t2[o2]), e3.maxY = Math.max(e3.maxY, t2[o2 + 1]);
        }
        function ne(e3, t2, o2, i2) {
          if (t2.geometry) {
            var r2 = t2.geometry.coordinates, n2 = t2.geometry.type, s2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2), a2 = [], l2 = t2.id;
            if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), "Point" === n2)
              se(r2, a2);
            else if ("MultiPoint" === n2)
              for (var c2 = 0; c2 < r2.length; c2++)
                se(r2[c2], a2);
            else if ("LineString" === n2)
              ae(r2, a2, s2, false);
            else if ("MultiLineString" === n2) {
              if (o2.lineMetrics) {
                for (c2 = 0; c2 < r2.length; c2++)
                  ae(r2[c2], a2 = [], s2, false), e3.push(ie(l2, "LineString", a2, t2.properties));
                return;
              }
              le(r2, a2, s2, false);
            } else if ("Polygon" === n2)
              le(r2, a2, s2, true);
            else {
              if ("MultiPolygon" !== n2) {
                if ("GeometryCollection" === n2) {
                  for (c2 = 0; c2 < t2.geometry.geometries.length; c2++)
                    ne(e3, { id: l2, geometry: t2.geometry.geometries[c2], properties: t2.properties }, o2, i2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (c2 = 0; c2 < r2.length; c2++) {
                var u2 = [];
                le(r2[c2], u2, s2, true), a2.push(u2);
              }
            }
            e3.push(ie(l2, n2, a2, t2.properties));
          }
        }
        function se(e3, t2) {
          t2.push(ce(e3[0])), t2.push(ue(e3[1])), t2.push(0);
        }
        function ae(e3, t2, o2, i2) {
          for (var r2, n2, s2 = 0, a2 = 0; a2 < e3.length; a2++) {
            var l2 = ce(e3[a2][0]), c2 = ue(e3[a2][1]);
            t2.push(l2), t2.push(c2), t2.push(0), a2 > 0 && (s2 += i2 ? (r2 * c2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - r2, 2) + Math.pow(c2 - n2, 2))), r2 = l2, n2 = c2;
          }
          var u2 = t2.length - 3;
          t2[2] = 1, te(t2, 0, u2, o2), t2[u2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
        }
        function le(e3, t2, o2, i2) {
          for (var r2 = 0; r2 < e3.length; r2++) {
            var n2 = [];
            ae(e3[r2], n2, o2, i2), t2.push(n2);
          }
        }
        function ce(e3) {
          return e3 / 360 + 0.5;
        }
        function ue(e3) {
          var t2 = Math.sin(e3 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function he(e3, t2, o2, i2, r2, n2, s2, a2) {
          if (i2 /= t2, n2 >= (o2 /= t2) && s2 < i2)
            return e3;
          if (s2 < o2 || n2 >= i2)
            return null;
          for (var l2 = [], c2 = 0; c2 < e3.length; c2++) {
            var u2 = e3[c2], h2 = u2.geometry, p2 = u2.type, f2 = 0 === r2 ? u2.minX : u2.minY, d2 = 0 === r2 ? u2.maxX : u2.maxY;
            if (f2 >= o2 && d2 < i2)
              l2.push(u2);
            else if (!(d2 < o2 || f2 >= i2)) {
              var g2 = [];
              if ("Point" === p2 || "MultiPoint" === p2)
                pe(h2, g2, o2, i2, r2);
              else if ("LineString" === p2)
                fe(h2, g2, o2, i2, r2, false, a2.lineMetrics);
              else if ("MultiLineString" === p2)
                ge(h2, g2, o2, i2, r2, false);
              else if ("Polygon" === p2)
                ge(h2, g2, o2, i2, r2, true);
              else if ("MultiPolygon" === p2)
                for (var m2 = 0; m2 < h2.length; m2++) {
                  var y2 = [];
                  ge(h2[m2], y2, o2, i2, r2, true), y2.length && g2.push(y2);
                }
              if (g2.length) {
                if (a2.lineMetrics && "LineString" === p2) {
                  for (m2 = 0; m2 < g2.length; m2++)
                    l2.push(ie(u2.id, p2, g2[m2], u2.tags));
                  continue;
                }
                "LineString" !== p2 && "MultiLineString" !== p2 || (1 === g2.length ? (p2 = "LineString", g2 = g2[0]) : p2 = "MultiLineString"), "Point" !== p2 && "MultiPoint" !== p2 || (p2 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(ie(u2.id, p2, g2, u2.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function pe(e3, t2, o2, i2, r2) {
          for (var n2 = 0; n2 < e3.length; n2 += 3) {
            var s2 = e3[n2 + r2];
            s2 >= o2 && s2 <= i2 && (t2.push(e3[n2]), t2.push(e3[n2 + 1]), t2.push(e3[n2 + 2]));
          }
        }
        function fe(e3, t2, o2, i2, r2, n2, s2) {
          for (var a2, l2, c2 = de(e3), u2 = 0 === r2 ? ye : ve, h2 = e3.start, p2 = 0; p2 < e3.length - 3; p2 += 3) {
            var f2 = e3[p2], d2 = e3[p2 + 1], g2 = e3[p2 + 2], m2 = e3[p2 + 3], y2 = e3[p2 + 4], v2 = 0 === r2 ? f2 : d2, x2 = 0 === r2 ? m2 : y2, w2 = false;
            s2 && (a2 = Math.sqrt(Math.pow(f2 - m2, 2) + Math.pow(d2 - y2, 2))), v2 < o2 ? x2 > o2 && (l2 = u2(c2, f2, d2, m2, y2, o2), s2 && (c2.start = h2 + a2 * l2)) : v2 > i2 ? x2 < i2 && (l2 = u2(c2, f2, d2, m2, y2, i2), s2 && (c2.start = h2 + a2 * l2)) : me(c2, f2, d2, g2), x2 < o2 && v2 >= o2 && (l2 = u2(c2, f2, d2, m2, y2, o2), w2 = true), x2 > i2 && v2 <= i2 && (l2 = u2(c2, f2, d2, m2, y2, i2), w2 = true), !n2 && w2 && (s2 && (c2.end = h2 + a2 * l2), t2.push(c2), c2 = de(e3)), s2 && (h2 += a2);
          }
          var S2 = e3.length - 3;
          f2 = e3[S2], d2 = e3[S2 + 1], g2 = e3[S2 + 2], (v2 = 0 === r2 ? f2 : d2) >= o2 && v2 <= i2 && me(c2, f2, d2, g2), S2 = c2.length - 3, n2 && S2 >= 3 && (c2[S2] !== c2[0] || c2[S2 + 1] !== c2[1]) && me(c2, c2[0], c2[1], c2[2]), c2.length && t2.push(c2);
        }
        function de(e3) {
          var t2 = [];
          return t2.size = e3.size, t2.start = e3.start, t2.end = e3.end, t2;
        }
        function ge(e3, t2, o2, i2, r2, n2) {
          for (var s2 = 0; s2 < e3.length; s2++)
            fe(e3[s2], t2, o2, i2, r2, n2, false);
        }
        function me(e3, t2, o2, i2) {
          e3.push(t2), e3.push(o2), e3.push(i2);
        }
        function ye(e3, t2, o2, i2, r2, n2) {
          var s2 = (n2 - t2) / (i2 - t2);
          return e3.push(n2), e3.push(o2 + (r2 - o2) * s2), e3.push(1), s2;
        }
        function ve(e3, t2, o2, i2, r2, n2) {
          var s2 = (n2 - o2) / (r2 - o2);
          return e3.push(t2 + (i2 - t2) * s2), e3.push(n2), e3.push(1), s2;
        }
        function xe(e3, t2) {
          for (var o2 = [], i2 = 0; i2 < e3.length; i2++) {
            var r2, n2 = e3[i2], s2 = n2.type;
            if ("Point" === s2 || "MultiPoint" === s2 || "LineString" === s2)
              r2 = we(n2.geometry, t2);
            else if ("MultiLineString" === s2 || "Polygon" === s2) {
              r2 = [];
              for (var a2 = 0; a2 < n2.geometry.length; a2++)
                r2.push(we(n2.geometry[a2], t2));
            } else if ("MultiPolygon" === s2)
              for (r2 = [], a2 = 0; a2 < n2.geometry.length; a2++) {
                for (var l2 = [], c2 = 0; c2 < n2.geometry[a2].length; c2++)
                  l2.push(we(n2.geometry[a2][c2], t2));
                r2.push(l2);
              }
            o2.push(ie(n2.id, s2, r2, n2.tags));
          }
          return o2;
        }
        function we(e3, t2) {
          var o2 = [];
          o2.size = e3.size, void 0 !== e3.start && (o2.start = e3.start, o2.end = e3.end);
          for (var i2 = 0; i2 < e3.length; i2 += 3)
            o2.push(e3[i2] + t2, e3[i2 + 1], e3[i2 + 2]);
          return o2;
        }
        function Se(e3, t2) {
          if (e3.transformed)
            return e3;
          var o2, i2, r2, n2 = 1 << e3.z, s2 = e3.x, a2 = e3.y;
          for (o2 = 0; o2 < e3.features.length; o2++) {
            var l2 = e3.features[o2], c2 = l2.geometry, u2 = l2.type;
            if (l2.geometry = [], 1 === u2)
              for (i2 = 0; i2 < c2.length; i2 += 2)
                l2.geometry.push(Ie(c2[i2], c2[i2 + 1], t2, n2, s2, a2));
            else
              for (i2 = 0; i2 < c2.length; i2++) {
                var h2 = [];
                for (r2 = 0; r2 < c2[i2].length; r2 += 2)
                  h2.push(Ie(c2[i2][r2], c2[i2][r2 + 1], t2, n2, s2, a2));
                l2.geometry.push(h2);
              }
          }
          return e3.transformed = true, e3;
        }
        function Ie(e3, t2, o2, i2, r2, n2) {
          return [Math.round(o2 * (e3 * i2 - r2)), Math.round(o2 * (t2 * i2 - n2))];
        }
        function Me(e3, t2, o2, i2, r2) {
          for (var n2 = t2 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t2) * r2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e3.length; a2++) {
            s2.numFeatures++, be(s2, e3[a2], n2, r2);
            var l2 = e3[a2].minX, c2 = e3[a2].minY, u2 = e3[a2].maxX, h2 = e3[a2].maxY;
            l2 < s2.minX && (s2.minX = l2), c2 < s2.minY && (s2.minY = c2), u2 > s2.maxX && (s2.maxX = u2), h2 > s2.maxY && (s2.maxY = h2);
          }
          return s2;
        }
        function be(e3, t2, o2, i2) {
          var r2 = t2.geometry, n2 = t2.type, s2 = [];
          if ("Point" === n2 || "MultiPoint" === n2)
            for (var a2 = 0; a2 < r2.length; a2 += 3)
              s2.push(r2[a2]), s2.push(r2[a2 + 1]), e3.numPoints++, e3.numSimplified++;
          else if ("LineString" === n2)
            ke(s2, r2, e3, o2, false, false);
          else if ("MultiLineString" === n2 || "Polygon" === n2)
            for (a2 = 0; a2 < r2.length; a2++)
              ke(s2, r2[a2], e3, o2, "Polygon" === n2, 0 === a2);
          else if ("MultiPolygon" === n2)
            for (var l2 = 0; l2 < r2.length; l2++) {
              var c2 = r2[l2];
              for (a2 = 0; a2 < c2.length; a2++)
                ke(s2, c2[a2], e3, o2, true, 0 === a2);
            }
          if (s2.length) {
            var u2 = t2.tags || null;
            if ("LineString" === n2 && i2.lineMetrics) {
              for (var h2 in u2 = {}, t2.tags)
                u2[h2] = t2.tags[h2];
              u2.mapbox_clip_start = r2.start / r2.size, u2.mapbox_clip_end = r2.end / r2.size;
            }
            var p2 = { geometry: s2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: u2 };
            null !== t2.id && (p2.id = t2.id), e3.features.push(p2);
          }
        }
        function ke(e3, t2, o2, i2, r2, n2) {
          var s2 = i2 * i2;
          if (i2 > 0 && t2.size < (r2 ? s2 : i2))
            o2.numPoints += t2.length / 3;
          else {
            for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
              (0 === i2 || t2[l2 + 2] > s2) && (o2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), o2.numPoints++;
            r2 && function(e4, t3) {
              for (var o3 = 0, i3 = 0, r3 = e4.length, n3 = r3 - 2; i3 < r3; n3 = i3, i3 += 2)
                o3 += (e4[i3] - e4[n3]) * (e4[i3 + 1] + e4[n3 + 1]);
              if (o3 > 0 === t3)
                for (i3 = 0, r3 = e4.length; i3 < r3 / 2; i3 += 2) {
                  var s3 = e4[i3], a3 = e4[i3 + 1];
                  e4[i3] = e4[r3 - 2 - i3], e4[i3 + 1] = e4[r3 - 1 - i3], e4[r3 - 2 - i3] = s3, e4[r3 - 1 - i3] = a3;
                }
            }(a2, n2), e3.push(a2);
          }
        }
        function _e(e3, t2) {
          var o2 = (t2 = this.options = function(e4, t3) {
            for (var o3 in t3)
              e4[o3] = t3[o3];
            return e4;
          }(Object.create(this.options), t2)).debug;
          if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var i2 = function(e4, t3) {
            var o3 = [];
            if ("FeatureCollection" === e4.type)
              for (var i3 = 0; i3 < e4.features.length; i3++)
                ne(o3, e4.features[i3], t3, i3);
            else
              ne(o3, "Feature" === e4.type ? e4 : { geometry: e4 }, t3);
            return o3;
          }(e3, t2);
          this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e4, t3) {
            var o3 = t3.buffer / t3.extent, i3 = e4, r2 = he(e4, 1, -1 - o3, o3, 0, -1, 2, t3), n2 = he(e4, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
            return (r2 || n2) && (i3 = he(e4, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], r2 && (i3 = xe(r2, 1).concat(i3)), n2 && (i3 = i3.concat(xe(n2, -1)))), i3;
          }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Pe(e3, t2, o2) {
          return 32 * ((1 << e3) * o2 + t2) + e3;
        }
        function Te(e3, t2) {
          const o2 = e3.tileID.canonical;
          if (!this._geoJSONIndex)
            return t2(null, null);
          const i2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
          if (!i2)
            return t2(null, null);
          const r2 = new g(i2.features);
          let n2 = z(r2);
          0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: r2, rawData: n2.buffer });
        }
        _e.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, _e.prototype.splitTile = function(e3, t2, o2, i2, r2, n2, s2) {
          for (var a2 = [e3, t2, o2, i2], l2 = this.options, c2 = l2.debug; a2.length; ) {
            i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e3 = a2.pop();
            var u2 = 1 << t2, h2 = Pe(t2, o2, i2), p2 = this.tiles[h2];
            if (!p2 && (c2 > 1 && console.time("creation"), p2 = this.tiles[h2] = Me(e3, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
              c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, p2.numFeatures, p2.numPoints, p2.numSimplified), console.timeEnd("creation"));
              var f2 = "z" + t2;
              this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
            }
            if (p2.source = e3, r2) {
              if (t2 === l2.maxZoom || t2 === r2)
                continue;
              var d2 = 1 << r2 - t2;
              if (o2 !== Math.floor(n2 / d2) || i2 !== Math.floor(s2 / d2))
                continue;
            } else if (t2 === l2.indexMaxZoom || p2.numPoints <= l2.indexMaxPoints)
              continue;
            if (p2.source = null, 0 !== e3.length) {
              c2 > 1 && console.time("clipping");
              var g2, m2, y2, v2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, I2 = 0.5 - S2, M2 = 0.5 + S2, b2 = 1 + S2;
              g2 = m2 = y2 = v2 = null, x2 = he(e3, u2, o2 - S2, o2 + M2, 0, p2.minX, p2.maxX, l2), w2 = he(e3, u2, o2 + I2, o2 + b2, 0, p2.minX, p2.maxX, l2), e3 = null, x2 && (g2 = he(x2, u2, i2 - S2, i2 + M2, 1, p2.minY, p2.maxY, l2), m2 = he(x2, u2, i2 + I2, i2 + b2, 1, p2.minY, p2.maxY, l2), x2 = null), w2 && (y2 = he(w2, u2, i2 - S2, i2 + M2, 1, p2.minY, p2.maxY, l2), v2 = he(w2, u2, i2 + I2, i2 + b2, 1, p2.minY, p2.maxY, l2), w2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(g2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(m2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(y2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
            }
          }
        }, _e.prototype.getTile = function(e3, t2, o2) {
          var i2 = this.options, r2 = i2.extent, n2 = i2.debug;
          if (e3 < 0 || e3 > 24)
            return null;
          var s2 = 1 << e3, a2 = Pe(e3, t2 = (t2 % s2 + s2) % s2, o2);
          if (this.tiles[a2])
            return Se(this.tiles[a2], r2);
          n2 > 1 && console.log("drilling down to z%d-%d-%d", e3, t2, o2);
          for (var l2, c2 = e3, u2 = t2, h2 = o2; !l2 && c2 > 0; )
            c2--, u2 = Math.floor(u2 / 2), h2 = Math.floor(h2 / 2), l2 = this.tiles[Pe(c2, u2, h2)];
          return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", c2, u2, h2), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, c2, u2, h2, e3, t2, o2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? Se(this.tiles[a2], r2) : null) : null;
        };
        class Ce extends l {
          constructor(e3, t2, o2, i2) {
            super(e3, t2, o2, Te), i2 && (this.loadGeoJSON = i2);
          }
          loadData(e3, t2) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), this._pendingCallback = t2, this._pendingLoadDataParams = e3, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
          }
          _loadData() {
            if (!this._pendingCallback || !this._pendingLoadDataParams)
              return;
            const t2 = this._pendingCallback, o2 = this._pendingLoadDataParams;
            delete this._pendingCallback, delete this._pendingLoadDataParams;
            const i2 = !!(o2 && o2.request && o2.request.collectResourceTiming) && new e2.RequestPerformance(o2.request);
            this.loadGeoJSON(o2, (r2, n2) => {
              if (r2 || !n2)
                return t2(r2);
              if ("object" != typeof n2)
                return t2(new Error(`Input data given to '${o2.source}' is not a valid GeoJSON object.`));
              {
                u(n2, true);
                try {
                  if (o2.filter) {
                    const t3 = e2.createExpression(o2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === t3.result)
                      throw new Error(t3.value.map((e3) => `${e3.key}: ${e3.message}`).join(", "));
                    const i3 = n2.features.filter((e3) => t3.value.evaluate({ zoom: 0 }, e3));
                    n2 = { type: "FeatureCollection", features: i3 };
                  }
                  this._geoJSONIndex = o2.cluster ? new V(function({ superclusterOptions: t3, clusterProperties: o3 }) {
                    if (!o3 || !t3)
                      return t3;
                    const i3 = {}, r3 = {}, n3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a2 = Object.keys(o3);
                    for (const t4 of a2) {
                      const [n4, s4] = o3[t4], a3 = e2.createExpression(s4), l2 = e2.createExpression("string" == typeof n4 ? [n4, ["accumulated"], ["get", t4]] : n4);
                      i3[t4] = a3.value, r3[t4] = l2.value;
                    }
                    return t3.map = (e3) => {
                      s3.properties = e3;
                      const t4 = {};
                      for (const e4 of a2)
                        t4[e4] = i3[e4].evaluate(n3, s3);
                      return t4;
                    }, t3.reduce = (e3, t4) => {
                      s3.properties = t4;
                      for (const t5 of a2)
                        n3.accumulated = e3[t5], e3[t5] = r3[t5].evaluate(n3, s3);
                    }, t3;
                  }(o2)).load(n2.features) : function(e3, t3) {
                    return new _e(e3, t3);
                  }(n2, o2.geojsonVtOptions);
                } catch (r3) {
                  return t2(r3);
                }
                this.loaded = {};
                const s2 = {};
                if (i2) {
                  const e3 = i2.finish();
                  e3 && (s2.resourceTiming = {}, s2.resourceTiming[o2.source] = JSON.parse(JSON.stringify(e3)));
                }
                t2(null, s2);
              }
            });
          }
          coalesce() {
            "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());
          }
          reloadTile(e3, t2) {
            const o2 = this.loaded;
            return o2 && o2[e3.uid] ? super.reloadTile(e3, t2) : this.loadTile(e3, t2);
          }
          loadGeoJSON(t2, o2) {
            if (t2.request)
              e2.getJSON(t2.request, o2);
            else {
              if ("string" != typeof t2.data)
                return o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              try {
                return o2(null, JSON.parse(t2.data));
              } catch (e3) {
                return o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          removeSource(e3, t2) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t2();
          }
          getClusterExpansionZoom(e3, t2) {
            try {
              t2(null, this._geoJSONIndex.getClusterExpansionZoom(e3.clusterId));
            } catch (e4) {
              t2(e4);
            }
          }
          getClusterChildren(e3, t2) {
            try {
              t2(null, this._geoJSONIndex.getChildren(e3.clusterId));
            } catch (e4) {
              t2(e4);
            }
          }
          getClusterLeaves(e3, t2) {
            try {
              t2(null, this._geoJSONIndex.getLeaves(e3.clusterId, e3.limit, e3.offset));
            } catch (e4) {
              t2(e4);
            }
          }
        }
        class De {
          constructor(t2) {
            this.self = t2, this.actor = new e2.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: Ce }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e3, t3) => {
              if (this.workerSourceTypes[e3])
                throw new Error(`Worker source with name "${e3}" already registered.`);
              this.workerSourceTypes[e3] = t3;
            }, this.self.registerRTLTextPlugin = (t3) => {
              if (e2.plugin.isParsed())
                throw new Error("RTL text plugin already registered.");
              e2.plugin.applyArabicShaping = t3.applyArabicShaping, e2.plugin.processBidirectionalText = t3.processBidirectionalText, e2.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
            };
          }
          setReferrer(e3, t2) {
            this.referrer = t2;
          }
          setImages(e3, t2, o2) {
            this.availableImages[e3] = t2;
            for (const o3 in this.workerSources[e3]) {
              const i2 = this.workerSources[e3][o3];
              for (const e4 in i2)
                i2[e4].availableImages = t2;
            }
            o2();
          }
          setLayers(e3, t2, o2) {
            this.getLayerIndex(e3).replace(t2), o2();
          }
          updateLayers(e3, t2, o2) {
            this.getLayerIndex(e3).update(t2.layers, t2.removedIds), o2();
          }
          loadTile(e3, t2, o2) {
            this.getWorkerSource(e3, t2.type, t2.source).loadTile(t2, o2);
          }
          loadDEMTile(e3, t2, o2) {
            this.getDEMWorkerSource(e3, t2.source).loadTile(t2, o2);
          }
          reloadTile(e3, t2, o2) {
            this.getWorkerSource(e3, t2.type, t2.source).reloadTile(t2, o2);
          }
          abortTile(e3, t2, o2) {
            this.getWorkerSource(e3, t2.type, t2.source).abortTile(t2, o2);
          }
          removeTile(e3, t2, o2) {
            this.getWorkerSource(e3, t2.type, t2.source).removeTile(t2, o2);
          }
          removeDEMTile(e3, t2) {
            this.getDEMWorkerSource(e3, t2.source).removeTile(t2);
          }
          removeSource(e3, t2, o2) {
            if (!this.workerSources[e3] || !this.workerSources[e3][t2.type] || !this.workerSources[e3][t2.type][t2.source])
              return;
            const i2 = this.workerSources[e3][t2.type][t2.source];
            delete this.workerSources[e3][t2.type][t2.source], void 0 !== i2.removeSource ? i2.removeSource(t2, o2) : o2();
          }
          loadWorkerSource(e3, t2, o2) {
            try {
              this.self.importScripts(t2.url), o2();
            } catch (e4) {
              o2(e4.toString());
            }
          }
          syncRTLPluginState(t2, o2, i2) {
            try {
              e2.plugin.setState(o2);
              const t3 = e2.plugin.getPluginURL();
              if (e2.plugin.isLoaded() && !e2.plugin.isParsed() && null != t3) {
                this.self.importScripts(t3);
                const o3 = e2.plugin.isParsed();
                i2(o3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), o3);
              }
            } catch (e3) {
              i2(e3.toString());
            }
          }
          getAvailableImages(e3) {
            let t2 = this.availableImages[e3];
            return t2 || (t2 = []), t2;
          }
          getLayerIndex(e3) {
            let t2 = this.layerIndexes[e3];
            return t2 || (t2 = this.layerIndexes[e3] = new i()), t2;
          }
          getWorkerSource(e3, t2, o2) {
            if (this.workerSources[e3] || (this.workerSources[e3] = {}), this.workerSources[e3][t2] || (this.workerSources[e3][t2] = {}), !this.workerSources[e3][t2][o2]) {
              const i2 = { send: (t3, o3, i3) => {
                this.actor.send(t3, o3, i3, e3);
              } };
              this.workerSources[e3][t2][o2] = new this.workerSourceTypes[t2](i2, this.getLayerIndex(e3), this.getAvailableImages(e3));
            }
            return this.workerSources[e3][t2][o2];
          }
          getDEMWorkerSource(e3, t2) {
            return this.demWorkerSources[e3] || (this.demWorkerSources[e3] = {}), this.demWorkerSources[e3][t2] || (this.demWorkerSources[e3][t2] = new c()), this.demWorkerSources[e3][t2];
          }
          enforceCacheSizeLimit(t2, o2) {
            e2.enforceCacheSizeLimit(o2);
          }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new De(self)), De;
      });
      define2(["./shared"], function(t) {
        "use strict";
        var e2 = i;
        function i(t2) {
          return !function(t3) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return false;
              var t4, e4, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
              try {
                e4 = new Worker(o2), t4 = true;
              } catch (e5) {
                t4 = false;
              }
              return e4 && e4.terminate(), URL.revokeObjectURL(o2), t4;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var t4 = document.createElement("canvas");
              t4.width = t4.height = 1;
              var e4 = t4.getContext("2d");
              if (!e4)
                return false;
              var i2 = e4.getImageData(0, 0, 1, 1);
              return i2 && i2.width === t4.width;
            }() ? (void 0 === o[e3 = t3 && t3.failIfMajorPerformanceCaveat] && (o[e3] = function(t4) {
              var e4, o2 = function(t5) {
                var e5 = document.createElement("canvas"), o3 = Object.create(i.webGLContextAttributes);
                return o3.failIfMajorPerformanceCaveat = t5, e5.getContext("webgl", o3) || e5.getContext("experimental-webgl", o3);
              }(t4);
              if (!o2)
                return false;
              try {
                e4 = o2.createShader(o2.VERTEX_SHADER);
              } catch (t5) {
                return false;
              }
              return !(!e4 || o2.isContextLost()) && (o2.shaderSource(e4, "void main() {}"), o2.compileShader(e4), true === o2.getShaderParameter(e4, o2.COMPILE_STATUS));
            }(e3)), o[e3] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var e3;
          }(t2);
        }
        var o = {};
        function a(t2, e3) {
          if (Array.isArray(t2)) {
            if (!Array.isArray(e3) || t2.length !== e3.length)
              return false;
            for (let i2 = 0; i2 < t2.length; i2++)
              if (!a(t2[i2], e3[i2]))
                return false;
            return true;
          }
          if ("object" == typeof t2 && null !== t2 && null !== e3) {
            if ("object" != typeof e3)
              return false;
            if (Object.keys(t2).length !== Object.keys(e3).length)
              return false;
            for (const i2 in t2)
              if (!a(t2[i2], e3[i2]))
                return false;
            return true;
          }
          return t2 === e3;
        }
        i.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        class s {
          static testProp(t2) {
            if (!s.docStyle)
              return t2[0];
            for (let e3 = 0; e3 < t2.length; e3++)
              if (t2[e3] in s.docStyle)
                return t2[e3];
            return t2[0];
          }
          static create(t2, e3, i2) {
            const o2 = window.document.createElement(t2);
            return void 0 !== e3 && (o2.className = e3), i2 && i2.appendChild(o2), o2;
          }
          static createNS(t2, e3) {
            return window.document.createElementNS(t2, e3);
          }
          static disableDrag() {
            s.docStyle && s.selectProp && (s.userSelect = s.docStyle[s.selectProp], s.docStyle[s.selectProp] = "none");
          }
          static enableDrag() {
            s.docStyle && s.selectProp && (s.docStyle[s.selectProp] = s.userSelect);
          }
          static setTransform(t2, e3) {
            t2.style[s.transformProp] = e3;
          }
          static addEventListener(t2, e3, i2, o2 = {}) {
            t2.addEventListener(e3, i2, "passive" in o2 ? o2 : o2.capture);
          }
          static removeEventListener(t2, e3, i2, o2 = {}) {
            t2.removeEventListener(e3, i2, "passive" in o2 ? o2 : o2.capture);
          }
          static suppressClickInternal(t2) {
            t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", s.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", s.suppressClickInternal, true), window.setTimeout(() => {
              window.removeEventListener("click", s.suppressClickInternal, true);
            }, 0);
          }
          static mousePos(e3, i2) {
            const o2 = e3.getBoundingClientRect();
            return new t.pointGeometry(i2.clientX - o2.left - e3.clientLeft, i2.clientY - o2.top - e3.clientTop);
          }
          static touchPos(e3, i2) {
            const o2 = e3.getBoundingClientRect(), a2 = [];
            for (let s2 = 0; s2 < i2.length; s2++)
              a2.push(new t.pointGeometry(i2[s2].clientX - o2.left - e3.clientLeft, i2[s2].clientY - o2.top - e3.clientTop));
            return a2;
          }
          static mouseButton(t2) {
            return t2.button;
          }
          static remove(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          }
        }
        s.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, s.selectProp = s.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), s.transformProp = s.testProp(["transform", "WebkitTransform"]);
        class r {
          constructor(t2) {
            this._transformRequestFn = t2;
          }
          transformRequest(t2, e3) {
            return this._transformRequestFn && this._transformRequestFn(t2, e3) || { url: t2 };
          }
          normalizeSpriteURL(t2, e3, i2) {
            const o2 = function(t3) {
              const e4 = t3.match(n);
              if (!e4)
                throw new Error(`Unable to parse URL "${t3}"`);
              return { protocol: e4[1], authority: e4[2], path: e4[3] || "/", params: e4[4] ? e4[4].split("&") : [] };
            }(t2);
            return o2.path += `${e3}${i2}`, function(t3) {
              const e4 = t3.params.length ? `?${t3.params.join("&")}` : "";
              return `${t3.protocol}://${t3.authority}${t3.path}${e4}`;
            }(o2);
          }
          setTransformRequest(t2) {
            this._transformRequestFn = t2;
          }
        }
        const n = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function l(e3) {
          var i2 = new t.ARRAY_TYPE(3);
          return i2[0] = e3[0], i2[1] = e3[1], i2[2] = e3[2], i2;
        }
        var c, h = function(t2, e3, i2) {
          return t2[0] = e3[0] - i2[0], t2[1] = e3[1] - i2[1], t2[2] = e3[2] - i2[2], t2;
        };
        c = new t.ARRAY_TYPE(3), t.ARRAY_TYPE != Float32Array && (c[0] = 0, c[1] = 0, c[2] = 0);
        var u = function(t2) {
          var e3 = t2[0], i2 = t2[1];
          return e3 * e3 + i2 * i2;
        };
        !function() {
          var e3 = new t.ARRAY_TYPE(2);
          t.ARRAY_TYPE != Float32Array && (e3[0] = 0, e3[1] = 0);
        }();
        class d {
          constructor(t2, e3, i2, o2) {
            this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e3, o2);
          }
          update(e3, i2, o2) {
            const { width: a2, height: s2 } = e3, r2 = !(this.size && this.size[0] === a2 && this.size[1] === s2 || o2), { context: n2 } = this, { gl: l2 } = n2;
            if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || false !== i2.premultiply)), r2)
              this.size = [a2, s2], e3 instanceof HTMLImageElement || e3 instanceof HTMLCanvasElement || e3 instanceof HTMLVideoElement || e3 instanceof ImageData || t.isImageBitmap(e3) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, e3) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, a2, s2, 0, this.format, l2.UNSIGNED_BYTE, e3.data);
            else {
              const { x: i3, y: r3 } = o2 || { x: 0, y: 0 };
              e3 instanceof HTMLImageElement || e3 instanceof HTMLCanvasElement || e3 instanceof HTMLVideoElement || e3 instanceof ImageData || t.isImageBitmap(e3) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, l2.RGBA, l2.UNSIGNED_BYTE, e3) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, a2, s2, l2.RGBA, l2.UNSIGNED_BYTE, e3.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
          }
          bind(t2, e3, i2) {
            const { context: o2 } = this, { gl: a2 } = o2;
            a2.bindTexture(a2.TEXTURE_2D, this.texture), i2 !== a2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = a2.LINEAR), t2 !== this.filter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, t2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e3 !== this.wrap && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, e3), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, e3), this.wrap = e3);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        function m(t2) {
          const { userImage: e3 } = t2;
          return !!(e3 && e3.render && e3.render()) && (t2.data.replace(new Uint8Array(e3.data.buffer)), true);
        }
        class _ extends t.Evented {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t2) {
            if (this.loaded !== t2 && (this.loaded = t2, t2)) {
              for (const { ids: t3, callback: e3 } of this.requestors)
                this._notify(t3, e3);
              this.requestors = [];
            }
          }
          getImage(t2) {
            return this.images[t2];
          }
          addImage(t2, e3) {
            this._validate(t2, e3) && (this.images[t2] = e3);
          }
          _validate(e3, i2) {
            let o2 = true;
            return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e3}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e3}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.ErrorEvent(new Error(`Image "${e3}" has invalid "content" value`))), o2 = false), o2;
          }
          _validateStretch(t2, e3) {
            if (!t2)
              return true;
            let i2 = 0;
            for (const o2 of t2) {
              if (o2[0] < i2 || o2[1] < o2[0] || e3 < o2[1])
                return false;
              i2 = o2[1];
            }
            return true;
          }
          _validateContent(t2, e3) {
            return !(t2 && (4 !== t2.length || t2[0] < 0 || e3.data.width < t2[0] || t2[1] < 0 || e3.data.height < t2[1] || t2[2] < 0 || e3.data.width < t2[2] || t2[3] < 0 || e3.data.height < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]));
          }
          updateImage(t2, e3) {
            e3.version = this.images[t2].version + 1, this.images[t2] = e3, this.updatedImages[t2] = true;
          }
          removeImage(t2) {
            const e3 = this.images[t2];
            delete this.images[t2], delete this.patterns[t2], e3.userImage && e3.userImage.onRemove && e3.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t2, e3) {
            let i2 = true;
            if (!this.isLoaded())
              for (const e4 of t2)
                this.images[e4] || (i2 = false);
            this.isLoaded() || i2 ? this._notify(t2, e3) : this.requestors.push({ ids: t2, callback: e3 });
          }
          _notify(e3, i2) {
            const o2 = {};
            for (const i3 of e3) {
              this.images[i3] || this.fire(new t.Event("styleimagemissing", { id: i3 }));
              const e4 = this.images[i3];
              e4 ? o2[i3] = { data: e4.data.clone(), pixelRatio: e4.pixelRatio, sdf: e4.sdf, version: e4.version, stretchX: e4.stretchX, stretchY: e4.stretchY, content: e4.content, hasRenderCallback: Boolean(e4.userImage && e4.userImage.render) } : t.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i2(null, o2);
          }
          getPixelSize() {
            const { width: t2, height: e3 } = this.atlasImage;
            return { width: t2, height: e3 };
          }
          getPattern(e3) {
            const i2 = this.patterns[e3], o2 = this.getImage(e3);
            if (!o2)
              return null;
            if (i2 && i2.position.version === o2.version)
              return i2.position;
            if (i2)
              i2.position.version = o2.version;
            else {
              const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(i3, o2);
              this.patterns[e3] = { bin: i3, position: a2 };
            }
            return this._updatePatternAtlas(), this.patterns[e3].position;
          }
          bind(t2) {
            const e3 = t2.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new d(t2, this.atlasImage, e3.RGBA), this.atlasTexture.bind(e3.LINEAR, e3.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e3 = [];
            for (const t2 in this.patterns)
              e3.push(this.patterns[t2].bin);
            const { w: i2, h: o2 } = t.potpack(e3), a2 = this.atlasImage;
            a2.resize({ width: i2 || 1, height: o2 || 1 });
            for (const e4 in this.patterns) {
              const { bin: i3 } = this.patterns[e4], o3 = i3.x + 1, s2 = i3.y + 1, r2 = this.images[e4].data, n2 = r2.width, l2 = r2.height;
              t.RGBAImage.copy(r2, a2, { x: 0, y: 0 }, { x: o3, y: s2 }, { width: n2, height: l2 }), t.RGBAImage.copy(r2, a2, { x: 0, y: l2 - 1 }, { x: o3, y: s2 - 1 }, { width: n2, height: 1 }), t.RGBAImage.copy(r2, a2, { x: 0, y: 0 }, { x: o3, y: s2 + l2 }, { width: n2, height: 1 }), t.RGBAImage.copy(r2, a2, { x: n2 - 1, y: 0 }, { x: o3 - 1, y: s2 }, { width: 1, height: l2 }), t.RGBAImage.copy(r2, a2, { x: 0, y: 0 }, { x: o3 + n2, y: s2 }, { width: 1, height: l2 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t2) {
            for (const e3 of t2) {
              if (this.callbackDispatchedThisFrame[e3])
                continue;
              this.callbackDispatchedThisFrame[e3] = true;
              const t3 = this.images[e3];
              m(t3) && this.updateImage(e3, t3);
            }
          }
        }
        const p = 1e20;
        function f(t2, e3, i2, o2, a2, s2, r2, n2, l2) {
          for (let c2 = e3; c2 < e3 + o2; c2++)
            g(t2, i2 * s2 + c2, s2, a2, r2, n2, l2);
          for (let c2 = i2; c2 < i2 + a2; c2++)
            g(t2, c2 * s2 + e3, 1, o2, r2, n2, l2);
        }
        function g(t2, e3, i2, o2, a2, s2, r2) {
          s2[0] = 0, r2[0] = -p, r2[1] = p, a2[0] = t2[e3];
          for (let n2 = 1, l2 = 0, c2 = 0; n2 < o2; n2++) {
            a2[n2] = t2[e3 + n2 * i2];
            const o3 = n2 * n2;
            do {
              const t3 = s2[l2];
              c2 = (a2[n2] - a2[t3] + o3 - t3 * t3) / (n2 - t3) / 2;
            } while (c2 <= r2[l2] && --l2 > -1);
            l2++, s2[l2] = n2, r2[l2] = c2, r2[l2 + 1] = p;
          }
          for (let n2 = 0, l2 = 0; n2 < o2; n2++) {
            for (; r2[l2 + 1] < n2; )
              l2++;
            const o3 = s2[l2], c2 = n2 - o3;
            t2[e3 + n2 * i2] = a2[o3] + c2 * c2;
          }
        }
        class x {
          constructor(t2, e3) {
            this.requestManager = t2, this.localIdeographFontFamily = e3, this.entries = {};
          }
          setURL(t2) {
            this.url = t2;
          }
          getGlyphs(e3, i2) {
            const o2 = [];
            for (const t2 in e3)
              for (const i3 of e3[t2])
                o2.push({ stack: t2, id: i3 });
            t.asyncAll(o2, ({ stack: t2, id: e4 }, i3) => {
              let o3 = this.entries[t2];
              o3 || (o3 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
              let a2 = o3.glyphs[e4];
              if (void 0 !== a2)
                return void i3(null, { stack: t2, id: e4, glyph: a2 });
              if (a2 = this._tinySDF(o3, t2, e4), a2)
                return o3.glyphs[e4] = a2, void i3(null, { stack: t2, id: e4, glyph: a2 });
              const s2 = Math.floor(e4 / 256);
              if (256 * s2 > 65535)
                return void i3(new Error("glyphs > 65535 not supported"));
              if (o3.ranges[s2])
                return void i3(null, { stack: t2, id: e4, glyph: a2 });
              let r2 = o3.requests[s2];
              r2 || (r2 = o3.requests[s2] = [], x.loadGlyphRange(t2, s2, this.url, this.requestManager, (t3, e5) => {
                if (e5) {
                  for (const t4 in e5)
                    this._doesCharSupportLocalGlyph(+t4) || (o3.glyphs[+t4] = e5[+t4]);
                  o3.ranges[s2] = true;
                }
                for (const i4 of r2)
                  i4(t3, e5);
                delete o3.requests[s2];
              })), r2.push((o4, a3) => {
                o4 ? i3(o4) : a3 && i3(null, { stack: t2, id: e4, glyph: a3[e4] || null });
              });
            }, (t2, e4) => {
              if (t2)
                i2(t2);
              else if (e4) {
                const t3 = {};
                for (const { stack: i3, id: o3, glyph: a2 } of e4)
                  (t3[i3] || (t3[i3] = {}))[o3] = a2 && { id: a2.id, bitmap: a2.bitmap.clone(), metrics: a2.metrics };
                i2(null, t3);
              }
            });
          }
          _doesCharSupportLocalGlyph(e3) {
            return !!this.localIdeographFontFamily && (t.unicodeBlockLookup["CJK Unified Ideographs"](e3) || t.unicodeBlockLookup["Hangul Syllables"](e3) || t.unicodeBlockLookup.Hiragana(e3) || t.unicodeBlockLookup.Katakana(e3));
          }
          _tinySDF(e3, i2, o2) {
            const a2 = this.localIdeographFontFamily;
            if (!a2)
              return;
            if (!this._doesCharSupportLocalGlyph(o2))
              return;
            let s2 = e3.tinySDF;
            if (!s2) {
              let t2 = "400";
              /bold/i.test(i2) ? t2 = "900" : /medium/i.test(i2) ? t2 = "500" : /light/i.test(i2) && (t2 = "200"), s2 = e3.tinySDF = new x.TinySDF({ fontSize: 24, buffer: 3, radius: 8, cutoff: 0.25, fontFamily: a2, fontWeight: t2 });
            }
            const r2 = s2.draw(String.fromCharCode(o2));
            return { id: o2, bitmap: new t.AlphaImage({ width: r2.width || 30, height: r2.height || 30 }, r2.data), metrics: { width: r2.glyphWidth || 24, height: r2.glyphHeight || 24, left: r2.glyphLeft || 0, top: r2.glyphTop - 27 || -8, advance: r2.glyphAdvance || 24 } };
          }
        }
        x.loadGlyphRange = function(e3, i2, o2, a2, s2) {
          const r2 = 256 * i2, n2 = r2 + 255, l2 = a2.transformRequest(o2.replace("{fontstack}", e3).replace("{range}", `${r2}-${n2}`), t.ResourceType.Glyphs);
          t.getArrayBuffer(l2, (e4, i3) => {
            if (e4)
              s2(e4);
            else if (i3) {
              const e5 = {};
              for (const o3 of t.parseGlyphPBF(i3))
                e5[o3.id] = o3;
              s2(null, e5);
            }
          });
        }, x.TinySDF = class {
          constructor({ fontSize: t2 = 24, buffer: e3 = 3, radius: i2 = 8, cutoff: o2 = 0.25, fontFamily: a2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: r2 = "normal" } = {}) {
            this.buffer = e3, this.cutoff = o2, this.radius = i2;
            const n2 = this.size = t2 + 4 * e3, l2 = this._createCanvas(n2), c2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
            c2.font = `${r2} ${s2} ${t2}px ${a2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
          }
          _createCanvas(t2) {
            const e3 = document.createElement("canvas");
            return e3.width = e3.height = t2, e3;
          }
          draw(t2) {
            const { width: e3, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: o2, actualBoundingBoxLeft: a2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), r2 = Math.ceil(i2), n2 = Math.min(this.size - this.buffer, Math.ceil(s2 - a2)), l2 = Math.min(this.size - this.buffer, r2 + Math.ceil(o2)), c2 = n2 + 2 * this.buffer, h2 = l2 + 2 * this.buffer, u2 = Math.max(c2 * h2, 0), d2 = new Uint8ClampedArray(u2), m2 = { data: d2, width: c2, height: h2, glyphWidth: n2, glyphHeight: l2, glyphTop: r2, glyphLeft: 0, glyphAdvance: e3 };
            if (0 === n2 || 0 === l2)
              return m2;
            const { ctx: _2, buffer: g2, gridInner: x2, gridOuter: v2 } = this;
            _2.clearRect(g2, g2, n2, l2), _2.fillText(t2, g2, g2 + r2);
            const y2 = _2.getImageData(g2, g2, n2, l2);
            v2.fill(p, 0, u2), x2.fill(0, 0, u2);
            for (let t3 = 0; t3 < l2; t3++)
              for (let e4 = 0; e4 < n2; e4++) {
                const i3 = y2.data[4 * (t3 * n2 + e4) + 3] / 255;
                if (0 === i3)
                  continue;
                const o3 = (t3 + g2) * c2 + e4 + g2;
                if (1 === i3)
                  v2[o3] = 0, x2[o3] = p;
                else {
                  const t4 = 0.5 - i3;
                  v2[o3] = t4 > 0 ? t4 * t4 : 0, x2[o3] = t4 < 0 ? t4 * t4 : 0;
                }
              }
            f(v2, 0, 0, c2, h2, c2, this.f, this.v, this.z), f(x2, g2, g2, n2, l2, c2, this.f, this.v, this.z);
            for (let t3 = 0; t3 < u2; t3++) {
              const e4 = Math.sqrt(v2[t3]) - Math.sqrt(x2[t3]);
              d2[t3] = Math.round(255 - 255 * (e4 / this.radius + this.cutoff));
            }
            return m2;
          }
        };
        const v = new t.Properties({ anchor: new t.DataConstantProperty(t.spec.light.anchor), position: new class {
          constructor() {
            this.specification = t.spec.light.position;
          }
          possiblyEvaluate(e3, i2) {
            return t.sphericalToCartesian(e3.expression.evaluate(i2));
          }
          interpolate(e3, i2, o2) {
            return { x: t.number(e3.x, i2.x, o2), y: t.number(e3.y, i2.y, o2), z: t.number(e3.z, i2.z, o2) };
          }
        }(), color: new t.DataConstantProperty(t.spec.light.color), intensity: new t.DataConstantProperty(t.spec.light.intensity) }), y = "-transition";
        class b extends t.Evented {
          constructor(e3) {
            super(), this._transitionable = new t.Transitionable(v), this.setLight(e3), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e3, i2 = {}) {
            if (!this._validate(t.validateLight, e3, i2))
              for (const t2 in e3) {
                const i3 = e3[t2];
                t2.endsWith(y) ? this._transitionable.setTransition(t2.slice(0, -y.length), i3) : this._transitionable.setValue(t2, i3);
              }
          }
          updateTransitions(t2) {
            this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t2) {
            this.properties = this._transitioning.possiblyEvaluate(t2);
          }
          _validate(e3, i2, o2) {
            return (!o2 || false !== o2.validate) && t.emitValidationErrors(this, e3.call(t.validateStyle, t.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.spec })));
          }
        }
        class w {
          constructor(t2, e3) {
            this.width = t2, this.height = e3, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t2, e3) {
            const i2 = t2.join(",") + String(e3);
            return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e3)), this.dashEntry[i2];
          }
          getDashRanges(t2, e3, i2) {
            const o2 = [];
            let a2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, s2 = t2[0] * i2, r2 = true;
            o2.push({ left: a2, right: s2, isDash: r2, zeroLength: 0 === t2[0] });
            let n2 = t2[0];
            for (let e4 = 1; e4 < t2.length; e4++) {
              r2 = !r2;
              const l2 = t2[e4];
              a2 = n2 * i2, n2 += l2, s2 = n2 * i2, o2.push({ left: a2, right: s2, isDash: r2, zeroLength: 0 === l2 });
            }
            return o2;
          }
          addRoundDash(t2, e3, i2) {
            const o2 = e3 / 2;
            for (let e4 = -i2; e4 <= i2; e4++) {
              const a2 = this.width * (this.nextRow + i2 + e4);
              let s2 = 0, r2 = t2[s2];
              for (let n2 = 0; n2 < this.width; n2++) {
                n2 / r2.right > 1 && (r2 = t2[++s2]);
                const l2 = Math.abs(n2 - r2.left), c2 = Math.abs(n2 - r2.right), h2 = Math.min(l2, c2);
                let u2;
                const d2 = e4 / i2 * (o2 + 1);
                if (r2.isDash) {
                  const t3 = o2 - Math.abs(d2);
                  u2 = Math.sqrt(h2 * h2 + t3 * t3);
                } else
                  u2 = o2 - Math.sqrt(h2 * h2 + d2 * d2);
                this.data[a2 + n2] = Math.max(0, Math.min(255, u2 + 128));
              }
            }
          }
          addRegularDash(t2) {
            for (let e4 = t2.length - 1; e4 >= 0; --e4) {
              const i3 = t2[e4], o3 = t2[e4 + 1];
              i3.zeroLength ? t2.splice(e4, 1) : o3 && o3.isDash === i3.isDash && (o3.left = i3.left, t2.splice(e4, 1));
            }
            const e3 = t2[0], i2 = t2[t2.length - 1];
            e3.isDash === i2.isDash && (e3.left = i2.left - this.width, i2.right = e3.right + this.width);
            const o2 = this.width * this.nextRow;
            let a2 = 0, s2 = t2[a2];
            for (let e4 = 0; e4 < this.width; e4++) {
              e4 / s2.right > 1 && (s2 = t2[++a2]);
              const i3 = Math.abs(e4 - s2.left), r2 = Math.abs(e4 - s2.right), n2 = Math.min(i3, r2);
              this.data[o2 + e4] = Math.max(0, Math.min(255, (s2.isDash ? n2 : -n2) + 128));
            }
          }
          addDash(e3, i2) {
            const o2 = i2 ? 7 : 0, a2 = 2 * o2 + 1;
            if (this.nextRow + a2 > this.height)
              return t.warnOnce("LineAtlas out of space"), null;
            let s2 = 0;
            for (let t2 = 0; t2 < e3.length; t2++)
              s2 += e3[t2];
            if (0 !== s2) {
              const t2 = this.width / s2, a3 = this.getDashRanges(e3, this.width, t2);
              i2 ? this.addRoundDash(a3, t2, o2) : this.addRegularDash(a3);
            }
            const r2 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: s2 };
            return this.nextRow += a2, this.dirty = true, r2;
          }
          bind(t2) {
            const e3 = t2.gl;
            this.texture ? (e3.bindTexture(e3.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e3.texSubImage2D(e3.TEXTURE_2D, 0, 0, 0, this.width, this.height, e3.ALPHA, e3.UNSIGNED_BYTE, this.data))) : (this.texture = e3.createTexture(), e3.bindTexture(e3.TEXTURE_2D, this.texture), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_S, e3.REPEAT), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_T, e3.REPEAT), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MIN_FILTER, e3.LINEAR), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MAG_FILTER, e3.LINEAR), e3.texImage2D(e3.TEXTURE_2D, 0, e3.ALPHA, this.width, this.height, 0, e3.ALPHA, e3.UNSIGNED_BYTE, this.data));
          }
        }
        class T {
          constructor(e3, i2) {
            this.workerPool = e3, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
            const o2 = this.workerPool.acquire(this.id);
            for (let t2 = 0; t2 < o2.length; t2++) {
              const e4 = new T.Actor(o2[t2], i2, this.id);
              e4.name = `Worker ${t2}`, this.actors.push(e4);
            }
          }
          broadcast(e3, i2, o2) {
            t.asyncAll(this.actors, (t2, o3) => {
              t2.send(e3, i2, o3);
            }, o2 = o2 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((t2) => {
              t2.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        function E(e3, i2, o2) {
          const a2 = function(i3, a3) {
            if (i3)
              return o2(i3);
            if (a3) {
              const i4 = t.pick(t.extend(a3, e3), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
              a3.vector_layers && (i4.vectorLayers = a3.vector_layers, i4.vectorLayerIds = i4.vectorLayers.map((t2) => t2.id)), o2(null, i4);
            }
          };
          return e3.url ? t.getJSON(i2.transformRequest(e3.url, t.ResourceType.Source), a2) : t.exported.frame(() => a2(null, e3));
        }
        T.Actor = t.Actor;
        class I {
          constructor(e3, i2, o2) {
            this.bounds = t.LngLatBounds.convert(this.validateBounds(e3)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
          }
          validateBounds(t2) {
            return Array.isArray(t2) && 4 === t2.length ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
          }
          contains(e3) {
            const i2 = Math.pow(2, e3.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), a2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), s2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), r2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
            return e3.x >= o2 && e3.x < s2 && e3.y >= a2 && e3.y < r2;
          }
        }
        class S extends t.Evented {
          constructor(e3, i2, o2, a2) {
            if (super(), this.id = e3, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a2);
          }
          load() {
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = E(this._options, this.map._requestManager, (e3, i2) => {
              this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e3 ? this.fire(new t.ErrorEvent(e3)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new I(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setSourceProperty(t2) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), t2(), this.load();
          }
          setTiles(t2) {
            return this.setSourceProperty(() => {
              this._options.tiles = t2;
            }), this;
          }
          setUrl(t2) {
            return this.setSourceProperty(() => {
              this.url = t2, this._options.url = t2;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          serialize() {
            return t.extend({}, this._options);
          }
          loadTile(e3, i2) {
            const o2 = e3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, tileSize: this.tileSize * e3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            function s2(o3, a3) {
              return delete e3.request, e3.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (a3 && a3.resourceTiming && (e3.resourceTiming = a3.resourceTiming), this.map._refreshExpiredTiles && a3 && e3.setExpiryData(a3), e3.loadVectorData(a3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (e3.reloadCallback && (this.loadTile(e3, e3.reloadCallback), e3.reloadCallback = null)));
            }
            a2.request.collectResourceTiming = this._collectResourceTiming, e3.actor && "expired" !== e3.state ? "loading" === e3.state ? e3.reloadCallback = i2 : e3.request = e3.actor.send("reloadTile", a2, s2.bind(this)) : (e3.actor = this.dispatcher.getActor(), e3.request = e3.actor.send("loadTile", a2, s2.bind(this)));
          }
          abortTile(t2) {
            t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
          }
          unloadTile(t2) {
            t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
          }
          hasTransition() {
            return false;
          }
        }
        class C extends t.Evented {
          constructor(e3, i2, o2, a2) {
            super(), this.id = e3, this.dispatcher = o2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, i2), t.extend(this, t.pick(i2, ["url", "scheme", "tileSize"]));
          }
          load() {
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = E(this._options, this.map._requestManager, (e3, i2) => {
              this._tileJSONRequest = null, this._loaded = true, e3 ? this.fire(new t.ErrorEvent(e3)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new I(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          serialize() {
            return t.extend({}, this._options);
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          loadTile(e3, i2) {
            const o2 = e3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), (o3, a2, s2) => {
              if (delete e3.request, e3.aborted)
                e3.state = "unloaded", i2(null);
              else if (o3)
                e3.state = "errored", i2(o3);
              else if (a2) {
                this.map._refreshExpiredTiles && e3.setExpiryData(s2);
                const o4 = this.map.painter.context, r2 = o4.gl;
                e3.texture = this.map.painter.getTileTexture(a2.width), e3.texture ? e3.texture.update(a2, { useMipmap: true }) : (e3.texture = new d(o4, a2, r2.RGBA, { useMipmap: true }), e3.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST), o4.extTextureFilterAnisotropic && r2.texParameterf(r2.TEXTURE_2D, o4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o4.extTextureFilterAnisotropicMax)), e3.state = "loaded", t.cacheEntryPossiblyAdded(this.dispatcher), i2(null);
              }
            });
          }
          abortTile(t2, e3) {
            t2.request && (t2.request.cancel(), delete t2.request), e3();
          }
          unloadTile(t2, e3) {
            t2.texture && this.map.painter.saveTileTexture(t2.texture), e3();
          }
          hasTransition() {
            return false;
          }
        }
        let P;
        class z extends C {
          constructor(e3, i2, o2, a2) {
            super(e3, i2, o2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
          }
          serialize() {
            return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
          }
          loadTile(e3, i2) {
            const o2 = e3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            function a2(t2, o3) {
              t2 && (e3.state = "errored", i2(t2)), o3 && (e3.dem = o3, e3.needsHillshadePrepare = true, e3.state = "loaded", i2(null));
            }
            e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), (function(o3, s2) {
              if (delete e3.request, e3.aborted)
                e3.state = "unloaded", i2(null);
              else if (o3)
                e3.state = "errored", i2(o3);
              else if (s2) {
                this.map._refreshExpiredTiles && e3.setExpiryData(s2), delete s2.cacheControl, delete s2.expires;
                const i3 = t.isImageBitmap(s2) && (null == P && (P = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), P) ? s2 : t.exported.getImageData(s2, 1), o4 = { uid: e3.uid, coord: e3.tileID, source: this.id, rawImageData: i3, encoding: this.encoding };
                e3.actor && "expired" !== e3.state || (e3.actor = this.dispatcher.getActor(), e3.actor.send("loadDEMTile", o4, a2.bind(this)));
              }
            }).bind(this)), e3.neighboringTiles = this._getNeighboringTiles(e3.tileID);
          }
          _getNeighboringTiles(e3) {
            const i2 = e3.canonical, o2 = Math.pow(2, i2.z), a2 = (i2.x - 1 + o2) % o2, s2 = 0 === i2.x ? e3.wrap - 1 : e3.wrap, r2 = (i2.x + 1 + o2) % o2, n2 = i2.x + 1 === o2 ? e3.wrap + 1 : e3.wrap, l2 = {};
            return l2[new t.OverscaledTileID(e3.overscaledZ, s2, i2.z, a2, i2.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new t.OverscaledTileID(e3.overscaledZ, s2, i2.z, a2, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new t.OverscaledTileID(e3.overscaledZ, s2, i2.z, a2, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }), l2;
          }
          unloadTile(t2) {
            t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && t2.actor.send("removeDEMTile", { uid: t2.uid, source: this.id });
          }
        }
        class D extends t.Evented {
          constructor(e3, i2, o2, a2) {
            super(), this.id = e3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = o2.getActor(), this.setEventedParent(a2), this._data = i2.data, this._options = t.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
            const s2 = t.EXTENT / this.tileSize;
            this.workerOptions = t.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * s2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * s2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.EXTENT, radius: (i2.clusterRadius || 50) * s2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
          }
          load() {
            this._updateWorkerData("metadata");
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setData(t2) {
            return this._data = t2, this._updateWorkerData("content"), this;
          }
          getClusterExpansionZoom(t2, e3) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e3), this;
          }
          getClusterChildren(t2, e3) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e3), this;
          }
          getClusterLeaves(t2, e3, i2, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e3, offset: i2 }, o2), this;
          }
          _updateWorkerData(e3) {
            const i2 = t.extend({}, this.workerOptions), o2 = this._data;
            "string" == typeof o2 ? (i2.request = this.map._requestManager.transformRequest(t.exported.resolveURL(o2), t.ResourceType.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoads++, this.fire(new t.Event("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i2, (o3, a2) => {
              if (this._pendingLoads--, this._removed || a2 && a2.abandoned)
                return;
              let s2 = null;
              if (a2 && a2.resourceTiming && a2.resourceTiming[this.id] && (s2 = a2.resourceTiming[this.id].slice(0)), this.actor.send(`${this.type}.coalesce`, { source: i2.source }, null), o3)
                return void this.fire(new t.ErrorEvent(o3));
              const r2 = { dataType: "source", sourceDataType: e3 };
              this._collectResourceTiming && s2 && s2.length > 0 && t.extend(r2, { resourceTiming: s2 }), this.fire(new t.Event("data", r2));
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(t2, e3) {
            const i2 = t2.actor ? "reloadTile" : "loadTile";
            t2.actor = this.actor;
            const o2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t2.request = this.actor.send(i2, o2, (o3, a2) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? e3(null) : o3 ? e3(o3) : (t2.loadVectorData(a2, this.map.painter, "reloadTile" === i2), e3(null))));
          }
          abortTile(t2) {
            t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = true;
          }
          unloadTile(t2) {
            t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
          }
          serialize() {
            return t.extend({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        var A = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class M extends t.Evented {
          constructor(t2, e3, i2, o2) {
            super(), this.id = t2, this.dispatcher = i2, this.coordinates = e3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = e3;
          }
          load(e3, i2) {
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (o2, a2) => {
              this._loaded = true, o2 ? this.fire(new t.ErrorEvent(o2)) : a2 && (this.image = a2, e3 && (this.coordinates = e3), i2 && i2(), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t2) {
            return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, () => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setCoordinates(e3) {
            this.coordinates = e3;
            const i2 = e3.map(t.MercatorCoordinate.fromLngLat);
            this.tileID = function(e4) {
              let i3 = 1 / 0, o3 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
              for (const t2 of e4)
                i3 = Math.min(i3, t2.x), o3 = Math.min(o3, t2.y), a2 = Math.max(a2, t2.x), s2 = Math.max(s2, t2.y);
              const r2 = Math.max(a2 - i3, s2 - o3), n2 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l2 = Math.pow(2, n2);
              return new t.CanonicalTileID(n2, Math.floor((i3 + a2) / 2 * l2), Math.floor((o3 + s2) / 2 * l2));
            }(i2), this.minzoom = this.maxzoom = this.tileID.z;
            const o2 = i2.map((t2) => this.tileID.getTilePoint(t2)._round());
            return this._boundsArray = new t.RasterBoundsArray(), this._boundsArray.emplaceBack(o2[0].x, o2[0].y, 0, 0), this._boundsArray.emplaceBack(o2[1].x, o2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(o2[3].x, o2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(o2[2].x, o2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image)
              return;
            const e3 = this.map.painter.context, i2 = e3.gl;
            this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new d(e3, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            for (const t2 in this.tiles) {
              const e4 = this.tiles[t2];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture);
            }
          }
          loadTile(t2, e3) {
            this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e3(null)) : (t2.state = "errored", e3(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        class L extends M {
          constructor(t2, e3, i2, o2) {
            super(t2, e3, i2, o2), this.roundZoom = true, this.type = "video", this.options = e3;
          }
          load() {
            this._loaded = false;
            const e3 = this.options;
            this.urls = [];
            for (const i2 of e3.urls)
              this.urls.push(this.map._requestManager.transformRequest(i2, t.ResourceType.Source).url);
            t.getVideo(this.urls, (e4, i2) => {
              this._loaded = true, e4 ? this.fire(new t.ErrorEvent(e4)) : i2 && (this.video = i2, this.video.loop = true, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e3) {
            if (this.video) {
              const i2 = this.video.seekable;
              e3 < i2.start(0) || e3 > i2.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e3;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t2) {
            this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
              return;
            const e3 = this.map.painter.context, i2 = e3.gl;
            this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new d(e3, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            for (const t2 in this.tiles) {
              const e4 = this.tiles[t2];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture);
            }
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class R extends M {
          constructor(e3, i2, o2, a2) {
            super(e3, i2, o2, a2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((t2) => !Array.isArray(t2) || 2 !== t2.length || t2.some((t3) => "number" != typeof t3)) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t2) {
            this.map = t2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), this._hasInvalidDimensions())
              return;
            if (0 === Object.keys(this.tiles).length)
              return;
            const i2 = this.map.painter.context, o2 = i2.gl;
            this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new d(i2, this.canvas, o2.RGBA, { premultiply: true });
            for (const t2 in this.tiles) {
              const e4 = this.tiles[t2];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture);
            }
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t2 of [this.canvas.width, this.canvas.height])
              if (isNaN(t2) || t2 <= 0)
                return true;
            return false;
          }
        }
        const k = { vector: S, raster: C, "raster-dem": z, geojson: D, video: L, image: M, canvas: R };
        function B(e3, i2) {
          const o2 = t.create();
          return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e3.width, 0.5 * e3.height, 1]), t.multiply(o2, o2, e3.calculatePosMatrix(i2.toUnwrapped()));
        }
        function F(t2, e3, i2, o2, a2, s2) {
          const r2 = function(t3, e4, i3) {
            if (t3)
              for (const o3 of t3) {
                const t4 = e4[o3];
                if (t4 && t4.source === i3 && "fill-extrusion" === t4.type)
                  return true;
              }
            else
              for (const t4 in e4) {
                const o3 = e4[t4];
                if (o3.source === i3 && "fill-extrusion" === o3.type)
                  return true;
              }
            return false;
          }(a2 && a2.layers, e3, t2.id), n2 = s2.maxPitchScaleFactor(), l2 = t2.tilesIn(o2, n2, r2);
          l2.sort(O);
          const c2 = [];
          for (const o3 of l2)
            c2.push({ wrappedTileID: o3.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(e3, i2, t2._state, o3.queryGeometry, o3.cameraQueryGeometry, o3.scale, a2, s2, n2, B(t2.transform, o3.tileID)) });
          const h2 = function(t3) {
            const e4 = {}, i3 = {};
            for (const o3 of t3) {
              const t4 = o3.queryResults, a3 = o3.wrappedTileID, s3 = i3[a3] = i3[a3] || {};
              for (const i4 in t4) {
                const o4 = t4[i4], a4 = s3[i4] = s3[i4] || {}, r3 = e4[i4] = e4[i4] || [];
                for (const t5 of o4)
                  a4[t5.featureIndex] || (a4[t5.featureIndex] = true, r3.push(t5));
              }
            }
            return e4;
          }(c2);
          for (const e4 in h2)
            h2[e4].forEach((e5) => {
              const i3 = e5.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
              i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
            });
          return h2;
        }
        function O(t2, e3) {
          const i2 = t2.tileID, o2 = e3.tileID;
          return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
        }
        class U {
          constructor(e3, i2) {
            this.tileID = e3, this.uid = t.uniqueId(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e3) {
            const i2 = e3 + this.timeAdded;
            i2 < t.exported.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          loadVectorData(e3, i2, o2) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e3) {
              e3.featureIndex && (this.latestFeatureIndex = e3.featureIndex, e3.rawTileData ? (this.latestRawTileData = e3.rawTileData, this.latestFeatureIndex.rawTileData = e3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e3.collisionBoxArray, this.buckets = function(t2, e4) {
                const i3 = {};
                if (!e4)
                  return i3;
                for (const o3 of t2) {
                  const t3 = o3.layerIds.map((t4) => e4.getLayer(t4)).filter(Boolean);
                  if (0 !== t3.length) {
                    o3.layers = t3, o3.stateDependentLayerIds && (o3.stateDependentLayers = o3.stateDependentLayerIds.map((e5) => t3.filter((t4) => t4.id === e5)[0]));
                    for (const e5 of t3)
                      i3[e5.id] = o3;
                  }
                }
                return i3;
              }(e3.buckets, i2.style), this.hasSymbolBuckets = false;
              for (const e4 in this.buckets) {
                const i3 = this.buckets[e4];
                if (i3 instanceof t.SymbolBucket) {
                  if (this.hasSymbolBuckets = true, !o2)
                    break;
                  i3.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const e4 in this.buckets) {
                  const i3 = this.buckets[e4];
                  if (i3 instanceof t.SymbolBucket && i3.hasRTLText) {
                    this.hasRTLText = true, t.lazyLoadRTLTextPlugin();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t2 in this.buckets) {
                const e4 = this.buckets[t2];
                this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t2).queryRadius(e4));
              }
              e3.imageAtlas && (this.imageAtlas = e3.imageAtlas), e3.glyphAtlasImage && (this.glyphAtlasImage = e3.glyphAtlasImage);
            } else
              this.collisionBoxArray = new t.CollisionBoxArray();
          }
          unloadVectorData() {
            for (const t2 in this.buckets)
              this.buckets[t2].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t2) {
            return this.buckets[t2.id];
          }
          upload(t2) {
            for (const e4 in this.buckets) {
              const i2 = this.buckets[e4];
              i2.uploadPending() && i2.upload(t2);
            }
            const e3 = t2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new d(t2, this.imageAtlas.image, e3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new d(t2, this.glyphAtlasImage, e3.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t2, e3, i2, o2, a2, s2, r2, n2, l2, c2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: o2, cameraQueryGeometry: a2, scale: s2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: r2, queryPadding: this.queryPadding * l2 }, t2, e3, i2) : {};
          }
          querySourceFeatures(e3, i2) {
            const o2 = this.latestFeatureIndex;
            if (!o2 || !o2.rawTileData)
              return;
            const a2 = o2.loadVTLayers(), s2 = i2 ? i2.sourceLayer : "", r2 = a2._geojsonTileLayer || a2[s2];
            if (!r2)
              return;
            const n2 = t.createFilter(i2 && i2.filter), { z: l2, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h2 };
            for (let i3 = 0; i3 < r2.length; i3++) {
              const a3 = r2.feature(i3);
              if (n2.needGeometry) {
                const e4 = t.toEvaluationFeature(a3, true);
                if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), e4, this.tileID.canonical))
                  continue;
              } else if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), a3))
                continue;
              const d2 = o2.getId(a3, s2), m2 = new t.GeoJSONFeature(a3, l2, c2, h2, d2);
              m2.tile = u2, e3.push(m2);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e3) {
            const i2 = this.expirationTime;
            if (e3.cacheControl) {
              const i3 = t.parseCacheControl(e3.cacheControl);
              i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
            } else
              e3.expires && (this.expirationTime = new Date(e3.expires).getTime());
            if (this.expirationTime) {
              const t2 = Date.now();
              let e4 = false;
              if (this.expirationTime > t2)
                e4 = false;
              else if (i2)
                if (this.expirationTime < i2)
                  e4 = true;
                else {
                  const o2 = this.expirationTime - i2;
                  o2 ? this.expirationTime = t2 + Math.max(o2, 3e4) : e4 = true;
                }
              else
                e4 = true;
              e4 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t2, e3) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length)
              return;
            const i2 = this.latestFeatureIndex.loadVTLayers();
            for (const o2 in this.buckets) {
              if (!e3.style.hasLayer(o2))
                continue;
              const a2 = this.buckets[o2], s2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i2[s2], n2 = t2[s2];
              if (!r2 || !n2 || 0 === Object.keys(n2).length)
                continue;
              a2.update(n2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const l2 = e3 && e3.style && e3.style.getLayer(o2);
              l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(a2)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t.exported.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e3) {
            this.symbolFadeHoldUntil = t.exported.now() + e3;
          }
          setDependencies(t2, e3) {
            const i2 = {};
            for (const t3 of e3)
              i2[t3] = true;
            this.dependencies[t2] = i2;
          }
          hasDependency(t2, e3) {
            for (const i2 of t2) {
              const t3 = this.dependencies[i2];
              if (t3) {
                for (const i3 of e3)
                  if (t3[i3])
                    return true;
              }
            }
            return false;
          }
        }
        class N {
          constructor(t2, e3) {
            this.max = t2, this.onRemove = e3, this.reset();
          }
          reset() {
            for (const t2 in this.data)
              for (const e3 of this.data[t2])
                e3.timeout && clearTimeout(e3.timeout), this.onRemove(e3.value);
            return this.data = {}, this.order = [], this;
          }
          add(t2, e3, i2) {
            const o2 = t2.wrapped().key;
            void 0 === this.data[o2] && (this.data[o2] = []);
            const a2 = { value: e3, timeout: void 0 };
            if (void 0 !== i2 && (a2.timeout = setTimeout(() => {
              this.remove(t2, a2);
            }, i2)), this.data[o2].push(a2), this.order.push(o2), this.order.length > this.max) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          has(t2) {
            return t2.wrapped().key in this.data;
          }
          getAndRemove(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }
          _getAndRemoveByKey(t2) {
            const e3 = this.data[t2].shift();
            return e3.timeout && clearTimeout(e3.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e3.value;
          }
          getByKey(t2) {
            const e3 = this.data[t2];
            return e3 ? e3[0].value : null;
          }
          get(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }
          remove(t2, e3) {
            if (!this.has(t2))
              return this;
            const i2 = t2.wrapped().key, o2 = void 0 === e3 ? 0 : this.data[i2].indexOf(e3), a2 = this.data[i2][o2];
            return this.data[i2].splice(o2, 1), a2.timeout && clearTimeout(a2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(a2.value), this.order.splice(this.order.indexOf(i2), 1), this;
          }
          setMaxSize(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          filter(t2) {
            const e3 = [];
            for (const i2 in this.data)
              for (const o2 of this.data[i2])
                t2(o2.value) || e3.push(o2);
            for (const t3 of e3)
              this.remove(t3.value.tileID, t3);
          }
        }
        class G {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e3, i2, o2) {
            const a2 = String(i2);
            if (this.stateChanges[e3] = this.stateChanges[e3] || {}, this.stateChanges[e3][a2] = this.stateChanges[e3][a2] || {}, t.extend(this.stateChanges[e3][a2], o2), null === this.deletedStates[e3]) {
              this.deletedStates[e3] = {};
              for (const t2 in this.state[e3])
                t2 !== a2 && (this.deletedStates[e3][t2] = null);
            } else if (this.deletedStates[e3] && null === this.deletedStates[e3][a2]) {
              this.deletedStates[e3][a2] = {};
              for (const t2 in this.state[e3][a2])
                o2[t2] || (this.deletedStates[e3][a2][t2] = null);
            } else
              for (const t2 in o2)
                this.deletedStates[e3] && this.deletedStates[e3][a2] && null === this.deletedStates[e3][a2][t2] && delete this.deletedStates[e3][a2][t2];
          }
          removeFeatureState(t2, e3, i2) {
            if (null === this.deletedStates[t2])
              return;
            const o2 = String(e3);
            if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && void 0 !== e3)
              null !== this.deletedStates[t2][o2] && (this.deletedStates[t2][o2] = this.deletedStates[t2][o2] || {}, this.deletedStates[t2][o2][i2] = null);
            else if (void 0 !== e3)
              if (this.stateChanges[t2] && this.stateChanges[t2][o2])
                for (i2 in this.deletedStates[t2][o2] = {}, this.stateChanges[t2][o2])
                  this.deletedStates[t2][o2][i2] = null;
              else
                this.deletedStates[t2][o2] = null;
            else
              this.deletedStates[t2] = null;
          }
          getState(e3, i2) {
            const o2 = String(i2), a2 = t.extend({}, (this.state[e3] || {})[o2], (this.stateChanges[e3] || {})[o2]);
            if (null === this.deletedStates[e3])
              return {};
            if (this.deletedStates[e3]) {
              const t2 = this.deletedStates[e3][i2];
              if (null === t2)
                return {};
              for (const e4 in t2)
                delete a2[e4];
            }
            return a2;
          }
          initializeTileState(t2, e3) {
            t2.setFeatureState(this.state, e3);
          }
          coalesceChanges(e3, i2) {
            const o2 = {};
            for (const e4 in this.stateChanges) {
              this.state[e4] = this.state[e4] || {};
              const i3 = {};
              for (const o3 in this.stateChanges[e4])
                this.state[e4][o3] || (this.state[e4][o3] = {}), t.extend(this.state[e4][o3], this.stateChanges[e4][o3]), i3[o3] = this.state[e4][o3];
              o2[e4] = i3;
            }
            for (const e4 in this.deletedStates) {
              this.state[e4] = this.state[e4] || {};
              const i3 = {};
              if (null === this.deletedStates[e4])
                for (const t2 in this.state[e4])
                  i3[t2] = {}, this.state[e4][t2] = {};
              else
                for (const t2 in this.deletedStates[e4]) {
                  if (null === this.deletedStates[e4][t2])
                    this.state[e4][t2] = {};
                  else
                    for (const i4 of Object.keys(this.deletedStates[e4][t2]))
                      delete this.state[e4][t2][i4];
                  i3[t2] = this.state[e4][t2];
                }
              o2[e4] = o2[e4] || {}, t.extend(o2[e4], i3);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o2).length)
              for (const t2 in e3)
                e3[t2].setFeatureState(o2, i2);
          }
        }
        class Z extends t.Evented {
          constructor(e3, i2, o2) {
            super(), this.id = e3, this.dispatcher = o2, this.on("data", (t2) => {
              "source" === t2.dataType && "metadata" === t2.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t2.dataType && "content" === t2.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
            }), this.on("dataloading", () => {
              this._sourceErrored = false;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = function(e4, i3, o3, a2) {
              const s2 = new k[i3.type](e4, i3, o3, a2);
              if (s2.id !== e4)
                throw new Error(`Expected Source id to be ${e4} instead of ${s2.id}`);
              return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], s2), s2;
            }(e3, i2, o2, this), this._tiles = {}, this._cache = new N(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new G();
          }
          onAdd(t2) {
            this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t2);
          }
          onRemove(t2) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            for (const t2 in this._tiles) {
              const e3 = this._tiles[t2];
              if ("loaded" !== e3.state && "errored" !== e3.state)
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const t2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(t2, e3) {
            return this._source.loadTile(t2, e3);
          }
          _unloadTile(t2) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t2, () => {
              });
          }
          _abortTile(e3) {
            this._source.abortTile && this._source.abortTile(e3, () => {
            }), this._source.fire(new t.Event("dataabort", { tile: e3, coord: e3.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e3 in this._tiles) {
              const i2 = this._tiles[e3];
              i2.upload(t2), i2.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((t2) => t2.tileID).sort(q).map((t2) => t2.key);
          }
          getRenderableIds(e3) {
            const i2 = [];
            for (const t2 in this._tiles)
              this._isIdRenderable(t2, e3) && i2.push(this._tiles[t2]);
            return e3 ? i2.sort((e4, i3) => {
              const o2 = e4.tileID, a2 = i3.tileID, s2 = new t.pointGeometry(o2.canonical.x, o2.canonical.y)._rotate(this.transform.angle), r2 = new t.pointGeometry(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle);
              return o2.overscaledZ - a2.overscaledZ || r2.y - s2.y || r2.x - s2.x;
            }).map((t2) => t2.tileID.key) : i2.map((t2) => t2.tileID).sort(q).map((t2) => t2.key);
          }
          hasRenderableParent(t2) {
            const e3 = this.findLoadedParent(t2, 0);
            return !!e3 && this._isIdRenderable(e3.tileID.key);
          }
          _isIdRenderable(t2, e3) {
            return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e3 || !this._tiles[t2].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t2 in this._tiles)
                "errored" !== this._tiles[t2].state && this._reloadTile(t2, "reloading");
            }
          }
          _reloadTile(t2, e3) {
            const i2 = this._tiles[t2];
            i2 && ("loading" !== i2.state && (i2.state = e3), this._loadTile(i2, this._tileLoaded.bind(this, i2, t2, e3)));
          }
          _tileLoaded(e3, i2, o2, a2) {
            if (a2)
              return e3.state = "errored", void (404 !== a2.status ? this._source.fire(new t.ErrorEvent(a2, { tile: e3 })) : this.update(this.transform));
            e3.timeAdded = t.exported.now(), "expired" === o2 && (e3.refreshedUponExpiration = true), this._setTileReloadTimer(i2, e3), "raster-dem" === this.getSource().type && e3.dem && this._backfillDEM(e3), this._state.initializeTileState(e3, this.map ? this.map.painter : null), e3.aborted || this._source.fire(new t.Event("data", { dataType: "source", tile: e3, coord: e3.tileID }));
          }
          _backfillDEM(t2) {
            const e3 = this.getRenderableIds();
            for (let o2 = 0; o2 < e3.length; o2++) {
              const a2 = e3[o2];
              if (t2.neighboringTiles && t2.neighboringTiles[a2]) {
                const e4 = this.getTileByID(a2);
                i2(t2, e4), i2(e4, t2);
              }
            }
            function i2(t3, e4) {
              t3.needsHillshadePrepare = true;
              let i3 = e4.tileID.canonical.x - t3.tileID.canonical.x;
              const o2 = e4.tileID.canonical.y - t3.tileID.canonical.y, a2 = Math.pow(2, t3.tileID.canonical.z), s2 = e4.tileID.key;
              0 === i3 && 0 === o2 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + a2) ? i3 += a2 : 1 === Math.abs(i3 - a2) && (i3 -= a2)), e4.dem && t3.dem && (t3.dem.backfillBorder(e4.dem, i3, o2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
            }
          }
          getTile(t2) {
            return this.getTileByID(t2.key);
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          _retainLoadedChildren(t2, e3, i2, o2) {
            for (const a2 in this._tiles) {
              let s2 = this._tiles[a2];
              if (o2[a2] || !s2.hasData() || s2.tileID.overscaledZ <= e3 || s2.tileID.overscaledZ > i2)
                continue;
              let r2 = s2.tileID;
              for (; s2 && s2.tileID.overscaledZ > e3 + 1; ) {
                const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
                s2 = this._tiles[t3.key], s2 && s2.hasData() && (r2 = t3);
              }
              let n2 = r2;
              for (; n2.overscaledZ > e3; )
                if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                  o2[r2.key] = r2;
                  break;
                }
            }
          }
          findLoadedParent(t2, e3) {
            if (t2.key in this._loadedParentTiles) {
              const i2 = this._loadedParentTiles[t2.key];
              return i2 && i2.tileID.overscaledZ >= e3 ? i2 : null;
            }
            for (let i2 = t2.overscaledZ - 1; i2 >= e3; i2--) {
              const e4 = t2.scaledTo(i2), o2 = this._getLoadedTile(e4);
              if (o2)
                return o2;
            }
          }
          _getLoadedTile(t2) {
            const e3 = this._tiles[t2.key];
            return e3 && e3.hasData() ? e3 : this._cache.getByKey(t2.wrapped().key);
          }
          updateCacheSize(t2) {
            const e3 = Math.ceil(t2.width / this._source.tileSize) + 1, i2 = Math.ceil(t2.height / this._source.tileSize) + 1, o2 = Math.floor(e3 * i2 * 5), a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o2) : o2;
            this._cache.setMaxSize(a2);
          }
          handleWrapJump(t2) {
            const e3 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
            if (this._prevLng = t2, e3) {
              const t3 = {};
              for (const i2 in this._tiles) {
                const o2 = this._tiles[i2];
                o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + e3), t3[o2.tileID.key] = o2;
              }
              this._tiles = t3;
              for (const t4 in this._timers)
                clearTimeout(this._timers[t4]), delete this._timers[t4];
              for (const t4 in this._tiles)
                this._setTileReloadTimer(t4, this._tiles[t4]);
            }
          }
          update(e3) {
            if (this.transform = e3, !this._sourceLoaded || this._paused)
              return;
            let i2;
            this.updateCacheSize(e3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? i2 = e3.getVisibleUnwrappedCoordinates(this._source.tileID).map((e4) => new t.OverscaledTileID(e4.canonical.z, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y)) : (i2 = e3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (i2 = i2.filter((t2) => this._source.hasTile(t2)))) : i2 = [];
            const o2 = e3.coveringZoomLevel(this._source), a2 = Math.max(o2 - Z.maxOverzooming, this._source.minzoom), s2 = Math.max(o2 + Z.maxUnderzooming, this._source.minzoom), r2 = this._updateRetainedTiles(i2, o2);
            if (V(this._source.type)) {
              const e4 = {}, i3 = {}, n3 = Object.keys(r2);
              for (const o3 of n3) {
                const s3 = r2[o3], n4 = this._tiles[o3];
                if (!n4 || n4.fadeEndTime && n4.fadeEndTime <= t.exported.now())
                  continue;
                const l2 = this.findLoadedParent(s3, a2);
                l2 && (this._addTile(l2.tileID), e4[l2.tileID.key] = l2.tileID), i3[o3] = s3;
              }
              this._retainLoadedChildren(i3, o2, s2, r2);
              for (const t2 in e4)
                r2[t2] || (this._coveredTiles[t2] = true, r2[t2] = e4[t2]);
            }
            for (const t2 in r2)
              this._tiles[t2].clearFadeHold();
            const n2 = t.keysDifference(this._tiles, r2);
            for (const t2 of n2) {
              const e4 = this._tiles[t2];
              e4.hasSymbolBuckets && !e4.holdingForFade() ? e4.setHoldDuration(this.map._fadeDuration) : e4.hasSymbolBuckets && !e4.symbolFadeFinished() || this._removeTile(t2);
            }
            this._updateLoadedParentTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const t2 in this._tiles)
              this._tiles[t2].holdingForFade() && this._removeTile(t2);
          }
          _updateRetainedTiles(t2, e3) {
            const i2 = {}, o2 = {}, a2 = Math.max(e3 - Z.maxOverzooming, this._source.minzoom), s2 = Math.max(e3 + Z.maxUnderzooming, this._source.minzoom), r2 = {};
            for (const o3 of t2) {
              const t3 = this._addTile(o3);
              i2[o3.key] = o3, t3.hasData() || e3 < this._source.maxzoom && (r2[o3.key] = o3);
            }
            this._retainLoadedChildren(r2, e3, s2, i2);
            for (const s3 of t2) {
              let t3 = this._tiles[s3.key];
              if (t3.hasData())
                continue;
              if (e3 + 1 > this._source.maxzoom) {
                const t4 = s3.children(this._source.maxzoom)[0], e4 = this.getTile(t4);
                if (e4 && e4.hasData()) {
                  i2[t4.key] = t4;
                  continue;
                }
              } else {
                const t4 = s3.children(this._source.maxzoom);
                if (i2[t4[0].key] && i2[t4[1].key] && i2[t4[2].key] && i2[t4[3].key])
                  continue;
              }
              let r3 = t3.wasRequested();
              for (let e4 = s3.overscaledZ - 1; e4 >= a2; --e4) {
                const a3 = s3.scaledTo(e4);
                if (o2[a3.key])
                  break;
                if (o2[a3.key] = true, t3 = this.getTile(a3), !t3 && r3 && (t3 = this._addTile(a3)), t3 && (i2[a3.key] = a3, r3 = t3.wasRequested(), t3.hasData()))
                  break;
              }
            }
            return i2;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t2 in this._tiles) {
              const e3 = [];
              let i2, o2 = this._tiles[t2].tileID;
              for (; o2.overscaledZ > 0; ) {
                if (o2.key in this._loadedParentTiles) {
                  i2 = this._loadedParentTiles[o2.key];
                  break;
                }
                e3.push(o2.key);
                const t3 = o2.scaledTo(o2.overscaledZ - 1);
                if (i2 = this._getLoadedTile(t3), i2)
                  break;
                o2 = t3;
              }
              for (const t3 of e3)
                this._loadedParentTiles[t3] = i2;
            }
          }
          _addTile(e3) {
            let i2 = this._tiles[e3.key];
            if (i2)
              return i2;
            i2 = this._cache.getAndRemove(e3), i2 && (this._setTileReloadTimer(e3.key, i2), i2.tileID = e3, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[e3.key] && (clearTimeout(this._cacheTimers[e3.key]), delete this._cacheTimers[e3.key], this._setTileReloadTimer(e3.key, i2)));
            const o2 = i2;
            return i2 || (i2 = new U(e3, this._source.tileSize * e3.overscaleFactor()), this._loadTile(i2, this._tileLoaded.bind(this, i2, e3.key, i2.state))), i2.uses++, this._tiles[e3.key] = i2, o2 || this._source.fire(new t.Event("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
          }
          _setTileReloadTimer(t2, e3) {
            t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
            const i2 = e3.getExpiryTimeout();
            i2 && (this._timers[t2] = setTimeout(() => {
              this._reloadTile(t2, "expired"), delete this._timers[t2];
            }, i2));
          }
          _removeTile(t2) {
            const e3 = this._tiles[t2];
            e3 && (e3.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t2 in this._tiles)
              this._removeTile(t2);
            this._cache.reset();
          }
          tilesIn(e3, i2, o2) {
            const a2 = [], s2 = this.transform;
            if (!s2)
              return a2;
            const r2 = o2 ? s2.getCameraQueryGeometry(e3) : e3, n2 = e3.map((t2) => s2.pointCoordinate(t2)), l2 = r2.map((t2) => s2.pointCoordinate(t2)), c2 = this.getIds();
            let h2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, m2 = -1 / 0;
            for (const t2 of l2)
              h2 = Math.min(h2, t2.x), u2 = Math.min(u2, t2.y), d2 = Math.max(d2, t2.x), m2 = Math.max(m2, t2.y);
            for (let e4 = 0; e4 < c2.length; e4++) {
              const o3 = this._tiles[c2[e4]];
              if (o3.holdingForFade())
                continue;
              const r3 = o3.tileID, _2 = Math.pow(2, s2.zoom - o3.tileID.overscaledZ), p2 = i2 * o3.queryPadding * t.EXTENT / o3.tileSize / _2, f2 = [r3.getTilePoint(new t.MercatorCoordinate(h2, u2)), r3.getTilePoint(new t.MercatorCoordinate(d2, m2))];
              if (f2[0].x - p2 < t.EXTENT && f2[0].y - p2 < t.EXTENT && f2[1].x + p2 >= 0 && f2[1].y + p2 >= 0) {
                const t2 = n2.map((t3) => r3.getTilePoint(t3)), e5 = l2.map((t3) => r3.getTilePoint(t3));
                a2.push({ tile: o3, tileID: r3, queryGeometry: t2, cameraQueryGeometry: e5, scale: _2 });
              }
            }
            return a2;
          }
          getVisibleCoordinates(t2) {
            const e3 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
            for (const t3 of e3)
              t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
            return e3;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (V(this._source.type))
              for (const e3 in this._tiles) {
                const i2 = this._tiles[e3];
                if (void 0 !== i2.fadeEndTime && i2.fadeEndTime >= t.exported.now())
                  return true;
              }
            return false;
          }
          setFeatureState(t2, e3, i2) {
            this._state.updateState(t2 = t2 || "_geojsonTileLayer", e3, i2);
          }
          removeFeatureState(t2, e3, i2) {
            this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e3, i2);
          }
          getFeatureState(t2, e3) {
            return this._state.getState(t2 = t2 || "_geojsonTileLayer", e3);
          }
          setDependencies(t2, e3, i2) {
            const o2 = this._tiles[t2];
            o2 && o2.setDependencies(e3, i2);
          }
          reloadTilesForDependencies(t2, e3) {
            for (const i2 in this._tiles)
              this._tiles[i2].hasDependency(t2, e3) && this._reloadTile(i2, "reloading");
            this._cache.filter((i2) => !i2.hasDependency(t2, e3));
          }
        }
        function q(t2, e3) {
          const i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), o2 = Math.abs(2 * e3.wrap) - +(e3.wrap < 0);
          return t2.overscaledZ - e3.overscaledZ || o2 - i2 || e3.canonical.y - t2.canonical.y || e3.canonical.x - t2.canonical.x;
        }
        function V(t2) {
          return "raster" === t2 || "image" === t2 || "video" === t2;
        }
        Z.maxOverzooming = 10, Z.maxUnderzooming = 3;
        const j = "mapboxgl_preloaded_worker_pool";
        class $ {
          constructor() {
            this.active = {};
          }
          acquire(t2) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < $.workerCount; )
                this.workers.push(new Worker(va.workerUrl));
            return this.active[t2] = true, this.workers.slice();
          }
          release(t2) {
            delete this.active[t2], 0 === this.numActive() && (this.workers.forEach((t3) => {
              t3.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[j];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const W = Math.floor(t.exported.hardwareConcurrency / 2);
        let X;
        function H() {
          return X || (X = new $()), X;
        }
        function K(e3, i2) {
          const o2 = {};
          for (const t2 in e3)
            "ref" !== t2 && (o2[t2] = e3[t2]);
          return t.refProperties.forEach((t2) => {
            t2 in i2 && (o2[t2] = i2[t2]);
          }), o2;
        }
        function Y(t2) {
          t2 = t2.slice();
          const e3 = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < t2.length; i2++)
            e3[t2[i2].id] = t2[i2];
          for (let i2 = 0; i2 < t2.length; i2++)
            "ref" in t2[i2] && (t2[i2] = K(t2[i2], e3[t2[i2].ref]));
          return t2;
        }
        $.workerCount = Math.max(Math.min(W, 6), 1);
        const J = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
        function Q(t2, e3, i2) {
          i2.push({ command: J.addSource, args: [t2, e3[t2]] });
        }
        function tt(t2, e3, i2) {
          e3.push({ command: J.removeSource, args: [t2] }), i2[t2] = true;
        }
        function et(t2, e3, i2, o2) {
          tt(t2, i2, o2), Q(t2, e3, i2);
        }
        function it(t2, e3, i2) {
          let o2;
          for (o2 in t2[i2])
            if (Object.prototype.hasOwnProperty.call(t2[i2], o2) && "data" !== o2 && !a(t2[i2][o2], e3[i2][o2]))
              return false;
          for (o2 in e3[i2])
            if (Object.prototype.hasOwnProperty.call(e3[i2], o2) && "data" !== o2 && !a(t2[i2][o2], e3[i2][o2]))
              return false;
          return true;
        }
        function ot(t2, e3, i2, o2, s2, r2) {
          let n2;
          for (n2 in e3 = e3 || {}, t2 = t2 || {})
            Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e3[n2]) || i2.push({ command: r2, args: [o2, n2, e3[n2], s2] }));
          for (n2 in e3)
            Object.prototype.hasOwnProperty.call(e3, n2) && !Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e3[n2]) || i2.push({ command: r2, args: [o2, n2, e3[n2], s2] }));
        }
        function at(t2) {
          return t2.id;
        }
        function st(t2, e3) {
          return t2[e3.id] = e3, t2;
        }
        class rt {
          constructor(t2, e3) {
            this.reset(t2, e3);
          }
          reset(t2, e3) {
            this.points = t2 || [], this._distances = [0];
            for (let t3 = 1; t3 < this.points.length; t3++)
              this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e3) {
            if (1 === this.points.length)
              return this.points[0];
            e3 = t.clamp(e3, 0, 1);
            let i2 = 1, o2 = this._distances[i2];
            const a2 = e3 * this.paddedLength + this.padding;
            for (; o2 < a2 && i2 < this._distances.length; )
              o2 = this._distances[++i2];
            const s2 = i2 - 1, r2 = this._distances[s2], n2 = o2 - r2, l2 = n2 > 0 ? (a2 - r2) / n2 : 0;
            return this.points[s2].mult(1 - l2).add(this.points[i2].mult(l2));
          }
        }
        function nt(t2, e3) {
          let i2 = true;
          return "always" === t2 || "never" !== t2 && "never" !== e3 || (i2 = false), i2;
        }
        class lt {
          constructor(t2, e3, i2) {
            const o2 = this.boxCells = [], a2 = this.circleCells = [];
            this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e3 / i2);
            for (let t3 = 0; t3 < this.xCellCount * this.yCellCount; t3++)
              o2.push([]), a2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e3, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e3, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t2, e3, i2, o2, a2) {
            this._forEachCell(e3, i2, o2, a2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e3), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(a2);
          }
          insertCircle(t2, e3, i2, o2) {
            this._forEachCell(e3 - o2, i2 - o2, e3 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e3), this.circles.push(i2), this.circles.push(o2);
          }
          _insertBoxCell(t2, e3, i2, o2, a2, s2) {
            this.boxCells[a2].push(s2);
          }
          _insertCircleCell(t2, e3, i2, o2, a2, s2) {
            this.circleCells[a2].push(s2);
          }
          _query(t2, e3, i2, o2, a2, s2, r2) {
            if (i2 < 0 || t2 > this.width || o2 < 0 || e3 > this.height)
              return [];
            const n2 = [];
            if (t2 <= 0 && e3 <= 0 && this.width <= i2 && this.height <= o2) {
              if (a2)
                return [{ key: null, x1: t2, y1: e3, x2: i2, y2: o2 }];
              for (let t3 = 0; t3 < this.boxKeys.length; t3++)
                n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
              for (let t3 = 0; t3 < this.circleKeys.length; t3++) {
                const e4 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], o3 = this.circles[3 * t3 + 2];
                n2.push({ key: this.circleKeys[t3], x1: e4 - o3, y1: i3 - o3, x2: e4 + o3, y2: i3 + o3 });
              }
            } else
              this._forEachCell(t2, e3, i2, o2, this._queryCell, n2, { hitTest: a2, overlapMode: s2, seenUids: { box: {}, circle: {} } }, r2);
            return n2;
          }
          query(t2, e3, i2, o2) {
            return this._query(t2, e3, i2, o2, false, null);
          }
          hitTest(t2, e3, i2, o2, a2, s2) {
            return this._query(t2, e3, i2, o2, true, a2, s2).length > 0;
          }
          hitTestCircle(t2, e3, i2, o2, a2) {
            const s2 = t2 - i2, r2 = t2 + i2, n2 = e3 - i2, l2 = e3 + i2;
            if (r2 < 0 || s2 > this.width || l2 < 0 || n2 > this.height)
              return false;
            const c2 = [];
            return this._forEachCell(s2, n2, r2, l2, this._queryCellCircle, c2, { hitTest: true, overlapMode: o2, circle: { x: t2, y: e3, radius: i2 }, seenUids: { box: {}, circle: {} } }, a2), c2.length > 0;
          }
          _queryCell(t2, e3, i2, o2, a2, s2, r2, n2) {
            const { seenUids: l2, hitTest: c2, overlapMode: h2 } = r2, u2 = this.boxCells[a2];
            if (null !== u2) {
              const a3 = this.bboxes;
              for (const r3 of u2)
                if (!l2.box[r3]) {
                  l2.box[r3] = true;
                  const u3 = 4 * r3, d3 = this.boxKeys[r3];
                  if (t2 <= a3[u3 + 2] && e3 <= a3[u3 + 3] && i2 >= a3[u3 + 0] && o2 >= a3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !nt(h2, d3.overlapMode)) && (s2.push({ key: d3, x1: a3[u3], y1: a3[u3 + 1], x2: a3[u3 + 2], y2: a3[u3 + 3] }), c2))
                    return true;
                }
            }
            const d2 = this.circleCells[a2];
            if (null !== d2) {
              const a3 = this.circles;
              for (const r3 of d2)
                if (!l2.circle[r3]) {
                  l2.circle[r3] = true;
                  const u3 = 3 * r3, d3 = this.circleKeys[r3];
                  if (this._circleAndRectCollide(a3[u3], a3[u3 + 1], a3[u3 + 2], t2, e3, i2, o2) && (!n2 || n2(d3)) && (!c2 || !nt(h2, d3.overlapMode))) {
                    const t3 = a3[u3], e4 = a3[u3 + 1], i3 = a3[u3 + 2];
                    if (s2.push({ key: d3, x1: t3 - i3, y1: e4 - i3, x2: t3 + i3, y2: e4 + i3 }), c2)
                      return true;
                  }
                }
            }
            return false;
          }
          _queryCellCircle(t2, e3, i2, o2, a2, s2, r2, n2) {
            const { circle: l2, seenUids: c2, overlapMode: h2 } = r2, u2 = this.boxCells[a2];
            if (null !== u2) {
              const t3 = this.bboxes;
              for (const e4 of u2)
                if (!c2.box[e4]) {
                  c2.box[e4] = true;
                  const i3 = 4 * e4, o3 = this.boxKeys[e4];
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(o3)) && !nt(h2, o3.overlapMode))
                    return s2.push(true), true;
                }
            }
            const d2 = this.circleCells[a2];
            if (null !== d2) {
              const t3 = this.circles;
              for (const e4 of d2)
                if (!c2.circle[e4]) {
                  c2.circle[e4] = true;
                  const i3 = 3 * e4, o3 = this.circleKeys[e4];
                  if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(o3)) && !nt(h2, o3.overlapMode))
                    return s2.push(true), true;
                }
            }
          }
          _forEachCell(t2, e3, i2, o2, a2, s2, r2, n2) {
            const l2 = this._convertToXCellCoord(t2), c2 = this._convertToYCellCoord(e3), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
            for (let d2 = l2; d2 <= h2; d2++)
              for (let l3 = c2; l3 <= u2; l3++)
                if (a2.call(this, t2, e3, i2, o2, this.xCellCount * l3 + d2, s2, r2, n2))
                  return;
          }
          _convertToXCellCoord(t2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
          }
          _convertToYCellCoord(t2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
          }
          _circlesCollide(t2, e3, i2, o2, a2, s2) {
            const r2 = o2 - t2, n2 = a2 - e3, l2 = i2 + s2;
            return l2 * l2 > r2 * r2 + n2 * n2;
          }
          _circleAndRectCollide(t2, e3, i2, o2, a2, s2, r2) {
            const n2 = (s2 - o2) / 2, l2 = Math.abs(t2 - (o2 + n2));
            if (l2 > n2 + i2)
              return false;
            const c2 = (r2 - a2) / 2, h2 = Math.abs(e3 - (a2 + c2));
            if (h2 > c2 + i2)
              return false;
            if (l2 <= n2 || h2 <= c2)
              return true;
            const u2 = l2 - n2, d2 = h2 - c2;
            return u2 * u2 + d2 * d2 <= i2 * i2;
          }
        }
        function ct(e3, i2, o2, a2, s2) {
          const r2 = t.create();
          return i2 ? (t.scale(r2, r2, [1 / s2, 1 / s2, 1]), o2 || t.rotateZ(r2, r2, a2.angle)) : t.multiply(r2, a2.labelPlaneMatrix, e3), r2;
        }
        function ht(e3, i2, o2, a2, s2) {
          if (i2) {
            const i3 = t.clone(e3);
            return t.scale(i3, i3, [s2, s2, 1]), o2 || t.rotateZ(i3, i3, -a2.angle), i3;
          }
          return a2.glCoordMatrix;
        }
        function ut(e3, i2) {
          const o2 = [e3.x, e3.y, 0, 1];
          wt(o2, o2, i2);
          const a2 = o2[3];
          return { point: new t.pointGeometry(o2[0] / a2, o2[1] / a2), signedDistanceFromCamera: a2 };
        }
        function dt(t2, e3) {
          return 0.5 + t2 / e3 * 0.5;
        }
        function mt(t2, e3) {
          const i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
          return i2 >= -e3[0] && i2 <= e3[0] && o2 >= -e3[1] && o2 <= e3[1];
        }
        function _t(e3, i2, o2, a2, s2, r2, n2, l2, c2) {
          const h2 = a2 ? e3.textSizeData : e3.iconSizeData, u2 = t.evaluateSizeForZoom(h2, o2.transform.zoom), d2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], m2 = a2 ? e3.text.dynamicLayoutVertexArray : e3.icon.dynamicLayoutVertexArray;
          m2.clear();
          const _2 = e3.lineVertexArray, p2 = a2 ? e3.text.placedSymbolArray : e3.icon.placedSymbolArray, f2 = o2.transform.width / o2.transform.height;
          let g2 = false;
          for (let a3 = 0; a3 < p2.length; a3++) {
            const x2 = p2.get(a3);
            if (x2.hidden || x2.writingMode === t.WritingMode.vertical && !g2) {
              bt(x2.numGlyphs, m2);
              continue;
            }
            g2 = false;
            const v2 = [x2.anchorX, x2.anchorY, 0, 1];
            if (t.transformMat4(v2, v2, i2), !mt(v2, d2)) {
              bt(x2.numGlyphs, m2);
              continue;
            }
            const y2 = dt(o2.transform.cameraToCenterDistance, v2[3]), b2 = t.evaluateSizeForFeature(h2, u2, x2), w2 = n2 ? b2 / y2 : b2 * y2, T2 = new t.pointGeometry(x2.anchorX, x2.anchorY), E2 = ut(T2, s2).point, I2 = {}, S2 = gt(x2, w2, false, l2, i2, s2, r2, e3.glyphOffsetArray, _2, m2, E2, T2, I2, f2, c2);
            g2 = S2.useVertical, (S2.notEnoughRoom || g2 || S2.needsFlipping && gt(x2, w2, true, l2, i2, s2, r2, e3.glyphOffsetArray, _2, m2, E2, T2, I2, f2, c2).notEnoughRoom) && bt(x2.numGlyphs, m2);
          }
          a2 ? e3.text.dynamicLayoutVertexBuffer.updateData(m2) : e3.icon.dynamicLayoutVertexBuffer.updateData(m2);
        }
        function pt(t2, e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2) {
          const d2 = n2.glyphStartIndex + n2.numGlyphs, m2 = n2.lineStartIndex, _2 = n2.lineStartIndex + n2.lineLength, p2 = e3.getoffsetX(n2.glyphStartIndex), f2 = e3.getoffsetX(d2 - 1), g2 = vt(t2 * p2, i2, o2, a2, s2, r2, n2.segment, m2, _2, l2, c2, h2, u2);
          if (!g2)
            return null;
          const x2 = vt(t2 * f2, i2, o2, a2, s2, r2, n2.segment, m2, _2, l2, c2, h2, u2);
          return x2 ? { first: g2, last: x2 } : null;
        }
        function ft(e3, i2, o2, a2) {
          return e3 === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * a2 ? { useVertical: true } : (e3 === t.WritingMode.vertical ? i2.y < o2.y : i2.x > o2.x) ? { needsFlipping: true } : null;
        }
        function gt(e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, m2, _2, p2) {
          const f2 = i2 / 24, g2 = e3.lineOffsetX * f2, x2 = e3.lineOffsetY * f2;
          let v2;
          if (e3.numGlyphs > 1) {
            const t2 = e3.glyphStartIndex + e3.numGlyphs, i3 = e3.lineStartIndex, s3 = e3.lineStartIndex + e3.lineLength, h3 = pt(f2, l2, g2, x2, o2, u2, d2, e3, c2, r2, m2, p2);
            if (!h3)
              return { notEnoughRoom: true };
            const y2 = ut(h3.first.point, n2).point, b2 = ut(h3.last.point, n2).point;
            if (a2 && !o2) {
              const t3 = ft(e3.writingMode, y2, b2, _2);
              if (t3)
                return t3;
            }
            v2 = [h3.first];
            for (let a3 = e3.glyphStartIndex + 1; a3 < t2 - 1; a3++)
              v2.push(vt(f2 * l2.getoffsetX(a3), g2, x2, o2, u2, d2, e3.segment, i3, s3, c2, r2, m2, p2));
            v2.push(h3.last);
          } else {
            if (a2 && !o2) {
              const i4 = ut(d2, s2).point, o3 = e3.lineStartIndex + e3.segment + 1, a3 = new t.pointGeometry(c2.getx(o3), c2.gety(o3)), r3 = ut(a3, s2), n3 = r3.signedDistanceFromCamera > 0 ? r3.point : xt(d2, a3, i4, 1, s2), l3 = ft(e3.writingMode, i4, n3, _2);
              if (l3)
                return l3;
            }
            const i3 = vt(f2 * l2.getoffsetX(e3.glyphStartIndex), g2, x2, o2, u2, d2, e3.segment, e3.lineStartIndex, e3.lineStartIndex + e3.lineLength, c2, r2, m2, p2);
            if (!i3)
              return { notEnoughRoom: true };
            v2 = [i3];
          }
          for (const e4 of v2)
            t.addDynamicAttributes(h2, e4.point, e4.angle);
          return {};
        }
        function xt(t2, e3, i2, o2, a2) {
          const s2 = ut(t2.add(t2.sub(e3)._unit()), a2).point, r2 = i2.sub(s2);
          return i2.add(r2._mult(o2 / r2.mag()));
        }
        function vt(e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, m2) {
          const _2 = a2 ? e3 - i2 : e3 + i2;
          let p2 = _2 > 0 ? 1 : -1, f2 = 0;
          a2 && (p2 *= -1, f2 = Math.PI), p2 < 0 && (f2 += Math.PI);
          let g2 = p2 > 0 ? l2 + n2 : l2 + n2 + 1, x2 = s2, v2 = s2, y2 = 0, b2 = 0;
          const w2 = Math.abs(_2), T2 = [];
          for (; y2 + b2 <= w2; ) {
            if (g2 += p2, g2 < l2 || g2 >= c2)
              return null;
            if (v2 = x2, T2.push(x2), x2 = d2[g2], void 0 === x2) {
              const e4 = new t.pointGeometry(h2.getx(g2), h2.gety(g2)), i3 = ut(e4, u2);
              if (i3.signedDistanceFromCamera > 0)
                x2 = d2[g2] = i3.point;
              else {
                const i4 = g2 - p2;
                x2 = xt(0 === y2 ? r2 : new t.pointGeometry(h2.getx(i4), h2.gety(i4)), e4, v2, w2 - y2 + 1, u2);
              }
            }
            y2 += b2, b2 = v2.dist(x2);
          }
          const E2 = (w2 - y2) / b2, I2 = x2.sub(v2), S2 = I2.mult(E2)._add(v2);
          S2._add(I2._unit()._perp()._mult(o2 * p2));
          const C2 = f2 + Math.atan2(x2.y - v2.y, x2.x - v2.x);
          return T2.push(S2), { point: S2, angle: m2 ? C2 : 0, path: T2 };
        }
        const yt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function bt(t2, e3) {
          for (let i2 = 0; i2 < t2; i2++) {
            const t3 = e3.length;
            e3.resize(t3 + 4), e3.float32.set(yt, 3 * t3);
          }
        }
        function wt(t2, e3, i2) {
          const o2 = e3[0], a2 = e3[1];
          return t2[0] = i2[0] * o2 + i2[4] * a2 + i2[12], t2[1] = i2[1] * o2 + i2[5] * a2 + i2[13], t2[3] = i2[3] * o2 + i2[7] * a2 + i2[15], t2;
        }
        const Tt = 100;
        class Et {
          constructor(t2, e3 = new lt(t2.width + 200, t2.height + 200, 25), i2 = new lt(t2.width + 200, t2.height + 200, 25)) {
            this.transform = t2, this.grid = e3, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + Tt, this.screenBottomBoundary = t2.height + Tt, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200;
          }
          placeCollisionBox(t2, e3, i2, o2, a2) {
            const s2 = this.projectAndGetPerspectiveRatio(o2, t2.anchorPointX, t2.anchorPointY), r2 = i2 * s2.perspectiveRatio, n2 = t2.x1 * r2 + s2.point.x, l2 = t2.y1 * r2 + s2.point.y, c2 = t2.x2 * r2 + s2.point.x, h2 = t2.y2 * r2 + s2.point.y;
            return !this.isInsideGrid(n2, l2, c2, h2) || "always" !== e3 && this.grid.hitTest(n2, l2, c2, h2, e3, a2) ? { box: [], offscreen: false } : { box: [n2, l2, c2, h2], offscreen: this.isOffscreen(n2, l2, c2, h2) };
          }
          placeCollisionCircles(e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, m2) {
            const _2 = [], p2 = new t.pointGeometry(i2.anchorX, i2.anchorY), f2 = ut(p2, r2), g2 = dt(this.transform.cameraToCenterDistance, f2.signedDistanceFromCamera), x2 = (h2 ? s2 / g2 : s2 * g2) / t.ONE_EM, v2 = ut(p2, n2).point, y2 = pt(x2, a2, i2.lineOffsetX * x2, i2.lineOffsetY * x2, false, v2, p2, i2, o2, n2, {}, false);
            let b2 = false, w2 = false, T2 = true;
            if (y2) {
              const i3 = 0.5 * d2 * g2 + m2, o3 = new t.pointGeometry(-100, -100), a3 = new t.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), s3 = new rt(), r3 = y2.first, n3 = y2.last;
              let h3 = [];
              for (let t2 = r3.path.length - 1; t2 >= 1; t2--)
                h3.push(r3.path[t2]);
              for (let t2 = 1; t2 < n3.path.length; t2++)
                h3.push(n3.path[t2]);
              const p3 = 2.5 * i3;
              if (l2) {
                const t2 = h3.map((t3) => ut(t3, l2));
                h3 = t2.some((t3) => t3.signedDistanceFromCamera <= 0) ? [] : t2.map((t3) => t3.point);
              }
              let f3 = [];
              if (h3.length > 0) {
                const e4 = h3[0].clone(), i4 = h3[0].clone();
                for (let t2 = 1; t2 < h3.length; t2++)
                  e4.x = Math.min(e4.x, h3[t2].x), e4.y = Math.min(e4.y, h3[t2].y), i4.x = Math.max(i4.x, h3[t2].x), i4.y = Math.max(i4.y, h3[t2].y);
                f3 = e4.x >= o3.x && i4.x <= a3.x && e4.y >= o3.y && i4.y <= a3.y ? [h3] : i4.x < o3.x || e4.x > a3.x || i4.y < o3.y || e4.y > a3.y ? [] : t.clipLine([h3], o3.x, o3.y, a3.x, a3.y);
              }
              for (const t2 of f3) {
                s3.reset(t2, 0.25 * i3);
                let o4 = 0;
                o4 = s3.length <= 0.5 * i3 ? 1 : Math.ceil(s3.paddedLength / p3) + 1;
                for (let t3 = 0; t3 < o4; t3++) {
                  const a4 = t3 / Math.max(o4 - 1, 1), r4 = s3.lerp(a4), n4 = r4.x + Tt, l3 = r4.y + Tt;
                  _2.push(n4, l3, i3, 0);
                  const h4 = n4 - i3, d3 = l3 - i3, m3 = n4 + i3, p4 = l3 + i3;
                  if (T2 = T2 && this.isOffscreen(h4, d3, m3, p4), w2 = w2 || this.isInsideGrid(h4, d3, m3, p4), "always" !== e3 && this.grid.hitTestCircle(n4, l3, i3, e3, u2) && (b2 = true, !c2))
                    return { circles: [], offscreen: false, collisionDetected: b2 };
                }
              }
            }
            return { circles: !c2 && b2 || !w2 ? [] : _2, offscreen: T2, collisionDetected: b2 };
          }
          queryRenderedSymbols(e3) {
            if (0 === e3.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            const i2 = [];
            let o2 = 1 / 0, a2 = 1 / 0, s2 = -1 / 0, r2 = -1 / 0;
            for (const n3 of e3) {
              const e4 = new t.pointGeometry(n3.x + Tt, n3.y + Tt);
              o2 = Math.min(o2, e4.x), a2 = Math.min(a2, e4.y), s2 = Math.max(s2, e4.x), r2 = Math.max(r2, e4.y), i2.push(e4);
            }
            const n2 = this.grid.query(o2, a2, s2, r2).concat(this.ignoredGrid.query(o2, a2, s2, r2)), l2 = {}, c2 = {};
            for (const e4 of n2) {
              const o3 = e4.key;
              if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                continue;
              const a3 = [new t.pointGeometry(e4.x1, e4.y1), new t.pointGeometry(e4.x2, e4.y1), new t.pointGeometry(e4.x2, e4.y2), new t.pointGeometry(e4.x1, e4.y2)];
              t.polygonIntersectsPolygon(i2, a3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
            }
            return c2;
          }
          insertCollisionBox(t2, e3, i2, o2, a2, s2) {
            (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: o2, featureIndex: a2, collisionGroupID: s2, overlapMode: e3 }, t2[0], t2[1], t2[2], t2[3]);
          }
          insertCollisionCircles(t2, e3, i2, o2, a2, s2) {
            const r2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: o2, featureIndex: a2, collisionGroupID: s2, overlapMode: e3 };
            for (let e4 = 0; e4 < t2.length; e4 += 4)
              r2.insertCircle(n2, t2[e4], t2[e4 + 1], t2[e4 + 2]);
          }
          projectAndGetPerspectiveRatio(e3, i2, o2) {
            const a2 = [i2, o2, 0, 1];
            return wt(a2, a2, e3), { point: new t.pointGeometry((a2[0] / a2[3] + 1) / 2 * this.transform.width + Tt, (-a2[1] / a2[3] + 1) / 2 * this.transform.height + Tt), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / a2[3] * 0.5 };
          }
          isOffscreen(t2, e3, i2, o2) {
            return i2 < Tt || t2 >= this.screenRightBoundary || o2 < Tt || e3 > this.screenBottomBoundary;
          }
          isInsideGrid(t2, e3, i2, o2) {
            return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e3 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e3 = t.identity([]);
            return t.translate(e3, e3, [-100, -100, 0]), e3;
          }
        }
        function It(e3, i2, o2) {
          return i2 * (t.EXTENT / (e3.tileSize * Math.pow(2, o2 - e3.tileID.overscaledZ)));
        }
        class St {
          constructor(t2, e3, i2, o2) {
            this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e3 : -e3))) : o2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Ct {
          constructor(t2, e3, i2, o2, a2) {
            this.text = new St(t2 ? t2.text : null, e3, i2, a2), this.icon = new St(t2 ? t2.icon : null, e3, o2, a2);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Pt {
          constructor(t2, e3, i2) {
            this.text = t2, this.icon = e3, this.skipFade = i2;
          }
        }
        class zt {
          constructor() {
            this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];
          }
        }
        class Dt {
          constructor(t2, e3, i2, o2, a2) {
            this.bucketInstanceId = t2, this.featureIndex = e3, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = a2;
          }
        }
        class At {
          constructor(t2) {
            this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t2) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[t2]) {
              const e3 = ++this.maxGroupID;
              this.collisionGroups[t2] = { ID: e3, predicate: (t3) => t3.collisionGroupID === e3 };
            }
            return this.collisionGroups[t2];
          }
        }
        function Mt(e3, i2, o2, a2, s2) {
          const { horizontalAlign: r2, verticalAlign: n2 } = t.getAnchorAlignment(e3), l2 = -(r2 - 0.5) * i2, c2 = -(n2 - 0.5) * o2, h2 = t.evaluateVariableOffset(e3, a2);
          return new t.pointGeometry(l2 + h2[0] * s2, c2 + h2[1] * s2);
        }
        function Lt(e3, i2, o2, a2, s2, r2) {
          const { x1: n2, x2: l2, y1: c2, y2: h2, anchorPointX: u2, anchorPointY: d2 } = e3, m2 = new t.pointGeometry(i2, o2);
          return a2 && m2._rotate(s2 ? r2 : -r2), { x1: n2 + m2.x, y1: c2 + m2.y, x2: l2 + m2.x, y2: h2 + m2.y, anchorPointX: u2, anchorPointY: d2 };
        }
        class Rt {
          constructor(t2, e3, i2, o2) {
            this.transform = t2.clone(), this.collisionIndex = new Et(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = e3, this.retainedQueryData = {}, this.collisionGroups = new At(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(e3, i2, o2, a2) {
            const s2 = o2.getBucket(i2), r2 = o2.latestFeatureIndex;
            if (!s2 || !r2 || i2.id !== s2.layerIds[0])
              return;
            const n2 = o2.collisionBoxArray, l2 = s2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / t.EXTENT, u2 = this.transform.calculatePosMatrix(o2.tileID.toUnwrapped()), d2 = "map" === l2.get("text-pitch-alignment"), m2 = "map" === l2.get("text-rotation-alignment"), _2 = It(o2, 1, this.transform.zoom), p2 = ct(u2, d2, m2, this.transform, _2);
            let f2 = null;
            if (d2) {
              const e4 = ht(u2, d2, m2, this.transform, _2);
              f2 = t.multiply([], this.transform.labelPlaneMatrix, e4);
            }
            this.retainedQueryData[s2.bucketInstanceId] = new Dt(s2.bucketInstanceId, r2, s2.sourceLayerIndex, s2.index, o2.tileID);
            const g2 = { bucket: s2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: p2, labelToScreenMatrix: f2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(s2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s2.sourceID) };
            if (a2)
              for (const t2 of s2.sortKeyRanges) {
                const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3 } = t2;
                e3.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3, parameters: g2 });
              }
            else
              e3.push({ symbolInstanceStart: 0, symbolInstanceEnd: s2.symbolInstances.length, parameters: g2 });
          }
          attemptAnchorPlacement(t2, e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, m2, _2) {
            const p2 = [u2.textOffset0, u2.textOffset1], f2 = Mt(t2, i2, o2, p2, a2), g2 = this.collisionIndex.placeCollisionBox(Lt(e3, f2.x, f2.y, s2, r2, this.transform.angle), h2, n2, l2, c2.predicate);
            if ((!_2 || 0 !== this.collisionIndex.placeCollisionBox(Lt(_2, f2.x, f2.y, s2, r2, this.transform.angle), h2, n2, l2, c2.predicate).box.length) && g2.box.length > 0) {
              let e4;
              return this.prevPlacement && this.prevPlacement.variableOffsets[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID].text && (e4 = this.prevPlacement.variableOffsets[u2.crossTileID].anchor), this.variableOffsets[u2.crossTileID] = { textOffset: p2, width: i2, height: o2, anchor: t2, textBoxScale: a2, prevAnchor: e4 }, this.markUsedJustification(d2, t2, u2, m2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, m2, u2), this.placedOrientations[u2.crossTileID] = m2), { shift: f2, placedGlyphBoxes: g2 };
            }
          }
          placeLayerBucketPart(e3, i2, o2) {
            const { bucket: a2, layout: s2, posMatrix: r2, textLabelPlaneMatrix: n2, labelToScreenMatrix: l2, textPixelRatio: c2, holdingForFade: h2, collisionBoxArray: u2, partiallyEvaluatedTextSize: d2, collisionGroup: m2 } = e3.parameters, _2 = s2.get("text-optional"), p2 = s2.get("icon-optional"), f2 = t.getOverlapMode(s2, "text-overlap", "text-allow-overlap"), g2 = "always" === f2, x2 = t.getOverlapMode(s2, "icon-overlap", "icon-allow-overlap"), v2 = "always" === x2, y2 = "map" === s2.get("text-rotation-alignment"), b2 = "map" === s2.get("text-pitch-alignment"), w2 = "none" !== s2.get("icon-text-fit"), T2 = "viewport-y" === s2.get("symbol-z-order"), E2 = g2 && (v2 || !a2.hasIconData() || p2), I2 = v2 && (g2 || !a2.hasTextData() || _2);
            !a2.collisionArrays && u2 && a2.deserializeCollisionBoxes(u2);
            const S2 = (e4, u3) => {
              if (i2[e4.crossTileID])
                return;
              if (h2)
                return void (this.placements[e4.crossTileID] = new Pt(false, false, false));
              let v3 = false, T3 = false, S3 = true, C2 = null, P2 = { box: null, offscreen: null }, z2 = { box: null, offscreen: null }, D2 = null, A2 = null, M2 = null, L2 = 0, R2 = 0, k2 = 0;
              u3.textFeatureIndex ? L2 = u3.textFeatureIndex : e4.useRuntimeCollisionCircles && (L2 = e4.featureIndex), u3.verticalTextFeatureIndex && (R2 = u3.verticalTextFeatureIndex);
              const B2 = u3.textBox;
              if (B2) {
                const i3 = (i4) => {
                  let o4 = t.WritingMode.horizontal;
                  if (a2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    const t2 = this.prevPlacement.placedOrientations[e4.crossTileID];
                    t2 && (this.placedOrientations[e4.crossTileID] = t2, o4 = t2, this.markUsedOrientation(a2, o4, e4));
                  }
                  return o4;
                }, o3 = (i4, o4) => {
                  if (a2.allowVerticalPlacement && e4.numVerticalGlyphVertices > 0 && u3.verticalTextBox) {
                    for (const e5 of a2.writingModes)
                      if (e5 === t.WritingMode.vertical ? (P2 = o4(), z2 = P2) : P2 = i4(), P2 && P2.box && P2.box.length)
                        break;
                  } else
                    P2 = i4();
                };
                if (s2.get("text-variable-anchor")) {
                  let n3 = s2.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[e4.crossTileID]) {
                    const t2 = this.prevPlacement.variableOffsets[e4.crossTileID];
                    n3.indexOf(t2.anchor) > 0 && (n3 = n3.filter((e5) => e5 !== t2.anchor), n3.unshift(t2.anchor));
                  }
                  const l3 = (t2, i4, o4) => {
                    const s3 = t2.x2 - t2.x1, l4 = t2.y2 - t2.y1, h4 = e4.textBoxScale, u4 = w2 && "never" === x2 ? i4 : null;
                    let d3 = { box: [], offscreen: false };
                    const _3 = "never" !== f2 ? 2 * n3.length : n3.length;
                    for (let i5 = 0; i5 < _3; ++i5) {
                      const _4 = this.attemptAnchorPlacement(n3[i5 % n3.length], t2, s3, l4, h4, y2, b2, c2, r2, m2, i5 >= n3.length ? f2 : "never", e4, a2, o4, u4);
                      if (_4 && (d3 = _4.placedGlyphBoxes, d3 && d3.box && d3.box.length)) {
                        v3 = true, C2 = _4.shift;
                        break;
                      }
                    }
                    return d3;
                  };
                  o3(() => l3(B2, u3.iconBox, t.WritingMode.horizontal), () => {
                    const i4 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && !(P2 && P2.box && P2.box.length) && e4.numVerticalGlyphVertices > 0 && i4 ? l3(i4, u3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                  }), P2 && (v3 = P2.box, S3 = P2.offscreen);
                  const h3 = i3(P2 && P2.box);
                  if (!v3 && this.prevPlacement) {
                    const t2 = this.prevPlacement.variableOffsets[e4.crossTileID];
                    t2 && (this.variableOffsets[e4.crossTileID] = t2, this.markUsedJustification(a2, t2.anchor, e4, h3));
                  }
                } else {
                  const s3 = (t2, i4) => {
                    const o4 = this.collisionIndex.placeCollisionBox(t2, f2, c2, r2, m2.predicate);
                    return o4 && o4.box && o4.box.length && (this.markUsedOrientation(a2, i4, e4), this.placedOrientations[e4.crossTileID] = i4), o4;
                  };
                  o3(() => s3(B2, t.WritingMode.horizontal), () => {
                    const i4 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && e4.numVerticalGlyphVertices > 0 && i4 ? s3(i4, t.WritingMode.vertical) : { box: null, offscreen: null };
                  }), i3(P2 && P2.box && P2.box.length);
                }
              }
              if (D2 = P2, v3 = D2 && D2.box && D2.box.length > 0, S3 = D2 && D2.offscreen, e4.useRuntimeCollisionCircles) {
                const i3 = a2.text.placedSymbolArray.get(e4.centerJustifiedTextSymbolIndex), c3 = t.evaluateSizeForFeature(a2.textSizeData, d2, i3), h3 = s2.get("text-padding");
                A2 = this.collisionIndex.placeCollisionCircles(f2, i3, a2.lineVertexArray, a2.glyphOffsetArray, c3, r2, n2, l2, o2, b2, m2.predicate, e4.collisionCircleDiameter, h3), v3 = g2 || A2.circles.length > 0 && !A2.collisionDetected, S3 = S3 && A2.offscreen;
              }
              if (u3.iconFeatureIndex && (k2 = u3.iconFeatureIndex), u3.iconBox) {
                const t2 = (t3) => {
                  const e5 = w2 && C2 ? Lt(t3, C2.x, C2.y, y2, b2, this.transform.angle) : t3;
                  return this.collisionIndex.placeCollisionBox(e5, x2, c2, r2, m2.predicate);
                };
                z2 && z2.box && z2.box.length && u3.verticalIconBox ? (M2 = t2(u3.verticalIconBox), T3 = M2.box.length > 0) : (M2 = t2(u3.iconBox), T3 = M2.box.length > 0), S3 = S3 && M2.offscreen;
              }
              const F2 = _2 || 0 === e4.numHorizontalGlyphVertices && 0 === e4.numVerticalGlyphVertices, O2 = p2 || 0 === e4.numIconVertices;
              if (F2 || O2 ? O2 ? F2 || (T3 = T3 && v3) : v3 = T3 && v3 : T3 = v3 = T3 && v3, v3 && D2 && D2.box && this.collisionIndex.insertCollisionBox(D2.box, f2, s2.get("text-ignore-placement"), a2.bucketInstanceId, z2 && z2.box && R2 ? R2 : L2, m2.ID), T3 && M2 && this.collisionIndex.insertCollisionBox(M2.box, x2, s2.get("icon-ignore-placement"), a2.bucketInstanceId, k2, m2.ID), A2 && (v3 && this.collisionIndex.insertCollisionCircles(A2.circles, f2, s2.get("text-ignore-placement"), a2.bucketInstanceId, L2, m2.ID), o2)) {
                const t2 = a2.bucketInstanceId;
                let e5 = this.collisionCircleArrays[t2];
                void 0 === e5 && (e5 = this.collisionCircleArrays[t2] = new zt());
                for (let t3 = 0; t3 < A2.circles.length; t3 += 4)
                  e5.circles.push(A2.circles[t3 + 0]), e5.circles.push(A2.circles[t3 + 1]), e5.circles.push(A2.circles[t3 + 2]), e5.circles.push(A2.collisionDetected ? 1 : 0);
              }
              this.placements[e4.crossTileID] = new Pt(v3 || E2, T3 || I2, S3 || a2.justReloaded), i2[e4.crossTileID] = true;
            };
            if (T2) {
              const t2 = a2.getSortedSymbolIndexes(this.transform.angle);
              for (let e4 = t2.length - 1; e4 >= 0; --e4) {
                const i3 = t2[e4];
                S2(a2.symbolInstances.get(i3), a2.collisionArrays[i3]);
              }
            } else
              for (let t2 = e3.symbolInstanceStart; t2 < e3.symbolInstanceEnd; t2++)
                S2(a2.symbolInstances.get(t2), a2.collisionArrays[t2]);
            if (o2 && a2.bucketInstanceId in this.collisionCircleArrays) {
              const e4 = this.collisionCircleArrays[a2.bucketInstanceId];
              t.invert(e4.invProjMatrix, r2), e4.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            a2.justReloaded = false;
          }
          markUsedJustification(e3, i2, o2, a2) {
            let s2;
            s2 = a2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i2)];
            const r2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
            for (const t2 of r2)
              t2 >= 0 && (e3.text.placedSymbolArray.get(t2).crossTileID = s2 >= 0 && t2 !== s2 ? 0 : o2.crossTileID);
          }
          markUsedOrientation(e3, i2, o2) {
            const a2 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, s2 = i2 === t.WritingMode.vertical ? i2 : 0, r2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
            for (const t2 of r2)
              e3.text.placedSymbolArray.get(t2).placedOrientation = a2;
            o2.verticalPlacedTextSymbolIndex && (e3.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = s2);
          }
          commit(t2) {
            this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const e3 = this.prevPlacement;
            let i2 = false;
            this.prevZoomAdjustment = e3 ? e3.zoomAdjustment(this.transform.zoom) : 0;
            const o2 = e3 ? e3.symbolFadeChange(t2) : 1, a2 = e3 ? e3.opacities : {}, s2 = e3 ? e3.variableOffsets : {}, r2 = e3 ? e3.placedOrientations : {};
            for (const t3 in this.placements) {
              const e4 = this.placements[t3], s3 = a2[t3];
              s3 ? (this.opacities[t3] = new Ct(s3, o2, e4.text, e4.icon), i2 = i2 || e4.text !== s3.text.placed || e4.icon !== s3.icon.placed) : (this.opacities[t3] = new Ct(null, o2, e4.text, e4.icon, e4.skipFade), i2 = i2 || e4.text || e4.icon);
            }
            for (const t3 in a2) {
              const e4 = a2[t3];
              if (!this.opacities[t3]) {
                const a3 = new Ct(e4, o2, false, false);
                a3.isHidden() || (this.opacities[t3] = a3, i2 = i2 || e4.text.placed || e4.icon.placed);
              }
            }
            for (const t3 in s2)
              this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = s2[t3]);
            for (const t3 in r2)
              this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = r2[t3]);
            i2 ? this.lastPlacementChangeTime = t2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e3 ? e3.lastPlacementChangeTime : t2);
          }
          updateLayerOpacities(t2, e3) {
            const i2 = {};
            for (const o2 of e3) {
              const e4 = o2.getBucket(t2);
              e4 && o2.latestFeatureIndex && t2.id === e4.layerIds[0] && this.updateBucketOpacities(e4, i2, o2.collisionBoxArray);
            }
          }
          updateBucketOpacities(e3, i2, o2) {
            e3.hasTextData() && e3.text.opacityVertexArray.clear(), e3.hasIconData() && e3.icon.opacityVertexArray.clear(), e3.hasIconCollisionBoxData() && e3.iconCollisionBox.collisionVertexArray.clear(), e3.hasTextCollisionBoxData() && e3.textCollisionBox.collisionVertexArray.clear();
            const a2 = e3.layers[0].layout, s2 = new Ct(null, 0, false, false, true), r2 = a2.get("text-allow-overlap"), n2 = a2.get("icon-allow-overlap"), l2 = a2.get("text-variable-anchor"), c2 = "map" === a2.get("text-rotation-alignment"), h2 = "map" === a2.get("text-pitch-alignment"), u2 = "none" !== a2.get("icon-text-fit"), d2 = new Ct(null, 0, r2 && (n2 || !e3.hasIconData() || a2.get("icon-optional")), n2 && (r2 || !e3.hasTextData() || a2.get("text-optional")), true);
            !e3.collisionArrays && o2 && (e3.hasIconCollisionBoxData() || e3.hasTextCollisionBoxData()) && e3.deserializeCollisionBoxes(o2);
            const m2 = (t2, e4, i3) => {
              for (let o3 = 0; o3 < e4 / 4; o3++)
                t2.opacityVertexArray.emplaceBack(i3);
            };
            for (let o3 = 0; o3 < e3.symbolInstances.length; o3++) {
              const a3 = e3.symbolInstances.get(o3), { numHorizontalGlyphVertices: r3, numVerticalGlyphVertices: n3, crossTileID: _2 } = a3;
              let p2 = this.opacities[_2];
              i2[_2] ? p2 = s2 : p2 || (p2 = d2, this.opacities[_2] = p2), i2[_2] = true;
              const f2 = a3.numIconVertices > 0, g2 = this.placedOrientations[a3.crossTileID], x2 = g2 === t.WritingMode.vertical, v2 = g2 === t.WritingMode.horizontal || g2 === t.WritingMode.horizontalOnly;
              if (r3 > 0 || n3 > 0) {
                const t2 = qt(p2.text);
                m2(e3.text, r3, x2 ? Vt : t2), m2(e3.text, n3, v2 ? Vt : t2);
                const i3 = p2.text.isHidden();
                [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach((t3) => {
                  t3 >= 0 && (e3.text.placedSymbolArray.get(t3).hidden = i3 || x2 ? 1 : 0);
                }), a3.verticalPlacedTextSymbolIndex >= 0 && (e3.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = i3 || v2 ? 1 : 0);
                const o4 = this.variableOffsets[a3.crossTileID];
                o4 && this.markUsedJustification(e3, o4.anchor, a3, g2);
                const s3 = this.placedOrientations[a3.crossTileID];
                s3 && (this.markUsedJustification(e3, "left", a3, s3), this.markUsedOrientation(e3, s3, a3));
              }
              if (f2) {
                const t2 = qt(p2.icon), i3 = !(u2 && a3.verticalPlacedIconSymbolIndex && x2);
                a3.placedIconSymbolIndex >= 0 && (m2(e3.icon, a3.numIconVertices, i3 ? t2 : Vt), e3.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = p2.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (m2(e3.icon, a3.numVerticalIconVertices, i3 ? Vt : t2), e3.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = p2.icon.isHidden());
              }
              if (e3.hasIconCollisionBoxData() || e3.hasTextCollisionBoxData()) {
                const i3 = e3.collisionArrays[o3];
                if (i3) {
                  let o4 = new t.pointGeometry(0, 0);
                  if (i3.textBox || i3.verticalTextBox) {
                    let t2 = true;
                    if (l2) {
                      const e4 = this.variableOffsets[_2];
                      e4 ? (o4 = Mt(e4.anchor, e4.width, e4.height, e4.textOffset, e4.textBoxScale), c2 && o4._rotate(h2 ? this.transform.angle : -this.transform.angle)) : t2 = false;
                    }
                    i3.textBox && kt(e3.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || x2, o4.x, o4.y), i3.verticalTextBox && kt(e3.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || v2, o4.x, o4.y);
                  }
                  const a4 = Boolean(!v2 && i3.verticalIconBox);
                  i3.iconBox && kt(e3.iconCollisionBox.collisionVertexArray, p2.icon.placed, a4, u2 ? o4.x : 0, u2 ? o4.y : 0), i3.verticalIconBox && kt(e3.iconCollisionBox.collisionVertexArray, p2.icon.placed, !a4, u2 ? o4.x : 0, u2 ? o4.y : 0);
                }
              }
            }
            if (e3.sortFeatures(this.transform.angle), this.retainedQueryData[e3.bucketInstanceId] && (this.retainedQueryData[e3.bucketInstanceId].featureSortOrder = e3.featureSortOrder), e3.hasTextData() && e3.text.opacityVertexBuffer && e3.text.opacityVertexBuffer.updateData(e3.text.opacityVertexArray), e3.hasIconData() && e3.icon.opacityVertexBuffer && e3.icon.opacityVertexBuffer.updateData(e3.icon.opacityVertexArray), e3.hasIconCollisionBoxData() && e3.iconCollisionBox.collisionVertexBuffer && e3.iconCollisionBox.collisionVertexBuffer.updateData(e3.iconCollisionBox.collisionVertexArray), e3.hasTextCollisionBoxData() && e3.textCollisionBox.collisionVertexBuffer && e3.textCollisionBox.collisionVertexBuffer.updateData(e3.textCollisionBox.collisionVertexArray), e3.bucketInstanceId in this.collisionCircleArrays) {
              const t2 = this.collisionCircleArrays[e3.bucketInstanceId];
              e3.placementInvProjMatrix = t2.invProjMatrix, e3.placementViewportMatrix = t2.viewportMatrix, e3.collisionCircleArray = t2.circles, delete this.collisionCircleArrays[e3.bucketInstanceId];
            }
          }
          symbolFadeChange(t2) {
            return 0 === this.fadeDuration ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t2) {
            return Math.max(0, (this.transform.zoom - t2) / 1.5);
          }
          hasTransitions(t2) {
            return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t2, e3) {
            const i2 = this.zoomAtLastRecencyCheck === e3 ? 1 - this.zoomAdjustment(e3) : 1;
            return this.zoomAtLastRecencyCheck = e3, this.commitTime + this.fadeDuration * i2 > t2;
          }
          setStale() {
            this.stale = true;
          }
        }
        function kt(t2, e3, i2, o2, a2) {
          t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0);
        }
        const Bt = Math.pow(2, 25), Ft = Math.pow(2, 24), Ot = Math.pow(2, 17), Ut = Math.pow(2, 16), Nt = Math.pow(2, 9), Gt = Math.pow(2, 8), Zt = Math.pow(2, 1);
        function qt(t2) {
          if (0 === t2.opacity && !t2.placed)
            return 0;
          if (1 === t2.opacity && t2.placed)
            return 4294967295;
          const e3 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
          return i2 * Bt + e3 * Ft + i2 * Ot + e3 * Ut + i2 * Nt + e3 * Gt + i2 * Zt + e3;
        }
        const Vt = 0;
        class jt {
          constructor(t2) {
            this._sortAcrossTiles = "viewport-y" !== t2.layout.get("symbol-z-order") && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t2, e3, i2, o2, a2) {
            const s2 = this._bucketParts;
            for (; this._currentTileIndex < t2.length; )
              if (e3.getBucketParts(s2, o2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a2())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, s2.sort((t3, e4) => t3.sortKey - e4.sortKey)); this._currentPartIndex < s2.length; )
              if (e3.placeLayerBucketPart(s2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, a2())
                return true;
            return false;
          }
        }
        class $t {
          constructor(t2, e3, i2, o2, a2, s2, r2) {
            this.placement = new Rt(t2, a2, s2, r2), this._currentPlacementIndex = e3.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e3, i2, o2) {
            const a2 = t.exported.now(), s2 = () => {
              const e4 = t.exported.now() - a2;
              return !this._forceFullPlacement && e4 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const t2 = i2[e3[this._currentPlacementIndex]], a3 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === t2.type && (!t2.minzoom || t2.minzoom <= a3) && (!t2.maxzoom || t2.maxzoom > a3)) {
                if (this._inProgressLayer || (this._inProgressLayer = new jt(t2)), this._inProgressLayer.continuePlacement(o2[t2.source], this.placement, this._showCollisionBoxes, t2, s2))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(t2) {
            return this.placement.commit(t2), this.placement;
          }
        }
        const Wt = 512 / t.EXTENT / 2;
        class Xt {
          constructor(t2, e3, i2) {
            this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
            for (let i3 = 0; i3 < e3.length; i3++) {
              const o2 = e3.get(i3), a2 = o2.key;
              this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, t2) });
            }
          }
          getScaledCoordinates(e3, i2) {
            const o2 = Wt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
            return { x: Math.floor((i2.canonical.x * t.EXTENT + e3.anchorX) * o2), y: Math.floor((i2.canonical.y * t.EXTENT + e3.anchorY) * o2) };
          }
          findMatches(t2, e3, i2) {
            const o2 = this.tileID.canonical.z < e3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e3.canonical.z);
            for (let a2 = 0; a2 < t2.length; a2++) {
              const s2 = t2.get(a2);
              if (s2.crossTileID)
                continue;
              const r2 = this.indexedSymbolInstances[s2.key];
              if (!r2)
                continue;
              const n2 = this.getScaledCoordinates(s2, e3);
              for (const t3 of r2)
                if (Math.abs(t3.coord.x - n2.x) <= o2 && Math.abs(t3.coord.y - n2.y) <= o2 && !i2[t3.crossTileID]) {
                  i2[t3.crossTileID] = true, s2.crossTileID = t3.crossTileID;
                  break;
                }
            }
          }
        }
        class Ht {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Kt {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t2) {
            const e3 = Math.round((t2 - this.lng) / 360);
            if (0 !== e3)
              for (const t3 in this.indexes) {
                const i2 = this.indexes[t3], o2 = {};
                for (const t4 in i2) {
                  const a2 = i2[t4];
                  a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e3), o2[a2.tileID.key] = a2;
                }
                this.indexes[t3] = o2;
              }
            this.lng = t2;
          }
          addBucket(t2, e3, i2) {
            if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
              if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e3.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
            }
            for (let t3 = 0; t3 < e3.symbolInstances.length; t3++)
              e3.symbolInstances.get(t3).crossTileID = 0;
            this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
            const o2 = this.usedCrossTileIDs[t2.overscaledZ];
            for (const i3 in this.indexes) {
              const a2 = this.indexes[i3];
              if (Number(i3) > t2.overscaledZ)
                for (const i4 in a2) {
                  const s2 = a2[i4];
                  s2.tileID.isChildOf(t2) && s2.findMatches(e3.symbolInstances, t2, o2);
                }
              else {
                const s2 = a2[t2.scaledTo(Number(i3)).key];
                s2 && s2.findMatches(e3.symbolInstances, t2, o2);
              }
            }
            for (let t3 = 0; t3 < e3.symbolInstances.length; t3++) {
              const a2 = e3.symbolInstances.get(t3);
              a2.crossTileID || (a2.crossTileID = i2.generate(), o2[a2.crossTileID] = true);
            }
            return void 0 === this.indexes[t2.overscaledZ] && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new Xt(t2, e3.symbolInstances, e3.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(t2, e3) {
            for (const i2 in e3.indexedSymbolInstances)
              for (const o2 of e3.indexedSymbolInstances[i2])
                delete this.usedCrossTileIDs[t2][o2.crossTileID];
          }
          removeStaleBuckets(t2) {
            let e3 = false;
            for (const i2 in this.indexes) {
              const o2 = this.indexes[i2];
              for (const a2 in o2)
                t2[o2[a2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[a2]), delete o2[a2], e3 = true);
            }
            return e3;
          }
        }
        class Yt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Ht(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t2, e3, i2) {
            let o2 = this.layerIndexes[t2.id];
            void 0 === o2 && (o2 = this.layerIndexes[t2.id] = new Kt());
            let a2 = false;
            const s2 = {};
            o2.handleWrapJump(i2);
            for (const i3 of e3) {
              const e4 = i3.getBucket(t2);
              e4 && t2.id === e4.layerIds[0] && (e4.bucketInstanceId || (e4.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(i3.tileID, e4, this.crossTileIDs) && (a2 = true), s2[e4.bucketInstanceId] = true);
            }
            return o2.removeStaleBuckets(s2) && (a2 = true), a2;
          }
          pruneUnusedLayers(t2) {
            const e3 = {};
            t2.forEach((t3) => {
              e3[t3] = true;
            });
            for (const t3 in this.layerIndexes)
              e3[t3] || delete this.layerIndexes[t3];
          }
        }
        const Jt = (e3, i2) => t.emitValidationErrors(e3, i2 && i2.filter((t2) => "source.canvas" !== t2.identifier)), Qt = t.pick(J, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), te = t.pick(J, ["setCenter", "setZoom", "setBearing", "setPitch"]), ee = function() {
          const e3 = {}, i2 = t.spec.$version;
          for (const o2 in t.spec.$root) {
            const a2 = t.spec.$root[o2];
            if (a2.required) {
              let t2 = null;
              t2 = "version" === o2 ? i2 : "array" === a2.type ? [] : {}, null != t2 && (e3[o2] = t2);
            }
          }
          return e3;
        }();
        class ie extends t.Evented {
          constructor(e3, i2 = {}) {
            super(), this.map = e3, this.dispatcher = new T(H(), this), this.imageManager = new _(), this.imageManager.setEventedParent(this), this.glyphManager = new x(e3._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new w(256, 512), this.crossTileSymbolIndex = new Yt(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
            const o2 = this;
            this._rtlTextPluginCallback = ie.registerForPluginStateChange((e4) => {
              o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e4.pluginStatus, pluginURL: e4.pluginURL }, (e5, i3) => {
                if (t.triggerPluginCompletionEvent(e5), i3 && i3.every((t2) => t2))
                  for (const t2 in o2.sourceCaches)
                    o2.sourceCaches[t2].reload();
              });
            }), this.on("data", (t2) => {
              if ("source" !== t2.dataType || "metadata" !== t2.sourceDataType)
                return;
              const e4 = this.sourceCaches[t2.sourceId];
              if (!e4)
                return;
              const i3 = e4.getSource();
              if (i3 && i3.vectorLayerIds)
                for (const t3 in this._layers) {
                  const e5 = this._layers[t3];
                  e5.source === i3.id && this._validateLayer(e5);
                }
            });
          }
          loadURL(e3, i2 = {}) {
            this.fire(new t.Event("dataloading", { dataType: "style" }));
            const o2 = "boolean" != typeof i2.validate || i2.validate, a2 = this.map._requestManager.transformRequest(e3, t.ResourceType.Style);
            this._request = t.getJSON(a2, (e4, i3) => {
              this._request = null, e4 ? this.fire(new t.ErrorEvent(e4)) : i3 && this._load(i3, o2);
            });
          }
          loadJSON(e3, i2 = {}) {
            this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.exported.frame(() => {
              this._request = null, this._load(e3, false !== i2.validate);
            });
          }
          loadEmpty() {
            this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(ee, false);
          }
          _load(e3, i2) {
            if (i2 && Jt(this, t.validateStyle(e3)))
              return;
            this._loaded = true, this.stylesheet = e3;
            for (const t2 in e3.sources)
              this.addSource(t2, e3.sources[t2], { validate: false });
            e3.sprite ? this._loadSprite(e3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(e3.glyphs);
            const o2 = Y(this.stylesheet.layers);
            this._order = o2.map((t2) => t2.id), this._layers = {}, this._serializedLayers = {};
            for (let e4 of o2)
              e4 = t.createStyleLayer(e4), e4.setEventedParent(this, { layer: { id: e4.id } }), this._layers[e4.id] = e4, this._serializedLayers[e4.id] = e4.serialize();
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new b(this.stylesheet.light), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
          }
          _loadSprite(e3) {
            this._spriteRequest = function(e4, i2, o2, a2) {
              let s2, r2, n2;
              const l2 = o2 > 1 ? "@2x" : "";
              let c2 = t.getJSON(i2.transformRequest(i2.normalizeSpriteURL(e4, l2, ".json"), t.ResourceType.SpriteJSON), (t2, e5) => {
                c2 = null, n2 || (n2 = t2, s2 = e5, u2());
              }), h2 = t.getImage(i2.transformRequest(i2.normalizeSpriteURL(e4, l2, ".png"), t.ResourceType.SpriteImage), (t2, e5) => {
                h2 = null, n2 || (n2 = t2, r2 = e5, u2());
              });
              function u2() {
                if (n2)
                  a2(n2);
                else if (s2 && r2) {
                  const e5 = t.exported.getImageData(r2), i3 = {};
                  for (const o3 in s2) {
                    const { width: a3, height: r3, x: n3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u3, stretchY: d2, content: m2 } = s2[o3], _2 = new t.RGBAImage({ width: a3, height: r3 });
                    t.RGBAImage.copy(e5, _2, { x: n3, y: l3 }, { x: 0, y: 0 }, { width: a3, height: r3 }), i3[o3] = { data: _2, pixelRatio: h3, sdf: c3, stretchX: u3, stretchY: d2, content: m2 };
                  }
                  a2(null, i3);
                }
              }
              return { cancel() {
                c2 && (c2.cancel(), c2 = null), h2 && (h2.cancel(), h2 = null);
              } };
            }(e3, this.map._requestManager, this.map.getPixelRatio(), (e4, i2) => {
              if (this._spriteRequest = null, e4)
                this.fire(new t.ErrorEvent(e4));
              else if (i2)
                for (const t2 in i2)
                  this.imageManager.addImage(t2, i2[t2]);
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
            });
          }
          _validateLayer(e3) {
            const i2 = this.sourceCaches[e3.source];
            if (!i2)
              return;
            const o2 = e3.sourceLayer;
            if (!o2)
              return;
            const a2 = i2.getSource();
            ("geojson" === a2.type || a2.vectorLayerIds && -1 === a2.vectorLayerIds.indexOf(o2)) && this.fire(new t.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${a2.id}" as specified by style layer "${e3.id}".`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (const t2 in this.sourceCaches)
              if (!this.sourceCaches[t2].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeLayers(t2) {
            const e3 = [];
            for (const i2 of t2) {
              const t3 = this._layers[i2];
              "custom" !== t3.type && e3.push(t3.serialize());
            }
            return e3;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return true;
            for (const t2 in this.sourceCaches)
              if (this.sourceCaches[t2].hasTransition())
                return true;
            for (const t2 in this._layers)
              if (this._layers[t2].hasTransition())
                return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading.");
          }
          update(e3) {
            if (!this._loaded)
              return;
            const i2 = this._changed;
            if (this._changed) {
              const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
              (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
              for (const t3 in this._updatedSources) {
                const e4 = this._updatedSources[t3];
                "reload" === e4 ? this._reloadSource(t3) : "clear" === e4 && this._clearSource(t3);
              }
              this._updateTilesForChangedImages();
              for (const t3 in this._updatedPaintProps)
                this._layers[t3].updateTransitions(e3);
              this.light.updateTransitions(e3), this._resetUpdates();
            }
            const o2 = {};
            for (const t2 in this.sourceCaches) {
              const e4 = this.sourceCaches[t2];
              o2[t2] = e4.used, e4.used = false;
            }
            for (const t2 of this._order) {
              const i3 = this._layers[t2];
              i3.recalculate(e3, this._availableImages), !i3.isHidden(e3.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
            }
            for (const e4 in o2) {
              const i3 = this.sourceCaches[e4];
              o2[e4] !== i3.used && i3.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: e4 }));
            }
            this.light.recalculate(e3), this.z = e3.zoom, i2 && this.fire(new t.Event("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t2 = Object.keys(this._changedImages);
            if (t2.length) {
              for (const e3 in this.sourceCaches)
                this.sourceCaches[e3].reloadTilesForDependencies(["icons", "patterns"], t2);
              this._changedImages = {};
            }
          }
          _updateWorkerLayers(t2, e3) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e3 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }
          setState(e3) {
            if (this._checkLoaded(), Jt(this, t.validateStyle(e3)))
              return false;
            (e3 = t.clone$1(e3)).layers = Y(e3.layers);
            const i2 = function(t2, e4) {
              if (!t2)
                return [{ command: J.setStyle, args: [e4] }];
              let i3 = [];
              try {
                if (!a(t2.version, e4.version))
                  return [{ command: J.setStyle, args: [e4] }];
                a(t2.center, e4.center) || i3.push({ command: J.setCenter, args: [e4.center] }), a(t2.zoom, e4.zoom) || i3.push({ command: J.setZoom, args: [e4.zoom] }), a(t2.bearing, e4.bearing) || i3.push({ command: J.setBearing, args: [e4.bearing] }), a(t2.pitch, e4.pitch) || i3.push({ command: J.setPitch, args: [e4.pitch] }), a(t2.sprite, e4.sprite) || i3.push({ command: J.setSprite, args: [e4.sprite] }), a(t2.glyphs, e4.glyphs) || i3.push({ command: J.setGlyphs, args: [e4.glyphs] }), a(t2.transition, e4.transition) || i3.push({ command: J.setTransition, args: [e4.transition] }), a(t2.light, e4.light) || i3.push({ command: J.setLight, args: [e4.light] });
                const o3 = {}, s2 = [];
                !function(t3, e5, i4, o4) {
                  let s3;
                  for (s3 in e5 = e5 || {}, t3 = t3 || {})
                    Object.prototype.hasOwnProperty.call(t3, s3) && (Object.prototype.hasOwnProperty.call(e5, s3) || tt(s3, i4, o4));
                  for (s3 in e5)
                    Object.prototype.hasOwnProperty.call(e5, s3) && (Object.prototype.hasOwnProperty.call(t3, s3) ? a(t3[s3], e5[s3]) || ("geojson" === t3[s3].type && "geojson" === e5[s3].type && it(t3, e5, s3) ? i4.push({ command: J.setGeoJSONSourceData, args: [s3, e5[s3].data] }) : et(s3, e5, i4, o4)) : Q(s3, e5, i4));
                }(t2.sources, e4.sources, s2, o3);
                const r2 = [];
                t2.layers && t2.layers.forEach((t3) => {
                  o3[t3.source] ? i3.push({ command: J.removeLayer, args: [t3.id] }) : r2.push(t3);
                }), i3 = i3.concat(s2), function(t3, e5, i4) {
                  e5 = e5 || [];
                  const o4 = (t3 = t3 || []).map(at), s3 = e5.map(at), r3 = t3.reduce(st, {}), n2 = e5.reduce(st, {}), l2 = o4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                  let h2, u2, d2, m2, _2, p2, f2;
                  for (h2 = 0, u2 = 0; h2 < o4.length; h2++)
                    d2 = o4[h2], Object.prototype.hasOwnProperty.call(n2, d2) ? u2++ : (i4.push({ command: J.removeLayer, args: [d2] }), l2.splice(l2.indexOf(d2, u2), 1));
                  for (h2 = 0, u2 = 0; h2 < s3.length; h2++)
                    d2 = s3[s3.length - 1 - h2], l2[l2.length - 1 - h2] !== d2 && (Object.prototype.hasOwnProperty.call(r3, d2) ? (i4.push({ command: J.removeLayer, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - u2), 1)) : u2++, p2 = l2[l2.length - h2], i4.push({ command: J.addLayer, args: [n2[d2], p2] }), l2.splice(l2.length - h2, 0, d2), c2[d2] = true);
                  for (h2 = 0; h2 < s3.length; h2++)
                    if (d2 = s3[h2], m2 = r3[d2], _2 = n2[d2], !c2[d2] && !a(m2, _2))
                      if (a(m2.source, _2.source) && a(m2["source-layer"], _2["source-layer"]) && a(m2.type, _2.type)) {
                        for (f2 in ot(m2.layout, _2.layout, i4, d2, null, J.setLayoutProperty), ot(m2.paint, _2.paint, i4, d2, null, J.setPaintProperty), a(m2.filter, _2.filter) || i4.push({ command: J.setFilter, args: [d2, _2.filter] }), a(m2.minzoom, _2.minzoom) && a(m2.maxzoom, _2.maxzoom) || i4.push({ command: J.setLayerZoomRange, args: [d2, _2.minzoom, _2.maxzoom] }), m2)
                          Object.prototype.hasOwnProperty.call(m2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? ot(m2[f2], _2[f2], i4, d2, f2.slice(6), J.setPaintProperty) : a(m2[f2], _2[f2]) || i4.push({ command: J.setLayerProperty, args: [d2, f2, _2[f2]] }));
                        for (f2 in _2)
                          Object.prototype.hasOwnProperty.call(_2, f2) && !Object.prototype.hasOwnProperty.call(m2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? ot(m2[f2], _2[f2], i4, d2, f2.slice(6), J.setPaintProperty) : a(m2[f2], _2[f2]) || i4.push({ command: J.setLayerProperty, args: [d2, f2, _2[f2]] }));
                      } else
                        i4.push({ command: J.removeLayer, args: [d2] }), p2 = l2[l2.lastIndexOf(d2) + 1], i4.push({ command: J.addLayer, args: [_2, p2] });
                }(r2, e4.layers, i3);
              } catch (t3) {
                console.warn("Unable to compute style diff:", t3), i3 = [{ command: J.setStyle, args: [e4] }];
              }
              return i3;
            }(this.serialize(), e3).filter((t2) => !(t2.command in te));
            if (0 === i2.length)
              return false;
            const o2 = i2.filter((t2) => !(t2.command in Qt));
            if (o2.length > 0)
              throw new Error(`Unimplemented: ${o2.map((t2) => t2.command).join(", ")}.`);
            return i2.forEach((t2) => {
              "setTransition" !== t2.command && this[t2.command].apply(this, t2.args);
            }), this.stylesheet = e3, true;
          }
          addImage(e3, i2) {
            if (this.getImage(e3))
              return this.fire(new t.ErrorEvent(new Error(`An image named "${e3}" already exists.`)));
            this.imageManager.addImage(e3, i2), this._afterImageUpdated(e3);
          }
          updateImage(t2, e3) {
            this.imageManager.updateImage(t2, e3);
          }
          getImage(t2) {
            return this.imageManager.getImage(t2);
          }
          removeImage(e3) {
            if (!this.getImage(e3))
              return this.fire(new t.ErrorEvent(new Error(`An image named "${e3}" does not exist.`)));
            this.imageManager.removeImage(e3), this._afterImageUpdated(e3);
          }
          _afterImageUpdated(e3) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e3, i2, o2 = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[e3])
              throw new Error(`Source "${e3}" already exists.`);
            if (!i2.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.validateStyle.source, `sources.${e3}`, i2, null, o2))
              return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
            const a2 = this.sourceCaches[e3] = new Z(e3, i2, this.dispatcher);
            a2.style = this, a2.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: a2.serialize(), sourceId: e3 })), a2.onAdd(this.map), this._changed = true;
          }
          removeSource(e3) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e3])
              throw new Error("There is no source with this ID");
            for (const i3 in this._layers)
              if (this._layers[i3].source === e3)
                return this.fire(new t.ErrorEvent(new Error(`Source "${e3}" cannot be removed while layer "${i3}" is using it.`)));
            const i2 = this.sourceCaches[e3];
            delete this.sourceCaches[e3], delete this._updatedSources[e3], i2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(t2, e3) {
            this._checkLoaded(), this.sourceCaches[t2].getSource().setData(e3), this._changed = true;
          }
          getSource(t2) {
            return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
          }
          addLayer(e3, i2, o2 = {}) {
            this._checkLoaded();
            const a2 = e3.id;
            if (this.getLayer(a2))
              return void this.fire(new t.ErrorEvent(new Error(`Layer "${a2}" already exists on this map.`)));
            let s2;
            if ("custom" === e3.type) {
              if (Jt(this, t.validateCustomStyleLayer(e3)))
                return;
              s2 = t.createStyleLayer(e3);
            } else {
              if ("object" == typeof e3.source && (this.addSource(a2, e3.source), e3 = t.clone$1(e3), e3 = t.extend(e3, { source: a2 })), this._validate(t.validateStyle.layer, `layers.${a2}`, e3, { arrayIndex: -1 }, o2))
                return;
              s2 = t.createStyleLayer(e3), this._validateLayer(s2), s2.setEventedParent(this, { layer: { id: a2 } }), this._serializedLayers[s2.id] = s2.serialize();
            }
            const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
            if (i2 && -1 === r2)
              this.fire(new t.ErrorEvent(new Error(`Cannot add layer "${a2}" before non-existing layer "${i2}".`)));
            else {
              if (this._order.splice(r2, 0, a2), this._layerOrderChanged = true, this._layers[a2] = s2, this._removedLayers[a2] && s2.source && "custom" !== s2.type) {
                const t2 = this._removedLayers[a2];
                delete this._removedLayers[a2], t2.type !== s2.type ? this._updatedSources[s2.source] = "clear" : (this._updatedSources[s2.source] = "reload", this.sourceCaches[s2.source].pause());
              }
              this._updateLayer(s2), s2.onAdd && s2.onAdd(this.map);
            }
          }
          moveLayer(e3, i2) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e3])
              return void this.fire(new t.ErrorEvent(new Error(`The layer '${e3}' does not exist in the map's style and cannot be moved.`)));
            if (e3 === i2)
              return;
            const o2 = this._order.indexOf(e3);
            this._order.splice(o2, 1);
            const a2 = i2 ? this._order.indexOf(i2) : this._order.length;
            i2 && -1 === a2 ? this.fire(new t.ErrorEvent(new Error(`Cannot move layer "${e3}" before non-existing layer "${i2}".`))) : (this._order.splice(a2, 0, e3), this._layerOrderChanged = true);
          }
          removeLayer(e3) {
            this._checkLoaded();
            const i2 = this._layers[e3];
            if (!i2)
              return void this.fire(new t.ErrorEvent(new Error(`Cannot remove non-existing layer "${e3}".`)));
            i2.setEventedParent(null);
            const o2 = this._order.indexOf(e3);
            this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e3] = i2, delete this._layers[e3], delete this._serializedLayers[e3], delete this._updatedLayers[e3], delete this._updatedPaintProps[e3], i2.onRemove && i2.onRemove(this.map);
          }
          getLayer(t2) {
            return this._layers[t2];
          }
          hasLayer(t2) {
            return t2 in this._layers;
          }
          setLayerZoomRange(e3, i2, o2) {
            this._checkLoaded();
            const a2 = this.getLayer(e3);
            a2 ? a2.minzoom === i2 && a2.maxzoom === o2 || (null != i2 && (a2.minzoom = i2), null != o2 && (a2.maxzoom = o2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e3}".`)));
          }
          setFilter(e3, i2, o2 = {}) {
            this._checkLoaded();
            const s2 = this.getLayer(e3);
            if (s2) {
              if (!a(s2.filter, i2))
                return null == i2 ? (s2.filter = void 0, void this._updateLayer(s2)) : void (this._validate(t.validateStyle.filter, `layers.${s2.id}.filter`, i2, null, o2) || (s2.filter = t.clone$1(i2), this._updateLayer(s2)));
            } else
              this.fire(new t.ErrorEvent(new Error(`Cannot filter non-existing layer "${e3}".`)));
          }
          getFilter(e3) {
            return t.clone$1(this.getLayer(e3).filter);
          }
          setLayoutProperty(e3, i2, o2, s2 = {}) {
            this._checkLoaded();
            const r2 = this.getLayer(e3);
            r2 ? a(r2.getLayoutProperty(i2), o2) || (r2.setLayoutProperty(i2, o2, s2), this._updateLayer(r2)) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e3}".`)));
          }
          getLayoutProperty(e3, i2) {
            const o2 = this.getLayer(e3);
            if (o2)
              return o2.getLayoutProperty(i2);
            this.fire(new t.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e3}".`)));
          }
          setPaintProperty(e3, i2, o2, s2 = {}) {
            this._checkLoaded();
            const r2 = this.getLayer(e3);
            r2 ? a(r2.getPaintProperty(i2), o2) || (r2.setPaintProperty(i2, o2, s2) && this._updateLayer(r2), this._changed = true, this._updatedPaintProps[e3] = true) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e3}".`)));
          }
          getPaintProperty(t2, e3) {
            return this.getLayer(t2).getPaintProperty(e3);
          }
          setFeatureState(e3, i2) {
            this._checkLoaded();
            const o2 = e3.source, a2 = e3.sourceLayer, s2 = this.sourceCaches[o2];
            if (void 0 === s2)
              return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const r2 = s2.getSource().type;
            "geojson" === r2 && a2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r2 || a2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), s2.setFeatureState(a2, e3.id, i2)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e3, i2) {
            this._checkLoaded();
            const o2 = e3.source, a2 = this.sourceCaches[o2];
            if (void 0 === a2)
              return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const s2 = a2.getSource().type, r2 = "vector" === s2 ? e3.sourceLayer : void 0;
            "vector" !== s2 || r2 ? i2 && "string" != typeof e3.id && "number" != typeof e3.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : a2.removeFeatureState(r2, e3.id, i2) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e3) {
            this._checkLoaded();
            const i2 = e3.source, o2 = e3.sourceLayer, a2 = this.sourceCaches[i2];
            if (void 0 !== a2)
              return "vector" !== a2.getSource().type || o2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.getFeatureState(o2, e3.id)) : void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new t.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
          }
          getTransition() {
            return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, (t2) => t2.serialize()), layers: this._serializeLayers(this._order) }, (t2) => void 0 !== t2);
          }
          _updateLayer(t2) {
            this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && "raster" !== this.sourceCaches[t2.source].getSource().type && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._changed = true;
          }
          _flattenAndSortRenderedFeatures(t2) {
            const e3 = (t3) => "fill-extrusion" === this._layers[t3].type, i2 = {}, o2 = [];
            for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
              const s2 = this._order[a3];
              if (e3(s2)) {
                i2[s2] = a3;
                for (const e4 of t2) {
                  const t3 = e4[s2];
                  if (t3)
                    for (const e5 of t3)
                      o2.push(e5);
                }
              }
            }
            o2.sort((t3, e4) => e4.intersectionZ - t3.intersectionZ);
            const a2 = [];
            for (let s2 = this._order.length - 1; s2 >= 0; s2--) {
              const r2 = this._order[s2];
              if (e3(r2))
                for (let t3 = o2.length - 1; t3 >= 0; t3--) {
                  const e4 = o2[t3].feature;
                  if (i2[e4.layer.id] < s2)
                    break;
                  a2.push(e4), o2.pop();
                }
              else
                for (const e4 of t2) {
                  const t3 = e4[r2];
                  if (t3)
                    for (const e5 of t3)
                      a2.push(e5.feature);
                }
            }
            return a2;
          }
          queryRenderedFeatures(e3, i2, o2) {
            i2 && i2.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
            const a2 = {};
            if (i2 && i2.layers) {
              if (!Array.isArray(i2.layers))
                return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (const e4 of i2.layers) {
                const i3 = this._layers[e4];
                if (!i3)
                  return this.fire(new t.ErrorEvent(new Error(`The layer '${e4}' does not exist in the map's style and cannot be queried for features.`))), [];
                a2[i3.source] = true;
              }
            }
            const s2 = [];
            i2.availableImages = this._availableImages;
            for (const t2 in this.sourceCaches)
              i2.layers && !a2[t2] || s2.push(F(this.sourceCaches[t2], this._layers, this._serializedLayers, e3, i2, o2));
            return this.placement && s2.push(function(t2, e4, i3, o3, a3, s3, r2) {
              const n2 = {}, l2 = s3.queryRenderedSymbols(o3), c2 = [];
              for (const t3 of Object.keys(l2).map(Number))
                c2.push(r2[t3]);
              c2.sort(O);
              for (const i4 of c2) {
                const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e4, i4.bucketIndex, i4.sourceLayerIndex, a3.filter, a3.layers, a3.availableImages, t2);
                for (const t3 in o4) {
                  const e5 = n2[t3] = n2[t3] || [], a4 = o4[t3];
                  a4.sort((t4, e6) => {
                    const o5 = i4.featureSortOrder;
                    if (o5) {
                      const i5 = o5.indexOf(t4.featureIndex);
                      return o5.indexOf(e6.featureIndex) - i5;
                    }
                    return e6.featureIndex - t4.featureIndex;
                  });
                  for (const t4 of a4)
                    e5.push(t4);
                }
              }
              for (const e5 in n2)
                n2[e5].forEach((o4) => {
                  const a4 = o4.feature, s4 = i3[t2[e5].source].getFeatureState(a4.layer["source-layer"], a4.id);
                  a4.source = a4.layer.source, a4.layer["source-layer"] && (a4.sourceLayer = a4.layer["source-layer"]), a4.state = s4;
                });
              return n2;
            }(this._layers, this._serializedLayers, this.sourceCaches, e3, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s2);
          }
          querySourceFeatures(e3, i2) {
            i2 && i2.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i2.filter, null, i2);
            const o2 = this.sourceCaches[e3];
            return o2 ? function(t2, e4) {
              const i3 = t2.getRenderableIds().map((e5) => t2.getTileByID(e5)), o3 = [], a2 = {};
              for (let t3 = 0; t3 < i3.length; t3++) {
                const s2 = i3[t3], r2 = s2.tileID.canonical.key;
                a2[r2] || (a2[r2] = true, s2.querySourceFeatures(o3, e4));
              }
              return o3;
            }(o2, i2) : [];
          }
          addSourceType(t2, e3, i2) {
            return ie.getSourceType(t2) ? i2(new Error(`A source type called "${t2}" already exists.`)) : (ie.setSourceType(t2, e3), e3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e3.workerSourceURL }, i2) : i2(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e3, i2 = {}) {
            this._checkLoaded();
            const o2 = this.light.getLight();
            let s2 = false;
            for (const t2 in e3)
              if (!a(e3[t2], o2[t2])) {
                s2 = true;
                break;
              }
            if (!s2)
              return;
            const r2 = { now: t.exported.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e3, i2), this.light.updateTransitions(r2);
          }
          _validate(e3, i2, o2, a2, s2 = {}) {
            return (!s2 || false !== s2.validate) && Jt(this, e3.call(t.validateStyle, t.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: t.spec }, a2)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const t2 in this._layers)
              this._layers[t2].setEventedParent(null);
            for (const t2 in this.sourceCaches) {
              const e3 = this.sourceCaches[t2];
              e3.setEventedParent(null), e3.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }
          _clearSource(t2) {
            this.sourceCaches[t2].clearTiles();
          }
          _reloadSource(t2) {
            this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
          }
          _updateSources(t2) {
            for (const e3 in this.sourceCaches)
              this.sourceCaches[e3].update(t2);
          }
          _generateCollisionBoxes() {
            for (const t2 in this.sourceCaches)
              this._reloadSource(t2);
          }
          _updatePlacement(e3, i2, o2, a2, s2 = false) {
            let r2 = false, n2 = false;
            const l2 = {};
            for (const t2 of this._order) {
              const i3 = this._layers[t2];
              if ("symbol" !== i3.type)
                continue;
              if (!l2[i3.source]) {
                const t3 = this.sourceCaches[i3.source];
                l2[i3.source] = t3.getRenderableIds(true).map((e4) => t3.getTileByID(e4)).sort((t4, e4) => e4.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e4.tileID) ? -1 : 1));
              }
              const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], e3.center.lng);
              r2 = r2 || o3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((s2 = s2 || this._layerOrderChanged || 0 === o2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e3.zoom)) && (this.pauseablePlacement = new $t(e3, this._order, s2, i2, o2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()), n2 = true), r2 && this.pauseablePlacement.placement.setStale()), n2 || r2)
              for (const t2 of this._order) {
                const e4 = this._layers[t2];
                "symbol" === e4.type && this.placement.updateLayerOpacities(e4, l2[e4.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now());
          }
          _releaseSymbolFadeTiles() {
            for (const t2 in this.sourceCaches)
              this.sourceCaches[t2].releaseSymbolFadeTiles();
          }
          getImages(t2, e3, i2) {
            this.imageManager.getImages(e3.icons, i2), this._updateTilesForChangedImages();
            const o2 = this.sourceCaches[e3.source];
            o2 && o2.setDependencies(e3.tileID.key, e3.type, e3.icons);
          }
          getGlyphs(t2, e3, i2) {
            this.glyphManager.getGlyphs(e3.stacks, i2);
          }
          getResource(e3, i2, o2) {
            return t.makeRequest(i2, o2);
          }
        }
        ie.getSourceType = function(t2) {
          return k[t2];
        }, ie.setSourceType = function(t2, e3) {
          k[t2] = e3;
        }, ie.registerForPluginStateChange = t.registerForPluginStateChange;
        var oe = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), ae = { prelude: se("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"), background: se("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: se("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: se("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: se("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: se("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: se("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: se("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: se("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: se("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), fill: se("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: se("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: se("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: se("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: se("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: se("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: se("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: se("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: se("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), lineGradient: se("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), linePattern: se("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: se("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: se("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: se("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"), symbolSDF: se("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: se("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}") };
        function se(t2, e3) {
          const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = e3.match(/attribute ([\w]+) ([\w]+)/g), a2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = e3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = s2 ? s2.concat(a2) : a2, n2 = {};
          return { fragmentSource: t2 = t2.replace(i2, (t3, e4, i3, o3, a3) => (n2[a3] = true, "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a3}
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`)), vertexSource: e3 = e3.replace(i2, (t3, e4, i3, o3, a3) => {
            const s3 = "float" === o3 ? "vec2" : "vec4", r3 = a3.match(/color/) ? "color" : s3;
            return n2[a3] ? "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${s3} a_${a3};
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${s3} a_${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`;
          }), staticAttributes: o2, staticUniforms: r2 };
        }
        class re {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t2, e3, i2, o2, a2, s2, r2, n2) {
            this.context = t2;
            let l2 = this.boundPaintVertexBuffers.length !== o2.length;
            for (let t3 = 0; !l2 && t3 < o2.length; t3++)
              this.boundPaintVertexBuffers[t3] !== o2[t3] && (l2 = true);
            t2.extVertexArrayObject && this.vao && this.boundProgram === e3 && this.boundLayoutVertexBuffer === i2 && !l2 && this.boundIndexBuffer === a2 && this.boundVertexOffset === s2 && this.boundDynamicVertexBuffer === r2 && this.boundDynamicVertexBuffer2 === n2 ? (t2.bindVertexArrayOES.set(this.vao), r2 && r2.bind(), a2 && a2.dynamicDraw && a2.bind(), n2 && n2.bind()) : this.freshBind(e3, i2, o2, a2, s2, r2, n2);
          }
          freshBind(t2, e3, i2, o2, a2, s2, r2) {
            let n2;
            const l2 = t2.numAttributes, c2 = this.context, h2 = c2.gl;
            if (c2.extVertexArrayObject)
              this.vao && this.destroy(), this.vao = c2.extVertexArrayObject.createVertexArrayOES(), c2.bindVertexArrayOES.set(this.vao), n2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e3, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = a2, this.boundDynamicVertexBuffer = s2, this.boundDynamicVertexBuffer2 = r2;
            else {
              n2 = c2.currentNumAttributes || 0;
              for (let t3 = l2; t3 < n2; t3++)
                h2.disableVertexAttribArray(t3);
            }
            e3.enableAttributes(h2, t2);
            for (const e4 of i2)
              e4.enableAttributes(h2, t2);
            s2 && s2.enableAttributes(h2, t2), r2 && r2.enableAttributes(h2, t2), e3.bind(), e3.setVertexAttribPointers(h2, t2, a2);
            for (const e4 of i2)
              e4.bind(), e4.setVertexAttribPointers(h2, t2, a2);
            s2 && (s2.bind(), s2.setVertexAttribPointers(h2, t2, a2)), o2 && o2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(h2, t2, a2)), c2.currentNumAttributes = l2;
          }
          destroy() {
            this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
          }
        }
        function ne(t2) {
          const e3 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            if (null === t2[i2])
              continue;
            const o2 = t2[i2].split(" ");
            e3.push(o2.pop());
          }
          return e3;
        }
        class le {
          constructor(t2, e3, i2, o2, a2, s2) {
            const r2 = t2.gl;
            this.program = r2.createProgram();
            const n2 = ne(i2.staticAttributes), l2 = o2 ? o2.getBinderAttributes() : [], c2 = n2.concat(l2), h2 = i2.staticUniforms ? ne(i2.staticUniforms) : [], u2 = o2 ? o2.getBinderUniforms() : [], d2 = h2.concat(u2), m2 = [];
            for (const t3 of d2)
              m2.indexOf(t3) < 0 && m2.push(t3);
            const _2 = o2 ? o2.defines() : [];
            s2 && _2.push("#define OVERDRAW_INSPECTOR;");
            const p2 = _2.concat(ae.prelude.fragmentSource, i2.fragmentSource).join("\n"), f2 = _2.concat(ae.prelude.vertexSource, i2.vertexSource).join("\n"), g2 = r2.createShader(r2.FRAGMENT_SHADER);
            if (r2.isContextLost())
              return void (this.failedToCreate = true);
            r2.shaderSource(g2, p2), r2.compileShader(g2), r2.attachShader(this.program, g2);
            const x2 = r2.createShader(r2.VERTEX_SHADER);
            if (r2.isContextLost())
              return void (this.failedToCreate = true);
            r2.shaderSource(x2, f2), r2.compileShader(x2), r2.attachShader(this.program, x2), this.attributes = {};
            const v2 = {};
            this.numAttributes = c2.length;
            for (let t3 = 0; t3 < this.numAttributes; t3++)
              c2[t3] && (r2.bindAttribLocation(this.program, t3, c2[t3]), this.attributes[c2[t3]] = t3);
            r2.linkProgram(this.program), r2.deleteShader(x2), r2.deleteShader(g2);
            for (let t3 = 0; t3 < m2.length; t3++) {
              const e4 = m2[t3];
              if (e4 && !v2[e4]) {
                const t4 = r2.getUniformLocation(this.program, e4);
                t4 && (v2[e4] = t4);
              }
            }
            this.fixedUniforms = a2(t2, v2), this.binderUniforms = o2 ? o2.getUniforms(t2, v2) : [];
          }
          draw(t2, e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, m2, _2, p2) {
            const f2 = t2.gl;
            if (this.failedToCreate)
              return;
            t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(a2), t2.setCullFace(s2);
            for (const t3 in this.fixedUniforms)
              this.fixedUniforms[t3].set(r2[t3]);
            m2 && m2.setUniforms(t2, this.binderUniforms, u2, { zoom: d2 });
            const g2 = { [f2.LINES]: 2, [f2.TRIANGLES]: 3, [f2.LINE_STRIP]: 1 }[e3];
            for (const i3 of h2.get()) {
              const o3 = i3.vaos || (i3.vaos = {});
              (o3[n2] || (o3[n2] = new re())).bind(t2, this, l2, m2 ? m2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, _2, p2), f2.drawElements(e3, i3.primitiveLength * g2, f2.UNSIGNED_SHORT, i3.primitiveOffset * g2 * 2);
            }
          }
        }
        function ce(t2, e3, i2) {
          const o2 = 1 / It(i2, 1, e3.transform.tileZoom), a2 = Math.pow(2, i2.tileID.overscaledZ), s2 = i2.tileSize * Math.pow(2, e3.transform.tileZoom) / a2, r2 = s2 * (i2.tileID.canonical.x + i2.tileID.wrap * a2), n2 = s2 * i2.tileID.canonical.y;
          return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [r2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n2] };
        }
        const he = (e3, i2, o2, a2) => {
          const s2 = i2.style.light, r2 = s2.properties.get("position"), n2 = [r2.x, r2.y, r2.z], l2 = function() {
            var e4 = new t.ARRAY_TYPE(9);
            return t.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[5] = 0, e4[6] = 0, e4[7] = 0), e4[0] = 1, e4[4] = 1, e4[8] = 1, e4;
          }();
          "viewport" === s2.properties.get("anchor") && function(t2, e4) {
            var i3 = Math.sin(e4), o3 = Math.cos(e4);
            t2[0] = o3, t2[1] = i3, t2[2] = 0, t2[3] = -i3, t2[4] = o3, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1;
          }(l2, -i2.transform.angle), function(t2, e4, i3) {
            var o3 = e4[0], a3 = e4[1], s3 = e4[2];
            t2[0] = o3 * i3[0] + a3 * i3[3] + s3 * i3[6], t2[1] = o3 * i3[1] + a3 * i3[4] + s3 * i3[7], t2[2] = o3 * i3[2] + a3 * i3[5] + s3 * i3[8];
          }(n2, n2, l2);
          const c2 = s2.properties.get("color");
          return { u_matrix: e3, u_lightpos: n2, u_lightintensity: s2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: a2 };
        }, ue = (e3, i2, o2, a2, s2, r2, n2) => t.extend(he(e3, i2, o2, a2), ce(r2, i2, n2), { u_height_factor: -Math.pow(2, s2.overscaledZ) / n2.tileSize / 8 }), de = (t2) => ({ u_matrix: t2 }), me = (e3, i2, o2, a2) => t.extend(de(e3), ce(o2, i2, a2)), _e = (t2, e3) => ({ u_matrix: t2, u_world: e3 }), pe = (e3, i2, o2, a2, s2) => t.extend(me(e3, i2, o2, a2), { u_world: s2 }), fe = (t2, e3, i2, o2) => {
          const a2 = t2.transform;
          let s2, r2;
          if ("map" === o2.paint.get("circle-pitch-alignment")) {
            const t3 = It(i2, 1, a2.zoom);
            s2 = true, r2 = [t3, t3];
          } else
            s2 = false, r2 = a2.pixelsToGLUnits;
          return { u_camera_to_center_distance: a2.cameraToCenterDistance, u_scale_with_map: +("map" === o2.paint.get("circle-pitch-scale")), u_matrix: t2.translatePosMatrix(e3.posMatrix, i2, o2.paint.get("circle-translate"), o2.paint.get("circle-translate-anchor")), u_pitch_with_map: +s2, u_device_pixel_ratio: t2.pixelRatio, u_extrude_scale: r2 };
        }, ge = (t2, e3, i2) => {
          const o2 = It(i2, 1, e3.zoom), a2 = Math.pow(2, e3.zoom - i2.tileID.overscaledZ), s2 = i2.tileID.overscaleFactor();
          return { u_matrix: t2, u_camera_to_center_distance: e3.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e3.pixelsToGLUnits[0] / (o2 * a2), e3.pixelsToGLUnits[1] / (o2 * a2)], u_overscale_factor: s2 };
        }, xe = (t2, e3, i2 = 1) => ({ u_matrix: t2, u_color: e3, u_overlay: 0, u_overlay_scale: i2 }), ve = (t2) => ({ u_matrix: t2 }), ye = (t2, e3, i2, o2) => ({ u_matrix: t2, u_extrude_scale: It(e3, 1, i2), u_intensity: o2 });
        function be(e3, i2) {
          const o2 = Math.pow(2, i2.canonical.z), a2 = i2.canonical.y;
          return [new t.MercatorCoordinate(0, a2 / o2).toLngLat().lat, new t.MercatorCoordinate(0, (a2 + 1) / o2).toLngLat().lat];
        }
        const we = (t2, e3, i2) => {
          const o2 = t2.transform;
          return { u_matrix: Ce(t2, e3, i2), u_ratio: 1 / It(e3, 1, o2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
        }, Te = (e3, i2, o2, a2) => t.extend(we(e3, i2, o2), { u_image: 0, u_image_height: a2 }), Ee = (t2, e3, i2, o2) => {
          const a2 = t2.transform, s2 = Se(e3, a2);
          return { u_matrix: Ce(t2, e3, i2), u_texsize: e3.imageAtlasTexture.size, u_ratio: 1 / It(e3, 1, a2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_image: 0, u_scale: [s2, o2.fromScale, o2.toScale], u_fade: o2.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
        }, Ie = (e3, i2, o2, a2, s2) => {
          const r2 = e3.lineAtlas, n2 = Se(i2, e3.transform), l2 = "round" === o2.layout.get("line-cap"), c2 = r2.getDash(a2.from, l2), h2 = r2.getDash(a2.to, l2), u2 = c2.width * s2.fromScale, d2 = h2.width * s2.toScale;
          return t.extend(we(e3, i2, o2), { u_patternscale_a: [n2 / u2, -c2.height / 2], u_patternscale_b: [n2 / d2, -h2.height / 2], u_sdfgamma: r2.width / (256 * Math.min(u2, d2) * e3.pixelRatio) / 2, u_image: 0, u_tex_y_a: c2.y, u_tex_y_b: h2.y, u_mix: s2.t });
        };
        function Se(t2, e3) {
          return 1 / It(t2, 1, e3.tileZoom);
        }
        function Ce(t2, e3, i2) {
          return t2.translatePosMatrix(e3.tileID.posMatrix, e3, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
        }
        const Pe = (t2, e3, i2, o2, a2) => {
          return { u_matrix: t2, u_tl_parent: e3, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (r2 = a2.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2), u_contrast_factor: (s2 = a2.paint.get("raster-contrast"), s2 > 0 ? 1 / (1 - s2) : 1 + s2), u_spin_weights: ze(a2.paint.get("raster-hue-rotate")) };
          var s2, r2;
        };
        function ze(t2) {
          t2 *= Math.PI / 180;
          const e3 = Math.sin(t2), i2 = Math.cos(t2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e3 - i2 + 1) / 3, (Math.sqrt(3) * e3 - i2 + 1) / 3];
        }
        const De = (t2, e3, i2, o2, a2, s2, r2, n2, l2, c2) => {
          const h2 = a2.transform;
          return { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: e3 ? e3.uSizeT : 0, u_size: e3 ? e3.uSize : 0, u_camera_to_center_distance: h2.cameraToCenterDistance, u_pitch: h2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: h2.width / h2.height, u_fade_change: a2.options.fadeDuration ? a2.symbolFadeChange : 1, u_matrix: s2, u_label_plane_matrix: r2, u_coord_matrix: n2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
        }, Ae = (e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2) => {
          const d2 = s2.transform;
          return t.extend(De(e3, i2, o2, a2, s2, r2, n2, l2, c2, h2), { u_gamma_scale: a2 ? Math.cos(d2._pitch) * d2.cameraToCenterDistance : 1, u_device_pixel_ratio: s2.pixelRatio, u_is_halo: +u2 });
        }, Me = (e3, i2, o2, a2, s2, r2, n2, l2, c2, h2) => t.extend(Ae(e3, i2, o2, a2, s2, r2, n2, l2, true, c2, true), { u_texsize_icon: h2, u_texture_icon: 1 }), Le = (t2, e3, i2) => ({ u_matrix: t2, u_opacity: e3, u_color: i2 }), Re = (e3, i2, o2, a2, s2, r2) => t.extend(function(t2, e4, i3, o3) {
          const a3 = i3.imageManager.getPattern(t2.from.toString()), s3 = i3.imageManager.getPattern(t2.to.toString()), { width: r3, height: n2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, h2 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l2), u2 = c2 * o3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: s3.tl, u_pattern_br_b: s3.br, u_texsize: [r3, n2], u_mix: e4.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: s3.displaySize, u_scale_a: e4.fromScale, u_scale_b: e4.toScale, u_tile_units_to_pixels: 1 / It(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & u2] };
        }(a2, r2, o2, s2), { u_matrix: e3, u_opacity: i2 }), ke = { fillExtrusion: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_lightpos: new t.Uniform3f(e3, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e3, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e3, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e3, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e3, i2.u_opacity) }), fillExtrusionPattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_lightpos: new t.Uniform3f(e3, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e3, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e3, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e3, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e3, i2.u_height_factor), u_image: new t.Uniform1i(e3, i2.u_image), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade), u_opacity: new t.Uniform1f(e3, i2.u_opacity) }), fill: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), fillPattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_image: new t.Uniform1i(e3, i2.u_image), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade) }), fillOutline: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_world: new t.Uniform2f(e3, i2.u_world) }), fillOutlinePattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_world: new t.Uniform2f(e3, i2.u_world), u_image: new t.Uniform1i(e3, i2.u_image), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade) }), circle: (e3, i2) => ({ u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e3, i2.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e3, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), collisionBox: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e3, i2.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e3, i2.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e3, i2.u_overscale_factor) }), collisionCircle: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e3, i2.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e3, i2.u_viewport_size) }), debug: (e3, i2) => ({ u_color: new t.UniformColor(e3, i2.u_color), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_overlay: new t.Uniform1i(e3, i2.u_overlay), u_overlay_scale: new t.Uniform1f(e3, i2.u_overlay_scale) }), clippingMask: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), heatmap: (e3, i2) => ({ u_extrude_scale: new t.Uniform1f(e3, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e3, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), heatmapTexture: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_world: new t.Uniform2f(e3, i2.u_world), u_image: new t.Uniform1i(e3, i2.u_image), u_color_ramp: new t.Uniform1i(e3, i2.u_color_ramp), u_opacity: new t.Uniform1f(e3, i2.u_opacity) }), hillshade: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_image: new t.Uniform1i(e3, i2.u_image), u_latrange: new t.Uniform2f(e3, i2.u_latrange), u_light: new t.Uniform2f(e3, i2.u_light), u_shadow: new t.UniformColor(e3, i2.u_shadow), u_highlight: new t.UniformColor(e3, i2.u_highlight), u_accent: new t.UniformColor(e3, i2.u_accent) }), hillshadePrepare: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_image: new t.Uniform1i(e3, i2.u_image), u_dimension: new t.Uniform2f(e3, i2.u_dimension), u_zoom: new t.Uniform1f(e3, i2.u_zoom), u_unpack: new t.Uniform4f(e3, i2.u_unpack) }), line: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels) }), lineGradient: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels), u_image: new t.Uniform1i(e3, i2.u_image), u_image_height: new t.Uniform1f(e3, i2.u_image_height) }), linePattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e3, i2.u_image), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade) }), lineSDF: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e3, i2.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e3, i2.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e3, i2.u_sdfgamma), u_image: new t.Uniform1i(e3, i2.u_image), u_tex_y_a: new t.Uniform1f(e3, i2.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e3, i2.u_tex_y_b), u_mix: new t.Uniform1f(e3, i2.u_mix) }), raster: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_tl_parent: new t.Uniform2f(e3, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e3, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e3, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e3, i2.u_fade_t), u_opacity: new t.Uniform1f(e3, i2.u_opacity), u_image0: new t.Uniform1i(e3, i2.u_image0), u_image1: new t.Uniform1i(e3, i2.u_image1), u_brightness_low: new t.Uniform1f(e3, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e3, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e3, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e3, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e3, i2.u_spin_weights) }), symbolIcon: (e3, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e3, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e3, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e3, i2.u_size_t), u_size: new t.Uniform1f(e3, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e3, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e3, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e3, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e3, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e3, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e3, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e3, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_texture: new t.Uniform1i(e3, i2.u_texture) }), symbolSDF: (e3, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e3, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e3, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e3, i2.u_size_t), u_size: new t.Uniform1f(e3, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e3, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e3, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e3, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e3, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e3, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e3, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e3, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_texture: new t.Uniform1i(e3, i2.u_texture), u_gamma_scale: new t.Uniform1f(e3, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e3, i2.u_is_halo) }), symbolTextAndIcon: (e3, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e3, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e3, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e3, i2.u_size_t), u_size: new t.Uniform1f(e3, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e3, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e3, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e3, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e3, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e3, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e3, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e3, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e3, i2.u_texsize_icon), u_texture: new t.Uniform1i(e3, i2.u_texture), u_texture_icon: new t.Uniform1i(e3, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e3, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e3, i2.u_is_halo) }), background: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_opacity: new t.Uniform1f(e3, i2.u_opacity), u_color: new t.UniformColor(e3, i2.u_color) }), backgroundPattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_opacity: new t.Uniform1f(e3, i2.u_opacity), u_image: new t.Uniform1i(e3, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e3, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e3, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e3, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e3, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_mix: new t.Uniform1f(e3, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e3, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e3, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e3, i2.u_scale_a), u_scale_b: new t.Uniform1f(e3, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e3, i2.u_tile_units_to_pixels) }) };
        class Be {
          constructor(t2, e3, i2) {
            this.context = t2;
            const o2 = t2.gl;
            this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e3.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e3.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t2) {
            const e3 = this.context.gl;
            this.context.unbindVAO(), this.bind(), e3.bufferSubData(e3.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Fe = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Oe {
          constructor(t2, e3, i2, o2) {
            this.length = e3.length, this.attributes = i2, this.itemSize = e3.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
            const a2 = t2.gl;
            this.buffer = a2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, e3.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e3.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t2) {
            const e3 = this.context.gl;
            this.bind(), e3.bufferSubData(e3.ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          enableAttributes(t2, e3) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              const o2 = e3.attributes[this.attributes[i2].name];
              void 0 !== o2 && t2.enableVertexAttribArray(o2);
            }
          }
          setVertexAttribPointers(t2, e3, i2) {
            for (let o2 = 0; o2 < this.attributes.length; o2++) {
              const a2 = this.attributes[o2], s2 = e3.attributes[a2.name];
              void 0 !== s2 && t2.vertexAttribPointer(s2, a2.components, t2[Fe[a2.type]], false, this.itemSize, a2.offset + this.itemSize * (i2 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Ue {
          constructor(t2) {
            this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(t2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ne extends Ue {
          getDefault() {
            return t.Color.transparent;
          }
          set(t2) {
            const e3 = this.current;
            (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }
        }
        class Ge extends Ue {
          getDefault() {
            return 1;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
          }
        }
        class Ze extends Ue {
          getDefault() {
            return 0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
          }
        }
        class qe extends Ue {
          getDefault() {
            return [true, true, true, true];
          }
          set(t2) {
            const e3 = this.current;
            (t2[0] !== e3[0] || t2[1] !== e3[1] || t2[2] !== e3[2] || t2[3] !== e3[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
          }
        }
        class Ve extends Ue {
          getDefault() {
            return true;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
          }
        }
        class je extends Ue {
          getDefault() {
            return 255;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
          }
        }
        class $e extends Ue {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t2) {
            const e3 = this.current;
            (t2.func !== e3.func || t2.ref !== e3.ref || t2.mask !== e3.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
          }
        }
        class We extends Ue {
          getDefault() {
            const t2 = this.gl;
            return [t2.KEEP, t2.KEEP, t2.KEEP];
          }
          set(t2) {
            const e3 = this.current;
            (t2[0] !== e3[0] || t2[1] !== e3[1] || t2[2] !== e3[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
          }
        }
        class Xe extends Ue {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            t2 ? e3.enable(e3.STENCIL_TEST) : e3.disable(e3.STENCIL_TEST), this.current = t2, this.dirty = false;
          }
        }
        class He extends Ue {
          getDefault() {
            return [0, 1];
          }
          set(t2) {
            const e3 = this.current;
            (t2[0] !== e3[0] || t2[1] !== e3[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
          }
        }
        class Ke extends Ue {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            t2 ? e3.enable(e3.DEPTH_TEST) : e3.disable(e3.DEPTH_TEST), this.current = t2, this.dirty = false;
          }
        }
        class Ye extends Ue {
          getDefault() {
            return this.gl.LESS;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
          }
        }
        class Je extends Ue {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            t2 ? e3.enable(e3.BLEND) : e3.disable(e3.BLEND), this.current = t2, this.dirty = false;
          }
        }
        class Qe extends Ue {
          getDefault() {
            const t2 = this.gl;
            return [t2.ONE, t2.ZERO];
          }
          set(t2) {
            const e3 = this.current;
            (t2[0] !== e3[0] || t2[1] !== e3[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
          }
        }
        class ti extends Ue {
          getDefault() {
            return t.Color.transparent;
          }
          set(t2) {
            const e3 = this.current;
            (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }
        }
        class ei extends Ue {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
          }
        }
        class ii extends Ue {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            t2 ? e3.enable(e3.CULL_FACE) : e3.disable(e3.CULL_FACE), this.current = t2, this.dirty = false;
          }
        }
        class oi extends Ue {
          getDefault() {
            return this.gl.BACK;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
          }
        }
        class ai extends Ue {
          getDefault() {
            return this.gl.CCW;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
          }
        }
        class si extends Ue {
          getDefault() {
            return null;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
          }
        }
        class ri extends Ue {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
          }
        }
        class ni extends Ue {
          getDefault() {
            const t2 = this.gl;
            return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
          }
          set(t2) {
            const e3 = this.current;
            (t2[0] !== e3[0] || t2[1] !== e3[1] || t2[2] !== e3[2] || t2[3] !== e3[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
          }
        }
        class li extends Ue {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            e3.bindFramebuffer(e3.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class ci extends Ue {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            e3.bindRenderbuffer(e3.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class hi extends Ue {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            e3.bindTexture(e3.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
          }
        }
        class ui extends Ue {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            e3.bindBuffer(e3.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class di extends Ue {
          getDefault() {
            return null;
          }
          set(t2) {
            const e3 = this.gl;
            e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class mi extends Ue {
          constructor(t2) {
            super(t2), this.vao = t2.extVertexArrayObject;
          }
          getDefault() {
            return null;
          }
          set(t2) {
            this.vao && (t2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t2), this.current = t2, this.dirty = false);
          }
        }
        class _i extends Ue {
          getDefault() {
            return 4;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            e3.pixelStorei(e3.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
          }
        }
        class pi extends Ue {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
          }
        }
        class fi extends Ue {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e3 = this.gl;
            e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
          }
        }
        class gi extends Ue {
          constructor(t2, e3) {
            super(t2), this.context = t2, this.parent = e3;
          }
          getDefault() {
            return null;
          }
        }
        class xi extends gi {
          setDirty() {
            this.dirty = true;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e3 = this.gl;
            e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
          }
        }
        class vi extends gi {
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e3 = this.gl;
            e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class yi {
          constructor(t2, e3, i2, o2) {
            this.context = t2, this.width = e3, this.height = i2;
            const a2 = this.framebuffer = t2.gl.createFramebuffer();
            this.colorAttachment = new xi(t2, a2), o2 && (this.depthAttachment = new vi(t2, a2));
          }
          destroy() {
            const t2 = this.context.gl, e3 = this.colorAttachment.get();
            if (e3 && t2.deleteTexture(e3), this.depthAttachment) {
              const e4 = this.depthAttachment.get();
              e4 && t2.deleteRenderbuffer(e4);
            }
            t2.deleteFramebuffer(this.framebuffer);
          }
        }
        class bi {
          constructor(t2, e3, i2) {
            this.blendFunction = t2, this.blendColor = e3, this.mask = i2;
          }
        }
        bi.Replace = [1, 0], bi.disabled = new bi(bi.Replace, t.Color.transparent, [false, false, false, false]), bi.unblended = new bi(bi.Replace, t.Color.transparent, [true, true, true, true]), bi.alphaBlended = new bi([1, 771], t.Color.transparent, [true, true, true, true]);
        class wi {
          constructor(t2) {
            this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new Ne(this), this.clearDepth = new Ge(this), this.clearStencil = new Ze(this), this.colorMask = new qe(this), this.depthMask = new Ve(this), this.stencilMask = new je(this), this.stencilFunc = new $e(this), this.stencilOp = new We(this), this.stencilTest = new Xe(this), this.depthRange = new He(this), this.depthTest = new Ke(this), this.depthFunc = new Ye(this), this.blend = new Je(this), this.blendFunc = new Qe(this), this.blendColor = new ti(this), this.blendEquation = new ei(this), this.cullFace = new ii(this), this.cullFaceSide = new oi(this), this.frontFace = new ai(this), this.program = new si(this), this.activeTexture = new ri(this), this.viewport = new ni(this), this.bindFramebuffer = new li(this), this.bindRenderbuffer = new ci(this), this.bindTexture = new hi(this), this.bindVertexBuffer = new ui(this), this.bindElementBuffer = new di(this), this.bindVertexArrayOES = this.extVertexArrayObject && new mi(this), this.pixelStoreUnpack = new _i(this), this.pixelStoreUnpackPremultiplyAlpha = new pi(this), this.pixelStoreUnpackFlipY = new fi(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(t2, e3) {
            return new Be(this, t2, e3);
          }
          createVertexBuffer(t2, e3, i2) {
            return new Oe(this, t2, e3, i2);
          }
          createRenderbuffer(t2, e3, i2) {
            const o2 = this.gl, a2 = o2.createRenderbuffer();
            return this.bindRenderbuffer.set(a2), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e3, i2), this.bindRenderbuffer.set(null), a2;
          }
          createFramebuffer(t2, e3, i2) {
            return new yi(this, t2, e3, i2);
          }
          clear({ color: t2, depth: e3 }) {
            const i2 = this.gl;
            let o2 = 0;
            t2 && (o2 |= i2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), void 0 !== e3 && (o2 |= i2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e3), this.depthMask.set(true)), i2.clear(o2);
          }
          setCullFace(t2) {
            false === t2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
          }
          setDepthMode(t2) {
            t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
          }
          setStencilMode(t2) {
            t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(t2) {
            a(t2.blendFunction, bi.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
          }
          unbindVAO() {
            this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
          }
        }
        class Ti {
          constructor(t2, e3, i2) {
            this.func = t2, this.mask = e3, this.range = i2;
          }
        }
        Ti.ReadOnly = false, Ti.ReadWrite = true, Ti.disabled = new Ti(519, Ti.ReadOnly, [0, 1]);
        const Ei = 7680;
        class Ii {
          constructor(t2, e3, i2, o2, a2, s2) {
            this.test = t2, this.ref = e3, this.mask = i2, this.fail = o2, this.depthFail = a2, this.pass = s2;
          }
        }
        Ii.disabled = new Ii({ func: 519, mask: 0 }, 0, 0, Ei, Ei, Ei);
        class Si {
          constructor(t2, e3, i2) {
            this.enable = t2, this.mode = e3, this.frontFace = i2;
          }
        }
        let Ci;
        function Pi(e3, i2, o2, a2, s2, r2, n2) {
          const l2 = e3.context, c2 = l2.gl, h2 = e3.useProgram("collisionBox"), u2 = [];
          let d2 = 0, m2 = 0;
          for (let _3 = 0; _3 < a2.length; _3++) {
            const p3 = a2[_3], f3 = i2.getTile(p3), g3 = f3.getBucket(o2);
            if (!g3)
              continue;
            let x3 = p3.posMatrix;
            0 === s2[0] && 0 === s2[1] || (x3 = e3.translatePosMatrix(p3.posMatrix, f3, s2, r2));
            const v3 = n2 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
            if (y2.length > 0) {
              const i3 = t.create(), o3 = x3;
              t.mul(i3, g3.placementInvProjMatrix, e3.transform.glCoordMatrix), t.mul(i3, i3, g3.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: m2, transform: o3, invTransform: i3 }), d2 += y2.length / 4, m2 = d2;
            }
            v3 && h2.draw(l2, c2.LINES, Ti.disabled, Ii.disabled, e3.colorModeForRenderPass(), Si.disabled, ge(x3, e3.transform, f3), o2.id, v3.layoutVertexBuffer, v3.indexBuffer, v3.segments, null, e3.transform.zoom, null, null, v3.collisionVertexBuffer);
          }
          if (!n2 || !u2.length)
            return;
          const _2 = e3.useProgram("collisionCircle"), p2 = new t.CollisionCircleLayoutArray();
          p2.resize(4 * d2), p2._trim();
          let f2 = 0;
          for (const t2 of u2)
            for (let e4 = 0; e4 < t2.circleArray.length / 4; e4++) {
              const i3 = 4 * e4, o3 = t2.circleArray[i3 + 0], a3 = t2.circleArray[i3 + 1], s3 = t2.circleArray[i3 + 2], r3 = t2.circleArray[i3 + 3];
              p2.emplace(f2++, o3, a3, s3, r3, 0), p2.emplace(f2++, o3, a3, s3, r3, 1), p2.emplace(f2++, o3, a3, s3, r3, 2), p2.emplace(f2++, o3, a3, s3, r3, 3);
            }
          (!Ci || Ci.length < 2 * d2) && (Ci = function(e4) {
            const i3 = 2 * e4, o3 = new t.QuadTriangleArray();
            o3.resize(i3), o3._trim();
            for (let t2 = 0; t2 < i3; t2++) {
              const e5 = 6 * t2;
              o3.uint16[e5 + 0] = 4 * t2 + 0, o3.uint16[e5 + 1] = 4 * t2 + 1, o3.uint16[e5 + 2] = 4 * t2 + 2, o3.uint16[e5 + 3] = 4 * t2 + 2, o3.uint16[e5 + 4] = 4 * t2 + 3, o3.uint16[e5 + 5] = 4 * t2 + 0;
            }
            return o3;
          }(d2));
          const g2 = l2.createIndexBuffer(Ci, true), x2 = l2.createVertexBuffer(p2, t.collisionCircleLayout.members, true);
          for (const i3 of u2) {
            const a3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (v2 = e3.transform).cameraToCenterDistance, u_viewport_size: [v2.width, v2.height] };
            _2.draw(l2, c2.TRIANGLES, Ti.disabled, Ii.disabled, e3.colorModeForRenderPass(), Si.disabled, a3, o2.id, x2, g2, t.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e3.transform.zoom, null, null, null);
          }
          var v2;
          x2.destroy(), g2.destroy();
        }
        Si.disabled = new Si(false, 1029, 2305), Si.backCCW = new Si(true, 1029, 2305);
        const zi = t.identity(new Float32Array(16));
        function Di(e3, i2, o2, a2, s2, r2) {
          const { horizontalAlign: n2, verticalAlign: l2 } = t.getAnchorAlignment(e3), c2 = -(n2 - 0.5) * i2, h2 = -(l2 - 0.5) * o2, u2 = t.evaluateVariableOffset(e3, a2);
          return new t.pointGeometry((c2 / s2 + u2[0]) * r2, (h2 / s2 + u2[1]) * r2);
        }
        function Ai(e3, i2, o2, a2, s2, r2, n2, l2, c2, h2) {
          const u2 = e3.text.placedSymbolArray, d2 = e3.text.dynamicLayoutVertexArray, m2 = e3.icon.dynamicLayoutVertexArray, _2 = {};
          d2.clear();
          for (let m3 = 0; m3 < u2.length; m3++) {
            const p2 = u2.get(m3), f2 = e3.allowVerticalPlacement && !p2.placedOrientation, g2 = p2.hidden || !p2.crossTileID || f2 ? null : a2[p2.crossTileID];
            if (g2) {
              const a3 = new t.pointGeometry(p2.anchorX, p2.anchorY), u3 = ut(a3, o2 ? n2 : r2), m4 = dt(s2.cameraToCenterDistance, u3.signedDistanceFromCamera);
              let f3 = t.evaluateSizeForFeature(e3.textSizeData, c2, p2) * m4 / t.ONE_EM;
              o2 && (f3 *= e3.tilePixelRatio / l2);
              const { width: x2, height: v2, anchor: y2, textOffset: b2, textBoxScale: w2 } = g2, T2 = Di(y2, x2, v2, b2, w2, f3), E2 = o2 ? ut(a3.add(T2), r2).point : u3.point.add(i2 ? T2.rotate(-s2.angle) : T2), I2 = e3.allowVerticalPlacement && p2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
              for (let e4 = 0; e4 < p2.numGlyphs; e4++)
                t.addDynamicAttributes(d2, E2, I2);
              h2 && p2.associatedIconIndex >= 0 && (_2[p2.associatedIconIndex] = { shiftedAnchor: E2, angle: I2 });
            } else
              bt(p2.numGlyphs, d2);
          }
          if (h2) {
            m2.clear();
            const i3 = e3.icon.placedSymbolArray;
            for (let e4 = 0; e4 < i3.length; e4++) {
              const o3 = i3.get(e4);
              if (o3.hidden)
                bt(o3.numGlyphs, m2);
              else {
                const i4 = _2[e4];
                if (i4)
                  for (let e5 = 0; e5 < o3.numGlyphs; e5++)
                    t.addDynamicAttributes(m2, i4.shiftedAnchor, i4.angle);
                else
                  bt(o3.numGlyphs, m2);
              }
            }
            e3.icon.dynamicLayoutVertexBuffer.updateData(m2);
          }
          e3.text.dynamicLayoutVertexBuffer.updateData(d2);
        }
        function Mi(t2, e3, i2) {
          return i2.iconsInText && e3 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
        }
        function Li(e3, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2) {
          const m2 = e3.context, _2 = m2.gl, p2 = e3.transform, f2 = "map" === l2, g2 = "map" === c2, x2 = "viewport" !== l2 && "point" !== o2.layout.get("symbol-placement"), v2 = f2 && !g2 && !x2, y2 = !o2.layout.get("symbol-sort-key").isConstant();
          let b2 = false;
          const w2 = e3.depthModeForSublayer(0, Ti.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [];
          for (const l3 of a2) {
            const a3 = i2.getTile(l3), c3 = a3.getBucket(o2);
            if (!c3)
              continue;
            const u3 = s2 ? c3.text : c3.icon;
            if (!u3 || !u3.segments.get().length)
              continue;
            const d3 = u3.programConfigurations.get(o2.id), m3 = s2 || c3.sdfIcons, w3 = s2 ? c3.textSizeData : c3.iconSizeData, I2 = g2 || 0 !== p2.pitch, S2 = e3.useProgram(Mi(m3, s2, c3), d3), C2 = t.evaluateSizeForZoom(w3, p2.zoom);
            let P2, z2, D2, A2, M2 = [0, 0], L2 = null;
            if (s2) {
              if (z2 = a3.glyphAtlasTexture, D2 = _2.LINEAR, P2 = a3.glyphAtlasTexture.size, c3.iconsInText) {
                M2 = a3.imageAtlasTexture.size, L2 = a3.imageAtlasTexture;
                const t2 = "composite" === w3.kind || "camera" === w3.kind;
                A2 = I2 || e3.options.rotating || e3.options.zooming || t2 ? _2.LINEAR : _2.NEAREST;
              }
            } else {
              const t2 = 1 !== o2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
              z2 = a3.imageAtlasTexture, D2 = m3 || e3.options.rotating || e3.options.zooming || t2 || I2 ? _2.LINEAR : _2.NEAREST, P2 = a3.imageAtlasTexture.size;
            }
            const R2 = It(a3, 1, e3.transform.zoom), k2 = ct(l3.posMatrix, g2, f2, e3.transform, R2), B2 = ht(l3.posMatrix, g2, f2, e3.transform, R2), F2 = T2 && c3.hasTextData(), O2 = "none" !== o2.layout.get("icon-text-fit") && F2 && c3.hasIconData();
            if (x2) {
              const t2 = "map" === o2.layout.get("text-rotation-alignment");
              _t(c3, l3.posMatrix, e3, s2, k2, B2, g2, h2, t2);
            }
            const U2 = e3.translatePosMatrix(l3.posMatrix, a3, r2, n2), N2 = x2 || s2 && T2 || O2 ? zi : k2, G2 = e3.translatePosMatrix(B2, a3, r2, n2, true), Z2 = m3 && 0 !== o2.paint.get(s2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let q2;
            q2 = m3 ? c3.iconsInText ? Me(w3.kind, C2, v2, g2, e3, U2, N2, G2, P2, M2) : Ae(w3.kind, C2, v2, g2, e3, U2, N2, G2, s2, P2, true) : De(w3.kind, C2, v2, g2, e3, U2, N2, G2, s2, P2);
            const V2 = { program: S2, buffers: u3, uniformValues: q2, atlasTexture: z2, atlasTextureIcon: L2, atlasInterpolation: D2, atlasInterpolationIcon: A2, isSDF: m3, hasHalo: Z2 };
            if (y2 && c3.canOverlap) {
              b2 = true;
              const e4 = u3.segments.get();
              for (const i3 of e4)
                E2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: V2 });
            } else
              E2.push({ segments: u3.segments, sortKey: 0, state: V2 });
          }
          b2 && E2.sort((t2, e4) => t2.sortKey - e4.sortKey);
          for (const t2 of E2) {
            const i3 = t2.state;
            if (m2.activeTexture.set(_2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, _2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (m2.activeTexture.set(_2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, _2.CLAMP_TO_EDGE)), i3.isSDF) {
              const a3 = i3.uniformValues;
              i3.hasHalo && (a3.u_is_halo = 1, Ri(i3.buffers, t2.segments, o2, e3, i3.program, w2, u2, d2, a3)), a3.u_is_halo = 0;
            }
            Ri(i3.buffers, t2.segments, o2, e3, i3.program, w2, u2, d2, i3.uniformValues);
          }
        }
        function Ri(t2, e3, i2, o2, a2, s2, r2, n2, l2) {
          const c2 = o2.context;
          a2.draw(c2, c2.gl.TRIANGLES, s2, r2, n2, Si.disabled, l2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e3, i2.paint, o2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
        }
        function ki(t2, e3, i2, o2, a2, s2, r2) {
          const n2 = t2.context.gl, l2 = i2.paint.get("fill-pattern"), c2 = l2 && l2.constantOr(1), h2 = i2.getCrossfadeParameters();
          let u2, d2, m2, _2, p2;
          r2 ? (d2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = n2.LINES) : (d2 = c2 ? "fillPattern" : "fill", u2 = n2.TRIANGLES);
          for (const f2 of o2) {
            const o3 = e3.getTile(f2);
            if (c2 && !o3.patternsLoaded())
              continue;
            const g2 = o3.getBucket(i2);
            if (!g2)
              continue;
            const x2 = g2.programConfigurations.get(i2.id), v2 = t2.useProgram(d2, x2);
            c2 && (t2.context.activeTexture.set(n2.TEXTURE0), o3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers(h2));
            const y2 = l2.constantOr(null);
            if (y2 && o3.imageAtlas) {
              const t3 = o3.imageAtlas, e4 = t3.patternPositions[y2.to.toString()], i3 = t3.patternPositions[y2.from.toString()];
              e4 && i3 && x2.setConstantPatternPositions(e4, i3);
            }
            const b2 = t2.translatePosMatrix(f2.posMatrix, o3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
            if (r2) {
              _2 = g2.indexBuffer2, p2 = g2.segments2;
              const e4 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
              m2 = "fillOutlinePattern" === d2 && c2 ? pe(b2, t2, h2, o3, e4) : _e(b2, e4);
            } else
              _2 = g2.indexBuffer, p2 = g2.segments, m2 = c2 ? me(b2, t2, h2, o3) : de(b2);
            v2.draw(t2.context, u2, a2, t2.stencilModeForClipping(f2), s2, Si.disabled, m2, i2.id, g2.layoutVertexBuffer, _2, p2, i2.paint, t2.transform.zoom, x2);
          }
        }
        function Bi(t2, e3, i2, o2, a2, s2, r2) {
          const n2 = t2.context, l2 = n2.gl, c2 = i2.paint.get("fill-extrusion-pattern"), h2 = c2.constantOr(1), u2 = i2.getCrossfadeParameters(), d2 = i2.paint.get("fill-extrusion-opacity");
          for (const m2 of o2) {
            const o3 = e3.getTile(m2), _2 = o3.getBucket(i2);
            if (!_2)
              continue;
            const p2 = _2.programConfigurations.get(i2.id), f2 = t2.useProgram(h2 ? "fillExtrusionPattern" : "fillExtrusion", p2);
            h2 && (t2.context.activeTexture.set(l2.TEXTURE0), o3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), p2.updatePaintBuffers(u2));
            const g2 = c2.constantOr(null);
            if (g2 && o3.imageAtlas) {
              const t3 = o3.imageAtlas, e4 = t3.patternPositions[g2.to.toString()], i3 = t3.patternPositions[g2.from.toString()];
              e4 && i3 && p2.setConstantPatternPositions(e4, i3);
            }
            const x2 = t2.translatePosMatrix(m2.posMatrix, o3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), v2 = i2.paint.get("fill-extrusion-vertical-gradient"), y2 = h2 ? ue(x2, t2, v2, d2, m2, u2, o3) : he(x2, t2, v2, d2);
            f2.draw(n2, n2.gl.TRIANGLES, a2, s2, r2, Si.backCCW, y2, i2.id, _2.layoutVertexBuffer, _2.indexBuffer, _2.segments, i2.paint, t2.transform.zoom, p2);
          }
        }
        function Fi(t2, e3, i2, o2, a2, s2) {
          const r2 = t2.context, n2 = r2.gl, l2 = e3.fbo;
          if (!l2)
            return;
          const c2 = t2.useProgram("hillshade");
          r2.activeTexture.set(n2.TEXTURE0), n2.bindTexture(n2.TEXTURE_2D, l2.colorAttachment.get());
          const h2 = ((t3, e4, i3) => {
            const o3 = i3.paint.get("hillshade-shadow-color"), a3 = i3.paint.get("hillshade-highlight-color"), s3 = i3.paint.get("hillshade-accent-color");
            let r3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i3.paint.get("hillshade-illumination-anchor") && (r3 -= t3.transform.angle);
            const n3 = !t3.options.moving;
            return { u_matrix: t3.transform.calculatePosMatrix(e4.tileID.toUnwrapped(), n3), u_image: 0, u_latrange: be(0, e4.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), r3], u_shadow: o3, u_highlight: a3, u_accent: s3 };
          })(t2, e3, i2);
          c2.draw(r2, n2.TRIANGLES, o2, a2, s2, Si.disabled, h2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
        }
        function Oi(e3, i2, o2, a2, s2, r2) {
          const n2 = e3.context, l2 = n2.gl, c2 = i2.dem;
          if (c2 && c2.data) {
            const h2 = c2.dim, u2 = c2.stride, m2 = c2.getPixels();
            if (n2.activeTexture.set(l2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || e3.getTileTexture(u2), i2.demTexture) {
              const t2 = i2.demTexture;
              t2.update(m2, { premultiply: false }), t2.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            } else
              i2.demTexture = new d(n2, m2, l2.RGBA, { premultiply: false }), i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            n2.activeTexture.set(l2.TEXTURE0);
            let _2 = i2.fbo;
            if (!_2) {
              const t2 = new d(n2, { width: h2, height: h2, data: null }, l2.RGBA);
              t2.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), _2 = i2.fbo = n2.createFramebuffer(h2, h2, true), _2.colorAttachment.set(t2.texture);
            }
            n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, h2, h2]), e3.useProgram("hillshadePrepare").draw(n2, l2.TRIANGLES, a2, s2, r2, Si.disabled, ((e4, i3) => {
              const o3 = i3.stride, a3 = t.create();
              return t.ortho(a3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(a3, a3, [0, -t.EXTENT, 0]), { u_matrix: a3, u_image: 1, u_dimension: [o3, o3], u_zoom: e4.overscaledZ, u_unpack: i3.getUnpackVector() };
            })(i2.tileID, c2), o2.id, e3.rasterBoundsBuffer, e3.quadTriangleIndexBuffer, e3.rasterBoundsSegments), i2.needsHillshadePrepare = false;
          }
        }
        function Ui(e3, i2, o2, a2, s2) {
          const r2 = a2.paint.get("raster-fade-duration");
          if (r2 > 0) {
            const a3 = t.exported.now(), n2 = (a3 - e3.timeAdded) / r2, l2 = i2 ? (a3 - i2.timeAdded) / r2 : -1, c2 = o2.getSource(), h2 = s2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(e3.tileID.overscaledZ - h2), d2 = u2 && e3.refreshedUponExpiration ? 1 : t.clamp(u2 ? n2 : 1 - l2, 0, 1);
            return e3.refreshedUponExpiration && n2 >= 1 && (e3.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Ni = new t.Color(1, 0, 0, 1), Gi = new t.Color(0, 1, 0, 1), Zi = new t.Color(0, 0, 1, 1), qi = new t.Color(1, 0, 1, 1), Vi = new t.Color(0, 1, 1, 1);
        function ji(t2, e3, i2, o2) {
          Wi(t2, 0, e3 + i2 / 2, t2.transform.width, i2, o2);
        }
        function $i(t2, e3, i2, o2) {
          Wi(t2, e3 - i2 / 2, 0, i2, t2.transform.height, o2);
        }
        function Wi(t2, e3, i2, o2, a2, s2) {
          const r2 = t2.context, n2 = r2.gl;
          n2.enable(n2.SCISSOR_TEST), n2.scissor(e3 * t2.pixelRatio, i2 * t2.pixelRatio, o2 * t2.pixelRatio, a2 * t2.pixelRatio), r2.clear({ color: s2 }), n2.disable(n2.SCISSOR_TEST);
        }
        function Xi(e3, i2, o2) {
          const a2 = e3.context, s2 = a2.gl, r2 = o2.posMatrix, n2 = e3.useProgram("debug"), l2 = Ti.disabled, c2 = Ii.disabled, h2 = e3.colorModeForRenderPass(), u2 = "$debug";
          a2.activeTexture.set(s2.TEXTURE0), e3.emptyTexture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), n2.draw(a2, s2.LINE_STRIP, l2, c2, h2, Si.disabled, xe(r2, t.Color.red), u2, e3.debugBuffer, e3.tileBorderIndexBuffer, e3.debugSegments);
          const d2 = i2.getTileByID(o2.key).latestRawTileData, m2 = Math.floor((d2 && d2.byteLength || 0) / 1024), _2 = i2.getTile(o2).tileSize, p2 = 512 / Math.min(_2, 512) * (o2.overscaledZ / e3.transform.zoom) * 0.5;
          let f2 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (f2 += ` => ${o2.overscaledZ}`), function(t2, e4) {
            t2.initDebugOverlayCanvas();
            const i3 = t2.debugOverlayCanvas, o3 = t2.context.gl, a3 = t2.debugOverlayCanvas.getContext("2d");
            a3.clearRect(0, 0, i3.width, i3.height), a3.shadowColor = "white", a3.shadowBlur = 2, a3.lineWidth = 1.5, a3.strokeStyle = "white", a3.textBaseline = "top", a3.font = "bold 36px Open Sans, sans-serif", a3.fillText(e4, 5, 5), a3.strokeText(e4, 5, 5), t2.debugOverlayTexture.update(i3), t2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(e3, `${f2} ${m2}kb`), n2.draw(a2, s2.TRIANGLES, l2, c2, bi.alphaBlended, Si.disabled, xe(r2, t.Color.transparent, p2), u2, e3.debugBuffer, e3.quadTriangleIndexBuffer, e3.debugSegments);
        }
        const Hi = { symbol: function(e3, i2, o2, a2, s2) {
          if ("translucent" !== e3.renderPass)
            return;
          const r2 = Ii.disabled, n2 = e3.colorModeForRenderPass();
          o2.layout.get("text-variable-anchor") && function(e4, i3, o3, a3, s3, r3, n3) {
            const l2 = i3.transform, c2 = "map" === s3, h2 = "map" === r3;
            for (const s4 of e4) {
              const e5 = a3.getTile(s4), r4 = e5.getBucket(o3);
              if (!r4 || !r4.text || !r4.text.segments.get().length)
                continue;
              const u2 = t.evaluateSizeForZoom(r4.textSizeData, l2.zoom), d2 = It(e5, 1, i3.transform.zoom), m2 = ct(s4.posMatrix, h2, c2, i3.transform, d2), _2 = "none" !== o3.layout.get("icon-text-fit") && r4.hasIconData();
              if (u2) {
                const t2 = Math.pow(2, l2.zoom - e5.tileID.overscaledZ);
                Ai(r4, c2, h2, n3, l2, m2, s4.posMatrix, t2, u2, _2);
              }
            }
          }(a2, e3, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), s2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && Li(e3, i2, o2, a2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), r2, n2), 0 !== o2.paint.get("text-opacity").constantOr(1) && Li(e3, i2, o2, a2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), r2, n2), i2.map.showCollisionBoxes && (Pi(e3, i2, o2, a2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Pi(e3, i2, o2, a2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
        }, circle: function(e3, i2, o2, a2) {
          if ("translucent" !== e3.renderPass)
            return;
          const s2 = o2.paint.get("circle-opacity"), r2 = o2.paint.get("circle-stroke-width"), n2 = o2.paint.get("circle-stroke-opacity"), l2 = !o2.layout.get("circle-sort-key").isConstant();
          if (0 === s2.constantOr(1) && (0 === r2.constantOr(1) || 0 === n2.constantOr(1)))
            return;
          const c2 = e3.context, h2 = c2.gl, u2 = e3.depthModeForSublayer(0, Ti.ReadOnly), d2 = Ii.disabled, m2 = e3.colorModeForRenderPass(), _2 = [];
          for (let s3 = 0; s3 < a2.length; s3++) {
            const r3 = a2[s3], n3 = i2.getTile(r3), c3 = n3.getBucket(o2);
            if (!c3)
              continue;
            const h3 = c3.programConfigurations.get(o2.id), u3 = { programConfiguration: h3, program: e3.useProgram("circle", h3), layoutVertexBuffer: c3.layoutVertexBuffer, indexBuffer: c3.indexBuffer, uniformValues: fe(e3, r3, n3, o2) };
            if (l2) {
              const e4 = c3.segments.get();
              for (const i3 of e4)
                _2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: u3 });
            } else
              _2.push({ segments: c3.segments, sortKey: 0, state: u3 });
          }
          l2 && _2.sort((t2, e4) => t2.sortKey - e4.sortKey);
          for (const t2 of _2) {
            const { programConfiguration: i3, program: a3, layoutVertexBuffer: s3, indexBuffer: r3, uniformValues: n3 } = t2.state;
            a3.draw(c2, h2.TRIANGLES, u2, d2, m2, Si.disabled, n3, o2.id, s3, r3, t2.segments, o2.paint, e3.transform.zoom, i3);
          }
        }, heatmap: function(e3, i2, o2, a2) {
          if (0 !== o2.paint.get("heatmap-opacity"))
            if ("offscreen" === e3.renderPass) {
              const s2 = e3.context, r2 = s2.gl, n2 = Ii.disabled, l2 = new bi([r2.ONE, r2.ONE], t.Color.transparent, [true, true, true, true]);
              !function(t2, e4, i3) {
                const o3 = t2.gl;
                t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e4.width / 4, e4.height / 4]);
                let a3 = i3.heatmapFbo;
                if (a3)
                  o3.bindTexture(o3.TEXTURE_2D, a3.colorAttachment.get()), t2.bindFramebuffer.set(a3.framebuffer);
                else {
                  const s3 = o3.createTexture();
                  o3.bindTexture(o3.TEXTURE_2D, s3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), a3 = i3.heatmapFbo = t2.createFramebuffer(e4.width / 4, e4.height / 4, false), function(t3, e5, i4, o4) {
                    const a4 = t3.gl;
                    a4.texImage2D(a4.TEXTURE_2D, 0, a4.RGBA, e5.width / 4, e5.height / 4, 0, a4.RGBA, t3.extRenderToTextureHalfFloat ? t3.extTextureHalfFloat.HALF_FLOAT_OES : a4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                  }(t2, e4, s3, a3);
                }
              }(s2, e3, o2), s2.clear({ color: t.Color.transparent });
              for (let t2 = 0; t2 < a2.length; t2++) {
                const c2 = a2[t2];
                if (i2.hasRenderableParent(c2))
                  continue;
                const h2 = i2.getTile(c2), u2 = h2.getBucket(o2);
                if (!u2)
                  continue;
                const d2 = u2.programConfigurations.get(o2.id), m2 = e3.useProgram("heatmap", d2), { zoom: _2 } = e3.transform;
                m2.draw(s2, r2.TRIANGLES, Ti.disabled, n2, l2, Si.disabled, ye(c2.posMatrix, h2, _2, o2.paint.get("heatmap-intensity")), o2.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, o2.paint, e3.transform.zoom, d2);
              }
              s2.viewport.set([0, 0, e3.width, e3.height]);
            } else
              "translucent" === e3.renderPass && (e3.context.setColorMode(e3.colorModeForRenderPass()), function(e4, i3) {
                const o3 = e4.context, a3 = o3.gl, s2 = i3.heatmapFbo;
                if (!s2)
                  return;
                o3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, s2.colorAttachment.get()), o3.activeTexture.set(a3.TEXTURE1);
                let r2 = i3.colorRampTexture;
                r2 || (r2 = i3.colorRampTexture = new d(o3, i3.colorRamp, a3.RGBA)), r2.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(o3, a3.TRIANGLES, Ti.disabled, Ii.disabled, e4.colorModeForRenderPass(), Si.disabled, ((e5, i4, o4, a4) => {
                  const s3 = t.create();
                  t.ortho(s3, 0, e5.width, e5.height, 0, 0, 1);
                  const r3 = e5.context.gl;
                  return { u_matrix: s3, u_world: [r3.drawingBufferWidth, r3.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i4.paint.get("heatmap-opacity") };
                })(e4, i3), i3.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i3.paint, e4.transform.zoom);
              }(e3, o2));
        }, line: function(e3, i2, o2, a2) {
          if ("translucent" !== e3.renderPass)
            return;
          const s2 = o2.paint.get("line-opacity"), r2 = o2.paint.get("line-width");
          if (0 === s2.constantOr(1) || 0 === r2.constantOr(1))
            return;
          const n2 = e3.depthModeForSublayer(0, Ti.ReadOnly), l2 = e3.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), h2 = o2.paint.get("line-pattern"), u2 = h2.constantOr(1), m2 = o2.paint.get("line-gradient"), _2 = o2.getCrossfadeParameters(), p2 = u2 ? "linePattern" : c2 ? "lineSDF" : m2 ? "lineGradient" : "line", f2 = e3.context, g2 = f2.gl;
          let x2 = true;
          for (const s3 of a2) {
            const a3 = i2.getTile(s3);
            if (u2 && !a3.patternsLoaded())
              continue;
            const r3 = a3.getBucket(o2);
            if (!r3)
              continue;
            const v2 = r3.programConfigurations.get(o2.id), y2 = e3.context.program.get(), b2 = e3.useProgram(p2, v2), w2 = x2 || b2.program !== y2, T2 = h2.constantOr(null);
            if (T2 && a3.imageAtlas) {
              const t2 = a3.imageAtlas, e4 = t2.patternPositions[T2.to.toString()], i3 = t2.patternPositions[T2.from.toString()];
              e4 && i3 && v2.setConstantPatternPositions(e4, i3);
            }
            const E2 = u2 ? Ee(e3, a3, o2, _2) : c2 ? Ie(e3, a3, o2, c2, _2) : m2 ? Te(e3, a3, o2, r3.lineClipsArray.length) : we(e3, a3, o2);
            if (u2)
              f2.activeTexture.set(g2.TEXTURE0), a3.imageAtlasTexture.bind(g2.LINEAR, g2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
            else if (c2 && (w2 || e3.lineAtlas.dirty))
              f2.activeTexture.set(g2.TEXTURE0), e3.lineAtlas.bind(f2);
            else if (m2) {
              const a4 = r3.gradients[o2.id];
              let n3 = a4.texture;
              if (o2.gradientVersion !== a4.version) {
                let l3 = 256;
                if (o2.stepInterpolant) {
                  const o3 = i2.getSource().maxzoom, a5 = s3.canonical.z === o3 ? Math.ceil(1 << e3.transform.maxZoom - s3.canonical.z) : 1;
                  l3 = t.clamp(t.nextPowerOfTwo(r3.maxLineLength / t.EXTENT * 1024 * a5), 256, f2.maxTextureSize);
                }
                a4.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: a4.gradient || void 0, clips: r3.lineClipsArray }), a4.texture ? a4.texture.update(a4.gradient) : a4.texture = new d(f2, a4.gradient, g2.RGBA), a4.version = o2.gradientVersion, n3 = a4.texture;
              }
              f2.activeTexture.set(g2.TEXTURE0), n3.bind(o2.stepInterpolant ? g2.NEAREST : g2.LINEAR, g2.CLAMP_TO_EDGE);
            }
            b2.draw(f2, g2.TRIANGLES, n2, e3.stencilModeForClipping(s3), l2, Si.disabled, E2, o2.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, o2.paint, e3.transform.zoom, v2, r3.layoutVertexBuffer2), x2 = false;
          }
        }, fill: function(e3, i2, o2, a2) {
          const s2 = o2.paint.get("fill-color"), r2 = o2.paint.get("fill-opacity");
          if (0 === r2.constantOr(1))
            return;
          const n2 = e3.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e3.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === s2.constantOr(t.Color.transparent).a && 1 === r2.constantOr(0) ? "opaque" : "translucent";
          if (e3.renderPass === c2) {
            const t2 = e3.depthModeForSublayer(1, "opaque" === e3.renderPass ? Ti.ReadWrite : Ti.ReadOnly);
            ki(e3, i2, o2, a2, t2, n2, false);
          }
          if ("translucent" === e3.renderPass && o2.paint.get("fill-antialias")) {
            const t2 = e3.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, Ti.ReadOnly);
            ki(e3, i2, o2, a2, t2, n2, true);
          }
        }, "fill-extrusion": function(t2, e3, i2, o2) {
          const a2 = i2.paint.get("fill-extrusion-opacity");
          if (0 !== a2 && "translucent" === t2.renderPass) {
            const s2 = new Ti(t2.context.gl.LEQUAL, Ti.ReadWrite, t2.depthRangeFor3D);
            if (1 !== a2 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
              Bi(t2, e3, i2, o2, s2, Ii.disabled, bi.disabled), Bi(t2, e3, i2, o2, s2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
            else {
              const a3 = t2.colorModeForRenderPass();
              Bi(t2, e3, i2, o2, s2, Ii.disabled, a3);
            }
          }
        }, hillshade: function(t2, e3, i2, o2) {
          if ("offscreen" !== t2.renderPass && "translucent" !== t2.renderPass)
            return;
          const a2 = t2.context, s2 = t2.depthModeForSublayer(0, Ti.ReadOnly), r2 = t2.colorModeForRenderPass(), [n2, l2] = "translucent" === t2.renderPass ? t2.stencilConfigForOverlap(o2) : [{}, o2];
          for (const o3 of l2) {
            const a3 = e3.getTile(o3);
            a3.needsHillshadePrepare && "offscreen" === t2.renderPass ? Oi(t2, a3, i2, s2, Ii.disabled, r2) : "translucent" === t2.renderPass && Fi(t2, a3, i2, s2, n2[o3.overscaledZ], r2);
          }
          a2.viewport.set([0, 0, t2.width, t2.height]);
        }, raster: function(t2, e3, i2, o2) {
          if ("translucent" !== t2.renderPass)
            return;
          if (0 === i2.paint.get("raster-opacity"))
            return;
          if (!o2.length)
            return;
          const a2 = t2.context, s2 = a2.gl, r2 = e3.getSource(), n2 = t2.useProgram("raster"), l2 = t2.colorModeForRenderPass(), [c2, h2] = r2 instanceof M ? [{}, o2] : t2.stencilConfigForOverlap(o2), u2 = h2[h2.length - 1].overscaledZ, d2 = !t2.options.moving;
          for (const o3 of h2) {
            const h3 = t2.depthModeForSublayer(o3.overscaledZ - u2, 1 === i2.paint.get("raster-opacity") ? Ti.ReadWrite : Ti.ReadOnly, s2.LESS), m2 = e3.getTile(o3), _2 = t2.transform.calculatePosMatrix(o3.toUnwrapped(), d2);
            m2.registerFadeDuration(i2.paint.get("raster-fade-duration"));
            const p2 = e3.findLoadedParent(o3, 0), f2 = Ui(m2, p2, e3, i2, t2.transform);
            let g2, x2;
            const v2 = "nearest" === i2.paint.get("raster-resampling") ? s2.NEAREST : s2.LINEAR;
            a2.activeTexture.set(s2.TEXTURE0), m2.texture.bind(v2, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), a2.activeTexture.set(s2.TEXTURE1), p2 ? (p2.texture.bind(v2, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), g2 = Math.pow(2, p2.tileID.overscaledZ - m2.tileID.overscaledZ), x2 = [m2.tileID.canonical.x * g2 % 1, m2.tileID.canonical.y * g2 % 1]) : m2.texture.bind(v2, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST);
            const y2 = Pe(_2, x2 || [0, 0], g2 || 1, f2, i2);
            r2 instanceof M ? n2.draw(a2, s2.TRIANGLES, h3, Ii.disabled, l2, Si.disabled, y2, i2.id, r2.boundsBuffer, t2.quadTriangleIndexBuffer, r2.boundsSegments) : n2.draw(a2, s2.TRIANGLES, h3, c2[o3.overscaledZ], l2, Si.disabled, y2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
          }
        }, background: function(t2, e3, i2) {
          const o2 = i2.paint.get("background-color"), a2 = i2.paint.get("background-opacity");
          if (0 === a2)
            return;
          const s2 = t2.context, r2 = s2.gl, n2 = t2.transform, l2 = n2.tileSize, c2 = i2.paint.get("background-pattern");
          if (t2.isPatternMissing(c2))
            return;
          const h2 = !c2 && 1 === o2.a && 1 === a2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (t2.renderPass !== h2)
            return;
          const u2 = Ii.disabled, d2 = t2.depthModeForSublayer(0, "opaque" === h2 ? Ti.ReadWrite : Ti.ReadOnly), m2 = t2.colorModeForRenderPass(), _2 = t2.useProgram(c2 ? "backgroundPattern" : "background"), p2 = n2.coveringTiles({ tileSize: l2 });
          c2 && (s2.activeTexture.set(r2.TEXTURE0), t2.imageManager.bind(t2.context));
          const f2 = i2.getCrossfadeParameters();
          for (const e4 of p2) {
            const n3 = t2.transform.calculatePosMatrix(e4.toUnwrapped()), h3 = c2 ? Re(n3, a2, t2, c2, { tileID: e4, tileSize: l2 }, f2) : Le(n3, a2, o2);
            _2.draw(s2, r2.TRIANGLES, d2, u2, m2, Si.disabled, h3, i2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
          }
        }, debug: function(t2, e3, i2) {
          for (let o2 = 0; o2 < i2.length; o2++)
            Xi(t2, e3, i2[o2]);
        }, custom: function(t2, e3, i2) {
          const o2 = t2.context, a2 = i2.implementation;
          if ("offscreen" === t2.renderPass) {
            const e4 = a2.prerender;
            e4 && (t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), e4.call(a2, o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState());
          } else if ("translucent" === t2.renderPass) {
            t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), o2.setStencilMode(Ii.disabled);
            const e4 = "3d" === a2.renderingMode ? new Ti(t2.context.gl.LEQUAL, Ti.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, Ti.ReadOnly);
            o2.setDepthMode(e4), a2.render(o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState(), o2.bindFramebuffer.set(null);
          }
        } };
        class Ki {
          constructor(t2, e3) {
            this.context = new wi(t2), this.transform = e3, this._tileTextures = {}, this.setup(), this.numSublayers = Z.maxUnderzooming + Z.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Yt(), this.gpuTimers = {};
          }
          resize(t2, e3, i2) {
            if (this.width = t2 * i2, this.height = e3 * i2, this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const t3 of this.style._order)
                this.style._layers[t3].resize();
          }
          setup() {
            const e3 = this.context, i2 = new t.PosArray();
            i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e3.createVertexBuffer(i2, oe.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            const o2 = new t.PosArray();
            o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e3.createVertexBuffer(o2, oe.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
            const a2 = new t.RasterBoundsArray();
            a2.emplaceBack(0, 0, 0, 0), a2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), a2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), a2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e3.createVertexBuffer(a2, A.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            const s2 = new t.PosArray();
            s2.emplaceBack(0, 0), s2.emplaceBack(1, 0), s2.emplaceBack(0, 1), s2.emplaceBack(1, 1), this.viewportBuffer = e3.createVertexBuffer(s2, oe.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            const r2 = new t.LineStripIndexArray();
            r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = e3.createIndexBuffer(r2);
            const n2 = new t.TriangleIndexArray();
            n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e3.createIndexBuffer(n2), this.emptyTexture = new d(e3, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e3.gl.RGBA);
            const l2 = this.context.gl;
            this.stencilClearMode = new Ii({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
          }
          clearStencil() {
            const e3 = this.context, i2 = e3.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const o2 = t.create();
            t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e3, i2.TRIANGLES, Ti.disabled, this.stencilClearMode, bi.disabled, Si.disabled, ve(o2), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t2, e3) {
            if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e3 || !e3.length)
              return;
            this.currentStencilSource = t2.source;
            const i2 = this.context, o2 = i2.gl;
            this.nextStencilID + e3.length > 256 && this.clearStencil(), i2.setColorMode(bi.disabled), i2.setDepthMode(Ti.disabled);
            const a2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t3 of e3) {
              const e4 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++;
              a2.draw(i2, o2.TRIANGLES, Ti.disabled, new Ii({ func: o2.ALWAYS, mask: 0 }, e4, 255, o2.KEEP, o2.KEEP, o2.REPLACE), bi.disabled, Si.disabled, ve(t3.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t2 = this.nextStencilID++, e3 = this.context.gl;
            return new Ii({ func: e3.NOTEQUAL, mask: 255 }, t2, 255, e3.KEEP, e3.KEEP, e3.REPLACE);
          }
          stencilModeForClipping(t2) {
            const e3 = this.context.gl;
            return new Ii({ func: e3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e3.KEEP, e3.KEEP, e3.REPLACE);
          }
          stencilConfigForOverlap(t2) {
            const e3 = this.context.gl, i2 = t2.sort((t3, e4) => e4.overscaledZ - t3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, a2 = i2[0].overscaledZ - o2 + 1;
            if (a2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
              const t3 = {};
              for (let i3 = 0; i3 < a2; i3++)
                t3[i3 + o2] = new Ii({ func: e3.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e3.KEEP, e3.KEEP, e3.REPLACE);
              return this.nextStencilID += a2, [t3, i2];
            }
            return [{ [o2]: Ii.disabled }, i2];
          }
          colorModeForRenderPass() {
            const e3 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i2 = 1 / 8;
              return new bi([e3.CONSTANT_COLOR, e3.ONE], new t.Color(i2, i2, i2, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? bi.unblended : bi.alphaBlended;
          }
          depthModeForSublayer(t2, e3, i2) {
            if (!this.opaquePassEnabledForLayer())
              return Ti.disabled;
            const o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
            return new Ti(i2 || this.context.gl.LEQUAL, e3, [o2, o2]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e3, i2) {
            this.style = e3, this.options = i2, this.lineAtlas = e3.lineAtlas, this.imageManager = e3.imageManager, this.glyphManager = e3.glyphManager, this.symbolFadeChange = e3.placement.symbolFadeChange(t.exported.now()), this.imageManager.beginFrame();
            const o2 = this.style._order, a2 = this.style.sourceCaches;
            for (const t2 in a2) {
              const e4 = a2[t2];
              e4.used && e4.prepare(this.context);
            }
            const s2 = {}, r2 = {}, n2 = {};
            for (const t2 in a2) {
              const e4 = a2[t2];
              s2[t2] = e4.getVisibleCoordinates(), r2[t2] = s2[t2].slice().reverse(), n2[t2] = e4.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let t2 = 0; t2 < o2.length; t2++)
              if (this.style._layers[o2[t2]].is3D()) {
                this.opaquePassCutoff = t2;
                break;
              }
            this.renderPass = "offscreen";
            for (const t2 of o2) {
              const e4 = this.style._layers[t2];
              if (!e4.hasOffscreenPass() || e4.isHidden(this.transform.zoom))
                continue;
              const i3 = r2[e4.source];
              ("custom" === e4.type || i3.length) && this.renderLayer(this, a2[e4.source], e4, i3);
            }
            for (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e3._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const t2 = this.style._layers[o2[this.currentLayer]], e4 = a2[t2.source], i3 = s2[t2.source];
              this._renderTileClippingMasks(t2, i3), this.renderLayer(this, e4, t2, i3);
            }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
              const t2 = this.style._layers[o2[this.currentLayer]], e4 = a2[t2.source], i3 = ("symbol" === t2.type ? n2 : r2)[t2.source];
              this._renderTileClippingMasks(t2, s2[t2.source]), this.renderLayer(this, e4, t2, i3);
            }
            if (this.options.showTileBoundaries) {
              let t2, e4;
              Object.values(this.style._layers).forEach((i3) => {
                i3.source && !i3.isHidden(this.transform.zoom) && (i3.source !== (e4 && e4.id) && (e4 = this.style.sourceCaches[i3.source]), (!t2 || t2.getSource().maxzoom < e4.getSource().maxzoom) && (t2 = e4));
              }), t2 && Hi.debug(this, t2, t2.getVisibleCoordinates());
            }
            this.options.showPadding && function(t2) {
              const e4 = t2.transform.padding;
              ji(t2, t2.transform.height - (e4.top || 0), 3, Ni), ji(t2, e4.bottom || 0, 3, Gi), $i(t2, e4.left || 0, 3, Zi), $i(t2, t2.transform.width - (e4.right || 0), 3, qi);
              const i3 = t2.transform.centerPoint;
              !function(t3, e5, i4, o3) {
                Wi(t3, e5 - 1, i4 - 10, 2, 20, o3), Wi(t3, e5 - 10, i4 - 1, 20, 2, o3);
              }(t2, i3.x, t2.transform.height - i3.y, Vi);
            }(this), this.context.setDefault();
          }
          renderLayer(t2, e3, i2, o2) {
            i2.isHidden(this.transform.zoom) || ("background" === i2.type || "custom" === i2.type || o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), Hi[i2.type](t2, e3, i2, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
          }
          gpuTimingStart(t2) {
            if (!this.options.gpuTiming)
              return;
            const e3 = this.context.extTimerQuery;
            let i2 = this.gpuTimers[t2.id];
            i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e3.createQueryEXT() }), i2.calls++, e3.beginQueryEXT(e3.TIME_ELAPSED_EXT, i2.query);
          }
          gpuTimingEnd() {
            if (!this.options.gpuTiming)
              return;
            const t2 = this.context.extTimerQuery;
            t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const t2 = this.gpuTimers;
            return this.gpuTimers = {}, t2;
          }
          queryGpuTimers(t2) {
            const e3 = {};
            for (const i2 in t2) {
              const o2 = t2[i2], a2 = this.context.extTimerQuery, s2 = a2.getQueryObjectEXT(o2.query, a2.QUERY_RESULT_EXT) / 1e6;
              a2.deleteQueryEXT(o2.query), e3[i2] = s2;
            }
            return e3;
          }
          translatePosMatrix(e3, i2, o2, a2, s2) {
            if (!o2[0] && !o2[1])
              return e3;
            const r2 = s2 ? "map" === a2 ? this.transform.angle : 0 : "viewport" === a2 ? -this.transform.angle : 0;
            if (r2) {
              const t2 = Math.sin(r2), e4 = Math.cos(r2);
              o2 = [o2[0] * e4 - o2[1] * t2, o2[0] * t2 + o2[1] * e4];
            }
            const n2 = [s2 ? o2[0] : It(i2, o2[0], this.transform.zoom), s2 ? o2[1] : It(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return t.translate(l2, e3, n2), l2;
          }
          saveTileTexture(t2) {
            const e3 = this._tileTextures[t2.size[0]];
            e3 ? e3.push(t2) : this._tileTextures[t2.size[0]] = [t2];
          }
          getTileTexture(t2) {
            const e3 = this._tileTextures[t2];
            return e3 && e3.length > 0 ? e3.pop() : null;
          }
          isPatternMissing(t2) {
            if (!t2)
              return false;
            if (!t2.from || !t2.to)
              return true;
            const e3 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
            return !e3 || !i2;
          }
          useProgram(t2, e3) {
            this.cache = this.cache || {};
            const i2 = `${t2}${e3 ? e3.cacheKey : ""}${this._showOverdrawInspector ? "/overdraw" : ""}`;
            return this.cache[i2] || (this.cache[i2] = new le(this.context, t2, ae[t2], e3, ke[t2], this._showOverdrawInspector)), this.cache[i2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new d(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
        }
        class Yi {
          constructor(t2, e3) {
            this.points = t2, this.planes = e3;
          }
          static fromInvProjectionMatrix(e3, i2, o2) {
            const a2 = Math.pow(2, o2), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((i3) => t.transformMat4([], i3, e3)).map((e4) => t.scale$1([], e4, 1 / e4[3] / i2 * a2)), r2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t2) => {
              const e4 = function(t3, e5) {
                var i4 = e5[0], o4 = e5[1], a4 = e5[2], s3 = i4 * i4 + o4 * o4 + a4 * a4;
                return s3 > 0 && (s3 = 1 / Math.sqrt(s3)), t3[0] = e5[0] * s3, t3[1] = e5[1] * s3, t3[2] = e5[2] * s3, t3;
              }([], function(t3, e5, i4) {
                var o4 = e5[0], a4 = e5[1], s3 = e5[2], r3 = i4[0], n2 = i4[1], l2 = i4[2];
                return t3[0] = a4 * l2 - s3 * n2, t3[1] = s3 * r3 - o4 * l2, t3[2] = o4 * n2 - a4 * r3, t3;
              }([], h([], s2[t2[0]], s2[t2[1]]), h([], s2[t2[2]], s2[t2[1]]))), i3 = -((o3 = e4)[0] * (a3 = s2[t2[1]])[0] + o3[1] * a3[1] + o3[2] * a3[2]);
              var o3, a3;
              return e4.concat(i3);
            });
            return new Yi(s2, r2);
          }
        }
        class Ji {
          constructor(t2, e3) {
            this.min = t2, this.max = e3, this.center = function(t3, e4, i2) {
              return t3[0] = 0.5 * e4[0], t3[1] = 0.5 * e4[1], t3[2] = 0.5 * e4[2], t3;
            }([], function(t3, e4, i2) {
              return t3[0] = e4[0] + i2[0], t3[1] = e4[1] + i2[1], t3[2] = e4[2] + i2[2], t3;
            }([], this.min, this.max));
          }
          quadrant(t2) {
            const e3 = [t2 % 2 == 0, t2 < 2], i2 = l(this.min), o2 = l(this.max);
            for (let t3 = 0; t3 < e3.length; t3++)
              i2[t3] = e3[t3] ? this.min[t3] : this.center[t3], o2[t3] = e3[t3] ? this.center[t3] : this.max[t3];
            return o2[2] = this.max[2], new Ji(i2, o2);
          }
          distanceX(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }
          distanceY(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }
          intersects(e3) {
            const i2 = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]];
            let o2 = true;
            for (let a2 = 0; a2 < e3.planes.length; a2++) {
              const s2 = e3.planes[a2];
              let r2 = 0;
              for (let e4 = 0; e4 < i2.length; e4++)
                t.dot(s2, i2[e4]) >= 0 && r2++;
              if (0 === r2)
                return 0;
              r2 !== i2.length && (o2 = false);
            }
            if (o2)
              return 2;
            for (let t2 = 0; t2 < 3; t2++) {
              let i3 = Number.MAX_VALUE, o3 = -Number.MAX_VALUE;
              for (let a2 = 0; a2 < e3.points.length; a2++) {
                const s2 = e3.points[a2][t2] - this.min[t2];
                i3 = Math.min(i3, s2), o3 = Math.max(o3, s2);
              }
              if (o3 < 0 || i3 > this.max[t2] - this.min[t2])
                return 0;
            }
            return 1;
          }
        }
        class Qi {
          constructor(t2 = 0, e3 = 0, i2 = 0, o2 = 0) {
            if (isNaN(t2) || t2 < 0 || isNaN(e3) || e3 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t2, this.bottom = e3, this.left = i2, this.right = o2;
          }
          interpolate(e3, i2, o2) {
            return null != i2.top && null != e3.top && (this.top = t.number(e3.top, i2.top, o2)), null != i2.bottom && null != e3.bottom && (this.bottom = t.number(e3.bottom, i2.bottom, o2)), null != i2.left && null != e3.left && (this.left = t.number(e3.left, i2.left, o2)), null != i2.right && null != e3.right && (this.right = t.number(e3.right, i2.right, o2)), this;
          }
          getCenter(e3, i2) {
            const o2 = t.clamp((this.left + e3 - this.right) / 2, 0, e3), a2 = t.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
            return new t.pointGeometry(o2, a2);
          }
          equals(t2) {
            return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
          }
          clone() {
            return new Qi(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        class to {
          constructor(e3, i2, o2, a2, s2) {
            this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === s2 || !!s2, this._minZoom = e3 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == a2 ? 60 : a2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new Qi(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          clone() {
            const t2 = new to(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2._center = this._center, t2.zoom = this.zoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._unmodified = this._unmodified, t2._edgeInsets = this._edgeInsets.clone(), t2._calcMatrices(), t2;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t2) {
            this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t2) {
            this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t2) {
            this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t2) {
            this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(t2) {
            void 0 === t2 ? t2 = true : null === t2 && (t2 = false), this._renderWorldCopies = t2;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new t.pointGeometry(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(e3) {
            const i2 = -t.wrap(e3, -180, 180) * Math.PI / 180;
            this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = function() {
              var e4 = new t.ARRAY_TYPE(4);
              return t.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0), e4[0] = 1, e4[3] = 1, e4;
            }(), function(t2, e4, i3) {
              var o2 = e4[0], a2 = e4[1], s2 = e4[2], r2 = e4[3], n2 = Math.sin(i3), l2 = Math.cos(i3);
              t2[0] = o2 * l2 + s2 * n2, t2[1] = a2 * l2 + r2 * n2, t2[2] = o2 * -n2 + s2 * l2, t2[3] = a2 * -n2 + r2 * l2;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(e3) {
            const i2 = t.clamp(e3, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t2) {
            const e3 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
            this._zoom !== e3 && (this._unmodified = false, this._zoom = e3, this.scale = this.zoomScale(e3), this.tileZoom = Math.floor(e3), this.zoomFraction = e3 - this.tileZoom, this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(t2) {
            t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t2) {
            this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(t2) {
            return this._edgeInsets.equals(t2);
          }
          interpolatePadding(t2, e3, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(t2, e3, i2), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t2) {
            const e3 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
            return Math.max(0, e3);
          }
          getVisibleUnwrappedCoordinates(e3) {
            const i2 = [new t.UnwrappedTileID(0, e3)];
            if (this._renderWorldCopies) {
              const o2 = this.pointCoordinate(new t.pointGeometry(0, 0)), a2 = this.pointCoordinate(new t.pointGeometry(this.width, 0)), s2 = this.pointCoordinate(new t.pointGeometry(this.width, this.height)), r2 = this.pointCoordinate(new t.pointGeometry(0, this.height)), n2 = Math.floor(Math.min(o2.x, a2.x, s2.x, r2.x)), l2 = Math.floor(Math.max(o2.x, a2.x, s2.x, r2.x)), c2 = 1;
              for (let o3 = n2 - c2; o3 <= l2 + c2; o3++)
                0 !== o3 && i2.push(new t.UnwrappedTileID(o3, e3));
            }
            return i2;
          }
          coveringTiles(e3) {
            let i2 = this.coveringZoomLevel(e3);
            const o2 = i2;
            if (void 0 !== e3.minzoom && i2 < e3.minzoom)
              return [];
            void 0 !== e3.maxzoom && i2 > e3.maxzoom && (i2 = e3.maxzoom);
            const a2 = t.MercatorCoordinate.fromLngLat(this.center), s2 = Math.pow(2, i2), r2 = [s2 * a2.x, s2 * a2.y, 0], n2 = Yi.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2);
            let l2 = e3.minzoom || 0;
            this.pitch <= 60 && this._edgeInsets.top < 0.1 && (l2 = i2);
            const c2 = (t2) => ({ aabb: new Ji([t2 * s2, 0, 0], [(t2 + 1) * s2, s2, 0]), zoom: 0, x: 0, y: 0, wrap: t2, fullyVisible: false }), h2 = [], d2 = [], m2 = i2, _2 = e3.reparseOverscaled ? o2 : i2;
            if (this._renderWorldCopies)
              for (let t2 = 1; t2 <= 3; t2++)
                h2.push(c2(-t2)), h2.push(c2(t2));
            for (h2.push(c2(0)); h2.length > 0; ) {
              const e4 = h2.pop(), i3 = e4.x, o3 = e4.y;
              let a3 = e4.fullyVisible;
              if (!a3) {
                const t2 = e4.aabb.intersects(n2);
                if (0 === t2)
                  continue;
                a3 = 2 === t2;
              }
              const s3 = e4.aabb.distanceX(r2), c3 = e4.aabb.distanceY(r2), p2 = Math.max(Math.abs(s3), Math.abs(c3)), f2 = 3 + (1 << m2 - e4.zoom) - 2;
              if (e4.zoom === m2 || p2 > f2 && e4.zoom >= l2)
                d2.push({ tileID: new t.OverscaledTileID(e4.zoom === m2 ? _2 : e4.zoom, e4.wrap, e4.zoom, i3, o3), distanceSq: u([r2[0] - 0.5 - i3, r2[1] - 0.5 - o3]) });
              else
                for (let t2 = 0; t2 < 4; t2++) {
                  const s4 = (i3 << 1) + t2 % 2, r3 = (o3 << 1) + (t2 >> 1);
                  h2.push({ aabb: e4.aabb.quadrant(t2), zoom: e4.zoom + 1, x: s4, y: r3, wrap: e4.wrap, fullyVisible: a3 });
                }
            }
            return d2.sort((t2, e4) => t2.distanceSq - e4.distanceSq).map((t2) => t2.tileID);
          }
          resize(t2, e3) {
            this.width = t2, this.height = e3, this.pixelsToGLUnits = [2 / t2, -2 / e3], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t2) {
            return Math.pow(2, t2);
          }
          scaleZoom(t2) {
            return Math.log(t2) / Math.LN2;
          }
          project(e3) {
            const i2 = t.clamp(e3.lat, -this.maxValidLatitude, this.maxValidLatitude);
            return new t.pointGeometry(t.mercatorXfromLng(e3.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
          }
          unproject(e3) {
            return new t.MercatorCoordinate(e3.x / this.worldSize, e3.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          setLocationAtPoint(e3, i2) {
            const o2 = this.pointCoordinate(i2), a2 = this.pointCoordinate(this.centerPoint), s2 = this.locationCoordinate(e3), r2 = new t.MercatorCoordinate(s2.x - (o2.x - a2.x), s2.y - (o2.y - a2.y));
            this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(t2) {
            return this.coordinatePoint(this.locationCoordinate(t2));
          }
          pointLocation(t2) {
            return this.coordinateLocation(this.pointCoordinate(t2));
          }
          locationCoordinate(e3) {
            return t.MercatorCoordinate.fromLngLat(e3);
          }
          coordinateLocation(t2) {
            return t2.toLngLat();
          }
          pointCoordinate(e3) {
            const i2 = [e3.x, e3.y, 0, 1], o2 = [e3.x, e3.y, 1, 1];
            t.transformMat4(i2, i2, this.pixelMatrixInverse), t.transformMat4(o2, o2, this.pixelMatrixInverse);
            const a2 = i2[3], s2 = o2[3], r2 = i2[1] / a2, n2 = o2[1] / s2, l2 = i2[2] / a2, c2 = o2[2] / s2, h2 = l2 === c2 ? 0 : (0 - l2) / (c2 - l2);
            return new t.MercatorCoordinate(t.number(i2[0] / a2, o2[0] / s2, h2) / this.worldSize, t.number(r2, n2, h2) / this.worldSize);
          }
          coordinatePoint(e3) {
            const i2 = [e3.x * this.worldSize, e3.y * this.worldSize, 0, 1];
            return t.transformMat4(i2, i2, this.pixelMatrix), new t.pointGeometry(i2[0] / i2[3], i2[1] / i2[3]);
          }
          getBounds() {
            return new t.LngLatBounds().extend(this.pointLocation(new t.pointGeometry(0, 0))).extend(this.pointLocation(new t.pointGeometry(this.width, 0))).extend(this.pointLocation(new t.pointGeometry(this.width, this.height))).extend(this.pointLocation(new t.pointGeometry(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          setMaxBounds(t2) {
            t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
          }
          calculatePosMatrix(e3, i2 = false) {
            const o2 = e3.key, a2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (a2[o2])
              return a2[o2];
            const s2 = e3.canonical, r2 = this.worldSize / this.zoomScale(s2.z), n2 = s2.x + Math.pow(2, s2.z) * e3.wrap, l2 = t.identity(new Float64Array(16));
            return t.translate(l2, l2, [n2 * r2, s2.y * r2, 0]), t.scale(l2, l2, [r2 / t.EXTENT, r2 / t.EXTENT, 1]), t.multiply(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), a2[o2] = new Float32Array(l2), a2[o2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            this._constraining = true;
            let e3, i2, o2, a2, s2 = -90, r2 = 90, n2 = -180, l2 = 180;
            const c2 = this.size, h2 = this._unmodified;
            if (this.latRange) {
              const i3 = this.latRange;
              s2 = t.mercatorYfromLat(i3[1]) * this.worldSize, r2 = t.mercatorYfromLat(i3[0]) * this.worldSize, e3 = r2 - s2 < c2.y ? c2.y / (r2 - s2) : 0;
            }
            if (this.lngRange) {
              const e4 = this.lngRange;
              n2 = t.mercatorXfromLng(e4[0]) * this.worldSize, l2 = t.mercatorXfromLng(e4[1]) * this.worldSize, i2 = l2 - n2 < c2.x ? c2.x / (l2 - n2) : 0;
            }
            const u2 = this.point, d2 = Math.max(i2 || 0, e3 || 0);
            if (d2)
              return this.center = this.unproject(new t.pointGeometry(i2 ? (l2 + n2) / 2 : u2.x, e3 ? (r2 + s2) / 2 : u2.y)), this.zoom += this.scaleZoom(d2), this._unmodified = h2, void (this._constraining = false);
            if (this.latRange) {
              const t2 = u2.y, e4 = c2.y / 2;
              t2 - e4 < s2 && (a2 = s2 + e4), t2 + e4 > r2 && (a2 = r2 - e4);
            }
            if (this.lngRange) {
              const t2 = u2.x, e4 = c2.x / 2;
              t2 - e4 < n2 && (o2 = n2 + e4), t2 + e4 > l2 && (o2 = l2 - e4);
            }
            void 0 === o2 && void 0 === a2 || (this.center = this.unproject(new t.pointGeometry(void 0 !== o2 ? o2 : u2.x, void 0 !== a2 ? a2 : u2.y))), this._unmodified = h2, this._constraining = false;
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const e3 = this.centerOffset;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
            const i2 = Math.PI / 2 + this._pitch, o2 = this._fov * (0.5 + e3.y / this.height), a2 = Math.sin(o2) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i2 - o2, 0.01, Math.PI - 0.01)), s2 = this.point, r2 = s2.x, n2 = s2.y, l2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * a2 + this.cameraToCenterDistance), c2 = this.height / 50;
            let h2 = new Float64Array(16);
            t.perspective(h2, this._fov, this.width / this.height, c2, l2), h2[8] = 2 * -e3.x / this.width, h2[9] = 2 * e3.y / this.height, t.scale(h2, h2, [1, -1, 1]), t.translate(h2, h2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(h2, h2, this._pitch), t.rotateZ(h2, h2, this.angle), t.translate(h2, h2, [-r2, -n2, 0]), this.mercatorMatrix = t.scale([], h2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(h2, h2, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize]), this.projMatrix = h2, this.invProjMatrix = t.invert([], this.projMatrix);
            const u2 = this.width % 2 / 2, d2 = this.height % 2 / 2, m2 = Math.cos(this.angle), _2 = Math.sin(this.angle), p2 = r2 - Math.round(r2) + m2 * u2 + _2 * d2, f2 = n2 - Math.round(n2) + m2 * d2 + _2 * u2, g2 = new Float64Array(h2);
            if (t.translate(g2, g2, [p2 > 0.5 ? p2 - 1 : p2, f2 > 0.5 ? f2 - 1 : f2, 0]), this.alignedProjMatrix = g2, h2 = t.create(), t.scale(h2, h2, [this.width / 2, -this.height / 2, 1]), t.translate(h2, h2, [1, -1, 0]), this.labelPlaneMatrix = h2, h2 = t.create(), t.scale(h2, h2, [1, -1, 1]), t.translate(h2, h2, [-1, -1, 0]), t.scale(h2, h2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h2, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), h2 = t.invert(new Float64Array(16), this.pixelMatrix), !h2)
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = h2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          maxPitchScaleFactor() {
            if (!this.pixelMatrixInverse)
              return 1;
            const e3 = this.pointCoordinate(new t.pointGeometry(0, 0)), i2 = [e3.x * this.worldSize, e3.y * this.worldSize, 0, 1];
            return t.transformMat4(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }
          getCameraPoint() {
            const e3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new t.pointGeometry(0, e3));
          }
          getCameraQueryGeometry(e3) {
            const i2 = this.getCameraPoint();
            if (1 === e3.length)
              return [e3[0], i2];
            {
              let o2 = i2.x, a2 = i2.y, s2 = i2.x, r2 = i2.y;
              for (const t2 of e3)
                o2 = Math.min(o2, t2.x), a2 = Math.min(a2, t2.y), s2 = Math.max(s2, t2.x), r2 = Math.max(r2, t2.y);
              return [new t.pointGeometry(o2, a2), new t.pointGeometry(s2, a2), new t.pointGeometry(s2, r2), new t.pointGeometry(o2, r2), new t.pointGeometry(o2, a2)];
            }
          }
        }
        class eo {
          constructor(e3) {
            this._hashName = e3 && encodeURIComponent(e3), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = function(t2, e4) {
              let i2 = false, o2 = null;
              const a2 = () => {
                o2 = null, i2 && (t2(), o2 = setTimeout(a2, 300), i2 = false);
              };
              return () => (i2 = true, o2 || a2(), o2);
            }(this._updateHashUnthrottled.bind(this));
          }
          addTo(t2) {
            return this._map = t2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(t2) {
            const e3 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, o2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, o2), s2 = Math.round(e3.lng * a2) / a2, r2 = Math.round(e3.lat * a2) / a2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
            let c2 = "";
            if (c2 += t2 ? `/${s2}/${r2}/${i2}` : `${i2}/${r2}/${s2}`, (n2 || l2) && (c2 += "/" + Math.round(10 * n2) / 10), l2 && (c2 += `/${Math.round(l2)}`), this._hashName) {
              const t3 = this._hashName;
              let e4 = false;
              const i3 = window.location.hash.slice(1).split("&").map((i4) => {
                const o3 = i4.split("=")[0];
                return o3 === t3 ? (e4 = true, `${o3}=${c2}`) : i4;
              }).filter((t4) => t4);
              return e4 || i3.push(`${t3}=${c2}`), `#${i3.join("&")}`;
            }
            return `#${c2}`;
          }
          _getCurrentHash() {
            const t2 = window.location.hash.replace("#", "");
            if (this._hashName) {
              let e3;
              return t2.split("&").map((t3) => t3.split("=")).forEach((t3) => {
                t3[0] === this._hashName && (e3 = t3);
              }), (e3 && e3[1] || "").split("/");
            }
            return t2.split("/");
          }
          _onHashChange() {
            const t2 = this._getCurrentHash();
            if (t2.length >= 3 && !t2.some((t3) => isNaN(t3))) {
              const e3 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: e3, pitch: +(t2[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            const t2 = window.location.href.replace(/(#.+)?$/, this.getHashString());
            try {
              window.history.replaceState(window.history.state, null, t2);
            } catch (t3) {
            }
          }
        }
        const io = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, oo = t.extend({ deceleration: 2500, maxSpeed: 1400 }, io), ao = t.extend({ deceleration: 20, maxSpeed: 1400 }, io), so = t.extend({ deceleration: 1e3, maxSpeed: 360 }, io), ro = t.extend({ deceleration: 1e3, maxSpeed: 90 }, io);
        class no {
          constructor(t2) {
            this._map = t2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e3) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.exported.now(), settings: e3 });
          }
          _drainInertiaBuffer() {
            const e3 = this._inertiaBuffer, i2 = t.exported.now();
            for (; e3.length > 0 && i2 - e3[0].time > 160; )
              e3.shift();
          }
          _onMoveEnd(e3) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: t2 } of this._inertiaBuffer)
              i2.zoom += t2.zoomDelta || 0, i2.bearing += t2.bearingDelta || 0, i2.pitch += t2.pitchDelta || 0, t2.panDelta && i2.pan._add(t2.panDelta), t2.around && (i2.around = t2.around), t2.pinchAround && (i2.pinchAround = t2.pinchAround);
            const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a2 = {};
            if (i2.pan.mag()) {
              const s2 = co(i2.pan.mag(), o2, t.extend({}, oo, e3 || {}));
              a2.offset = i2.pan.mult(s2.amount / i2.pan.mag()), a2.center = this._map.transform.center, lo(a2, s2);
            }
            if (i2.zoom) {
              const t2 = co(i2.zoom, o2, ao);
              a2.zoom = this._map.transform.zoom + t2.amount, lo(a2, t2);
            }
            if (i2.bearing) {
              const e4 = co(i2.bearing, o2, so);
              a2.bearing = this._map.transform.bearing + t.clamp(e4.amount, -179, 179), lo(a2, e4);
            }
            if (i2.pitch) {
              const t2 = co(i2.pitch, o2, ro);
              a2.pitch = this._map.transform.pitch + t2.amount, lo(a2, t2);
            }
            if (a2.zoom || a2.bearing) {
              const t2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
              a2.around = t2 ? this._map.unproject(t2) : this._map.getCenter();
            }
            return this.clear(), t.extend(a2, { noMoveStart: true });
          }
        }
        function lo(t2, e3) {
          (!t2.duration || t2.duration < e3.duration) && (t2.duration = e3.duration, t2.easing = e3.easing);
        }
        function co(e3, i2, o2) {
          const { maxSpeed: a2, linearity: s2, deceleration: r2 } = o2, n2 = t.clamp(e3 * s2 / (i2 / 1e3), -a2, a2), l2 = Math.abs(n2) / (r2 * s2);
          return { easing: o2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
        }
        class ho extends t.Event {
          constructor(e3, i2, o2, a2 = {}) {
            const r2 = s.mousePos(i2.getCanvasContainer(), o2), n2 = i2.unproject(r2);
            super(e3, t.extend({ point: r2, lngLat: n2, originalEvent: o2 }, a2)), this._defaultPrevented = false, this.target = i2;
          }
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
        }
        class uo extends t.Event {
          constructor(e3, i2, o2) {
            const a2 = "touchend" === e3 ? o2.changedTouches : o2.touches, r2 = s.touchPos(i2.getCanvasContainer(), a2), n2 = r2.map((t2) => i2.unproject(t2)), l2 = r2.reduce((t2, e4, i3, o3) => t2.add(e4.div(o3.length)), new t.pointGeometry(0, 0));
            super(e3, { points: r2, point: l2, lngLats: n2, lngLat: i2.unproject(l2), originalEvent: o2 }), this._defaultPrevented = false;
          }
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
        }
        class mo extends t.Event {
          constructor(t2, e3, i2) {
            super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
          }
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
        }
        class _o {
          constructor(t2, e3) {
            this._map = t2, this._clickTolerance = e3.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t2) {
            return this._firePreventable(new mo(t2.type, this._map, t2));
          }
          mousedown(t2, e3) {
            return this._mousedownPos = e3, this._firePreventable(new ho(t2.type, this._map, t2));
          }
          mouseup(t2) {
            this._map.fire(new ho(t2.type, this._map, t2));
          }
          click(t2, e3) {
            this._mousedownPos && this._mousedownPos.dist(e3) >= this._clickTolerance || this._map.fire(new ho(t2.type, this._map, t2));
          }
          dblclick(t2) {
            return this._firePreventable(new ho(t2.type, this._map, t2));
          }
          mouseover(t2) {
            this._map.fire(new ho(t2.type, this._map, t2));
          }
          mouseout(t2) {
            this._map.fire(new ho(t2.type, this._map, t2));
          }
          touchstart(t2) {
            return this._firePreventable(new uo(t2.type, this._map, t2));
          }
          touchmove(t2) {
            this._map.fire(new uo(t2.type, this._map, t2));
          }
          touchend(t2) {
            this._map.fire(new uo(t2.type, this._map, t2));
          }
          touchcancel(t2) {
            this._map.fire(new uo(t2.type, this._map, t2));
          }
          _firePreventable(t2) {
            if (this._map.fire(t2), t2.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class po {
          constructor(t2) {
            this._map = t2;
          }
          reset() {
            this._delayContextMenu = false, delete this._contextMenuEvent;
          }
          mousemove(t2) {
            this._map.fire(new ho(t2.type, this._map, t2));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ho("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t2) {
            this._delayContextMenu ? this._contextMenuEvent = t2 : this._map.fire(new ho(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class fo {
          constructor(t2, e3) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e3.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(t2, e3) {
            this.isEnabled() && t2.shiftKey && 0 === t2.button && (s.disableDrag(), this._startPos = this._lastPos = e3, this._active = true);
          }
          mousemoveWindow(t2, e3) {
            if (!this._active)
              return;
            const i2 = e3;
            if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
              return;
            const o2 = this._startPos;
            this._lastPos = i2, this._box || (this._box = s.create("div", "maplibregl-boxzoom mapboxgl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair", "mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
            const a2 = Math.min(o2.x, i2.x), r2 = Math.max(o2.x, i2.x), n2 = Math.min(o2.y, i2.y), l2 = Math.max(o2.y, i2.y);
            s.setTransform(this._box, `translate(${a2}px,${n2}px)`), this._box.style.width = r2 - a2 + "px", this._box.style.height = l2 - n2 + "px";
          }
          mouseupWindow(e3, i2) {
            if (!this._active)
              return;
            if (0 !== e3.button)
              return;
            const o2 = this._startPos, a2 = i2;
            if (this.reset(), s.suppressClick(), o2.x !== a2.x || o2.y !== a2.y)
              return this._map.fire(new t.Event("boxzoomend", { originalEvent: e3 })), { cameraAnimation: (t2) => t2.fitScreenCoordinates(o2, a2, this._map.getBearing(), { linear: true }) };
            this._fireEvent("boxzoomcancel", e3);
          }
          keydown(t2) {
            this._active && 27 === t2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t2));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair", "mapboxgl-crosshair"), this._box && (s.remove(this._box), this._box = null), s.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e3, i2) {
            return this._map.fire(new t.Event(e3, { originalEvent: i2 }));
          }
        }
        function go(t2, e3) {
          const i2 = {};
          for (let o2 = 0; o2 < t2.length; o2++)
            i2[t2[o2].identifier] = e3[o2];
          return i2;
        }
        class xo {
          constructor(t2) {
            this.reset(), this.numTouches = t2.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e3, i2, o2) {
            (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e3.timeStamp), o2.length === this.numTouches && (this.centroid = function(e4) {
              const i3 = new t.pointGeometry(0, 0);
              for (const t2 of e4)
                i3._add(t2);
              return i3.div(e4.length);
            }(i2), this.touches = go(o2, i2)));
          }
          touchmove(t2, e3, i2) {
            if (this.aborted || !this.centroid)
              return;
            const o2 = go(i2, e3);
            for (const t3 in this.touches) {
              const e4 = this.touches[t3], i3 = o2[t3];
              (!i3 || i3.dist(e4) > 30) && (this.aborted = true);
            }
          }
          touchend(t2, e3, i2) {
            if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              const t3 = !this.aborted && this.centroid;
              if (this.reset(), t3)
                return t3;
            }
          }
        }
        class vo {
          constructor(t2) {
            this.singleTap = new xo(t2), this.numTaps = t2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t2, e3, i2) {
            this.singleTap.touchstart(t2, e3, i2);
          }
          touchmove(t2, e3, i2) {
            this.singleTap.touchmove(t2, e3, i2);
          }
          touchend(t2, e3, i2) {
            const o2 = this.singleTap.touchend(t2, e3, i2);
            if (o2) {
              const e4 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
              if (e4 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                return this.reset(), o2;
            }
          }
        }
        class yo {
          constructor() {
            this._zoomIn = new vo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new vo({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t2, e3, i2) {
            this._zoomIn.touchstart(t2, e3, i2), this._zoomOut.touchstart(t2, e3, i2);
          }
          touchmove(t2, e3, i2) {
            this._zoomIn.touchmove(t2, e3, i2), this._zoomOut.touchmove(t2, e3, i2);
          }
          touchend(t2, e3, i2) {
            const o2 = this._zoomIn.touchend(t2, e3, i2), a2 = this._zoomOut.touchend(t2, e3, i2);
            return o2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e4) => e4.easeTo({ duration: 300, zoom: e4.getZoom() + 1, around: e4.unproject(o2) }, { originalEvent: t2 }) }) : a2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e4) => e4.easeTo({ duration: 300, zoom: e4.getZoom() - 1, around: e4.unproject(a2) }, { originalEvent: t2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const bo = { 0: 1, 2: 2 };
        class wo {
          constructor(t2) {
            this.reset(), this._clickTolerance = t2.clickTolerance || 1;
          }
          reset() {
            this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
          }
          _correctButton(t2, e3) {
            return false;
          }
          _move(t2, e3) {
            return {};
          }
          mousedown(t2, e3) {
            if (this._lastPoint)
              return;
            const i2 = s.mouseButton(t2);
            this._correctButton(t2, i2) && (this._lastPoint = e3, this._eventButton = i2);
          }
          mousemoveWindow(t2, e3) {
            const i2 = this._lastPoint;
            if (i2) {
              if (t2.preventDefault(), function(t3, e4) {
                const i3 = bo[e4];
                return void 0 === t3.buttons || (t3.buttons & i3) !== i3;
              }(t2, this._eventButton))
                this.reset();
              else if (this._moved || !(e3.dist(i2) < this._clickTolerance))
                return this._moved = true, this._lastPoint = e3, this._move(i2, e3);
            }
          }
          mouseupWindow(t2) {
            this._lastPoint && s.mouseButton(t2) === this._eventButton && (this._moved && s.suppressClick(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class To extends wo {
          mousedown(t2, e3) {
            super.mousedown(t2, e3), this._lastPoint && (this._active = true);
          }
          _correctButton(t2, e3) {
            return 0 === e3 && !t2.ctrlKey;
          }
          _move(t2, e3) {
            return { around: e3, panDelta: e3.sub(t2) };
          }
        }
        class Eo extends wo {
          _correctButton(t2, e3) {
            return 0 === e3 && t2.ctrlKey || 2 === e3;
          }
          _move(t2, e3) {
            const i2 = 0.8 * (e3.x - t2.x);
            if (i2)
              return this._active = true, { bearingDelta: i2 };
          }
          contextmenu(t2) {
            t2.preventDefault();
          }
        }
        class Io extends wo {
          _correctButton(t2, e3) {
            return 0 === e3 && t2.ctrlKey || 2 === e3;
          }
          _move(t2, e3) {
            const i2 = -0.5 * (e3.y - t2.y);
            if (i2)
              return this._active = true, { pitchDelta: i2 };
          }
          contextmenu(t2) {
            t2.preventDefault();
          }
        }
        class So {
          constructor(t2) {
            this._minTouches = 1, this._clickTolerance = t2.clickTolerance || 1, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new t.pointGeometry(0, 0);
          }
          touchstart(t2, e3, i2) {
            return this._calculateTransform(t2, e3, i2);
          }
          touchmove(t2, e3, i2) {
            if (this._active && !(i2.length < this._minTouches))
              return t2.preventDefault(), this._calculateTransform(t2, e3, i2);
          }
          touchend(t2, e3, i2) {
            this._calculateTransform(t2, e3, i2), this._active && i2.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e3, i2, o2) {
            o2.length > 0 && (this._active = true);
            const a2 = go(o2, i2), s2 = new t.pointGeometry(0, 0), r2 = new t.pointGeometry(0, 0);
            let n2 = 0;
            for (const t2 in a2) {
              const e4 = a2[t2], i3 = this._touches[t2];
              i3 && (s2._add(e4), r2._add(e4.sub(i3)), n2++, a2[t2] = e4);
            }
            if (this._touches = a2, n2 < this._minTouches || !r2.mag())
              return;
            const l2 = r2.div(n2);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: s2.div(n2), panDelta: l2 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Co {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          _start(t2) {
          }
          _move(t2, e3, i2) {
            return {};
          }
          touchstart(t2, e3, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e3[0], e3[1]]));
          }
          touchmove(t2, e3, i2) {
            if (!this._firstTwoTouches)
              return;
            t2.preventDefault();
            const [o2, a2] = this._firstTwoTouches, s2 = Po(i2, e3, o2), r2 = Po(i2, e3, a2);
            if (!s2 || !r2)
              return;
            const n2 = this._aroundCenter ? null : s2.add(r2).div(2);
            return this._move([s2, r2], n2, t2);
          }
          touchend(t2, e3, i2) {
            if (!this._firstTwoTouches)
              return;
            const [o2, a2] = this._firstTwoTouches, r2 = Po(i2, e3, o2), n2 = Po(i2, e3, a2);
            r2 && n2 || (this._active && s.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t2) {
            this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Po(t2, e3, i2) {
          for (let o2 = 0; o2 < t2.length; o2++)
            if (t2[o2].identifier === i2)
              return e3[o2];
        }
        function zo(t2, e3) {
          return Math.log(t2 / e3) / Math.LN2;
        }
        class Do extends Co {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t2) {
            this._startDistance = this._distance = t2[0].dist(t2[1]);
          }
          _move(t2, e3) {
            const i2 = this._distance;
            if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(zo(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: zo(this._distance, i2), pinchAround: e3 };
          }
        }
        function Ao(t2, e3) {
          return 180 * t2.angleWith(e3) / Math.PI;
        }
        class Mo extends Co {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t2) {
            this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
          }
          _move(t2, e3) {
            const i2 = this._vector;
            if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
              return this._active = true, { bearingDelta: Ao(this._vector, i2), pinchAround: e3 };
          }
          _isBelowThreshold(t2) {
            this._minDiameter = Math.min(this._minDiameter, t2.mag());
            const e3 = 25 / (Math.PI * this._minDiameter) * 360, i2 = Ao(t2, this._startVector);
            return Math.abs(i2) < e3;
          }
        }
        function Lo(t2) {
          return Math.abs(t2.y) > Math.abs(t2.x);
        }
        class Ro extends Co {
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          _start(t2) {
            this._lastPoints = t2, Lo(t2[0].sub(t2[1])) && (this._valid = false);
          }
          _move(t2, e3, i2) {
            const o2 = t2[0].sub(this._lastPoints[0]), a2 = t2[1].sub(this._lastPoints[1]);
            if (this._valid = this.gestureBeginsVertically(o2, a2, i2.timeStamp), this._valid)
              return this._lastPoints = t2, this._active = true, { pitchDelta: (o2.y + a2.y) / 2 * -0.5 };
          }
          gestureBeginsVertically(t2, e3, i2) {
            if (void 0 !== this._valid)
              return this._valid;
            const o2 = t2.mag() >= 2, a2 = e3.mag() >= 2;
            if (!o2 && !a2)
              return;
            if (!o2 || !a2)
              return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            const s2 = t2.y > 0 == e3.y > 0;
            return Lo(t2) && Lo(e3) && s2;
          }
        }
        const ko = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Bo {
          constructor() {
            const t2 = ko;
            this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(t2) {
            if (t2.altKey || t2.ctrlKey || t2.metaKey)
              return;
            let e3 = 0, i2 = 0, o2 = 0, a2 = 0, s2 = 0;
            switch (t2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e3 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e3 = -1;
                break;
              case 37:
                t2.shiftKey ? i2 = -1 : (t2.preventDefault(), a2 = -1);
                break;
              case 39:
                t2.shiftKey ? i2 = 1 : (t2.preventDefault(), a2 = 1);
                break;
              case 38:
                t2.shiftKey ? o2 = 1 : (t2.preventDefault(), s2 = -1);
                break;
              case 40:
                t2.shiftKey ? o2 = -1 : (t2.preventDefault(), s2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (r2) => {
              const n2 = r2.getZoom();
              r2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Fo, zoom: e3 ? Math.round(n2) + e3 * (t2.shiftKey ? 2 : 1) : n2, bearing: r2.getBearing() + i2 * this._bearingStep, pitch: r2.getPitch() + o2 * this._pitchStep, offset: [-a2 * this._panStep, -s2 * this._panStep], center: r2.getCenter() }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Fo(t2) {
          return t2 * (2 - t2);
        }
        const Oo = 4.000244140625;
        class Uo {
          constructor(e3, i2) {
            this._map = e3, this._el = e3.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, t.bindAll(["_onTimeout"], this);
          }
          setZoomRate(t2) {
            this._defaultZoomRate = t2;
          }
          setWheelZoomRate(t2) {
            this._wheelZoomRate = t2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = t2 && "center" === t2.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          wheel(e3) {
            if (!this.isEnabled())
              return;
            let i2 = e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e3.deltaY : e3.deltaY;
            const o2 = t.exported.now(), a2 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, 0 !== i2 && i2 % Oo == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e3)) : this._type || (this._type = Math.abs(a2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e3.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e3, this._delta -= i2, this._active || this._start(e3)), e3.preventDefault();
          }
          _onTimeout(t2) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t2);
          }
          _start(e3) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i2 = s.mousePos(this._el, e3);
            this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(i2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const e3 = this._map.transform;
            if (0 !== this._delta) {
              const t2 = "wheel" === this._type && Math.abs(this._delta) > Oo ? this._wheelZoomRate : this._defaultZoomRate;
              let i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * t2)));
              this._delta < 0 && 0 !== i3 && (i3 = 1 / i3);
              const o3 = "number" == typeof this._targetZoom ? e3.zoomScale(this._targetZoom) : e3.scale;
              this._targetZoom = Math.min(e3.maxZoom, Math.max(e3.minZoom, e3.scaleZoom(o3 * i3))), "wheel" === this._type && (this._startZoom = e3.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i2 = "number" == typeof this._targetZoom ? this._targetZoom : e3.zoom, o2 = this._startZoom, a2 = this._easing;
            let s2, r2 = false;
            if ("wheel" === this._type && o2 && a2) {
              const e4 = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1), n2 = a2(e4);
              s2 = t.number(o2, i2, n2), e4 < 1 ? this._frameId || (this._frameId = true) : r2 = true;
            } else
              s2 = i2, r2 = true;
            return this._active = true, r2 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !r2, zoomDelta: s2 - e3.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e3) {
            let i2 = t.ease;
            if (this._prevEase) {
              const e4 = this._prevEase, o2 = (t.exported.now() - e4.start) / e4.duration, a2 = e4.easing(o2 + 0.01) - e4.easing(o2), s2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, r2 = Math.sqrt(0.0729 - s2 * s2);
              i2 = t.bezier(s2, r2, 0.25, 1);
            }
            return this._prevEase = { start: t.exported.now(), duration: e3, easing: i2 }, i2;
          }
          reset() {
            this._active = false;
          }
        }
        class No {
          constructor(t2, e3) {
            this._clickZoom = t2, this._tapZoom = e3;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Go {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(t2, e3) {
            return t2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: i2.getZoom() + (t2.shiftKey ? -1 : 1), around: i2.unproject(e3) }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Zo {
          constructor() {
            this._tap = new vo({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
          }
          touchstart(t2, e3, i2) {
            this._swipePoint || (this._tapTime && t2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = e3[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(t2, e3, i2));
          }
          touchmove(t2, e3, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch)
                  return;
                const o2 = e3[0], a2 = o2.y - this._swipePoint.y;
                return this._swipePoint = o2, t2.preventDefault(), this._active = true, { zoomDelta: a2 / 128 };
              }
            } else
              this._tap.touchmove(t2, e3, i2);
          }
          touchend(t2, e3, i2) {
            this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(t2, e3, i2) && (this._tapTime = t2.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class qo {
          constructor(t2, e3, i2) {
            this._el = t2, this._mousePan = e3, this._touchPan = i2;
          }
          enable(t2) {
            this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Vo {
          constructor(t2, e3, i2) {
            this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e3, this._mousePitch = i2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class jo {
          constructor(t2, e3, i2, o2) {
            this._el = t2, this._touchZoom = e3, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(t2) {
            this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const $o = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;
        class Wo extends t.Event {
        }
        function Xo(t2) {
          return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
        }
        class Ho {
          constructor(e3, i2) {
            this._map = e3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new no(e3), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
            const o2 = this._el;
            this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [t2, e4, i3] of this._listeners)
              s.addEventListener(t2, e4, t2 === document ? this.handleWindowEvent : this.handleEvent, i3);
          }
          destroy() {
            for (const [t2, e3, i2] of this._listeners)
              s.removeEventListener(t2, e3, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
          }
          _addDefaultHandlers(t2) {
            const e3 = this._map, i2 = e3.getCanvasContainer();
            this._add("mapEvent", new _o(e3, t2));
            const o2 = e3.boxZoom = new fo(e3, t2);
            this._add("boxZoom", o2);
            const a2 = new yo(), s2 = new Go();
            e3.doubleClickZoom = new No(s2, a2), this._add("tapZoom", a2), this._add("clickZoom", s2);
            const r2 = new Zo();
            this._add("tapDragZoom", r2);
            const n2 = e3.touchPitch = new Ro();
            this._add("touchPitch", n2);
            const l2 = new Eo(t2), c2 = new Io(t2);
            e3.dragRotate = new Vo(t2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
            const h2 = new To(t2), u2 = new So(t2);
            e3.dragPan = new qo(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
            const d2 = new Mo(), m2 = new Do();
            e3.touchZoomRotate = new jo(i2, m2, d2, r2), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]);
            const _2 = e3.scrollZoom = new Uo(e3, this);
            this._add("scrollZoom", _2, ["mousePan"]);
            const p2 = e3.keyboard = new Bo();
            this._add("keyboard", p2), this._add("blockableMapEvent", new po(e3));
            for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
              t2.interactive && t2[i3] && e3[i3].enable(t2[i3]);
          }
          _add(t2, e3, i2) {
            this._handlers.push({ handlerName: t2, handler: e3, allowed: i2 }), this._handlersById[t2] = e3;
          }
          stop(t2) {
            if (!this._updatingCamera) {
              for (const { handler: t3 } of this._handlers)
                t3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t2 } of this._handlers)
              if (t2.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean($o(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t2, e3, i2) {
            for (const o2 in t2)
              if (o2 !== i2 && (!e3 || e3.indexOf(o2) < 0))
                return true;
            return false;
          }
          handleWindowEvent(t2) {
            this.handleEvent(t2, `${t2.type}Window`);
          }
          _getMapTouches(t2) {
            const e3 = [];
            for (const i2 of t2)
              this._el.contains(i2.target) && e3.push(i2);
            return e3;
          }
          handleEvent(t2, e3) {
            if ("blur" === t2.type)
              return void this.stop(true);
            this._updatingCamera = true;
            const i2 = "renderFrame" === t2.type ? void 0 : t2, o2 = { needsRenderFrame: false }, a2 = {}, r2 = {}, n2 = t2.touches, l2 = n2 ? this._getMapTouches(n2) : void 0, c2 = l2 ? s.touchPos(this._el, l2) : s.mousePos(this._el, t2);
            for (const { handlerName: s2, handler: n3, allowed: h3 } of this._handlers) {
              if (!n3.isEnabled())
                continue;
              let u3;
              this._blockedByActive(r2, h3, s2) ? n3.reset() : n3[e3 || t2.type] && (u3 = n3[e3 || t2.type](t2, c2, l2), this.mergeHandlerResult(o2, a2, u3, s2, i2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (r2[s2] = n3);
            }
            const h2 = {};
            for (const t3 in this._previousActiveHandlers)
              r2[t3] || (h2[t3] = i2);
            this._previousActiveHandlers = r2, (Object.keys(h2).length || Xo(o2)) && (this._changes.push([o2, a2, h2]), this._triggerRenderFrame()), (Object.keys(r2).length || Xo(o2)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: u2 } = o2;
            u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
          }
          mergeHandlerResult(e3, i2, o2, a2, s2) {
            if (!o2)
              return;
            t.extend(e3, o2);
            const r2 = { handlerName: a2, originalEvent: o2.originalEvent || s2 };
            void 0 !== o2.zoomDelta && (i2.zoom = r2), void 0 !== o2.panDelta && (i2.drag = r2), void 0 !== o2.pitchDelta && (i2.pitch = r2), void 0 !== o2.bearingDelta && (i2.rotate = r2);
          }
          _applyChanges() {
            const e3 = {}, i2 = {}, o2 = {};
            for (const [a2, s2, r2] of this._changes)
              a2.panDelta && (e3.panDelta = (e3.panDelta || new t.pointGeometry(0, 0))._add(a2.panDelta)), a2.zoomDelta && (e3.zoomDelta = (e3.zoomDelta || 0) + a2.zoomDelta), a2.bearingDelta && (e3.bearingDelta = (e3.bearingDelta || 0) + a2.bearingDelta), a2.pitchDelta && (e3.pitchDelta = (e3.pitchDelta || 0) + a2.pitchDelta), void 0 !== a2.around && (e3.around = a2.around), void 0 !== a2.pinchAround && (e3.pinchAround = a2.pinchAround), a2.noInertia && (e3.noInertia = a2.noInertia), t.extend(i2, s2), t.extend(o2, r2);
            this._updateMapTransform(e3, i2, o2), this._changes = [];
          }
          _updateMapTransform(t2, e3, i2) {
            const o2 = this._map, a2 = o2.transform;
            if (!Xo(t2))
              return this._fireEvents(e3, i2, true);
            let { panDelta: s2, zoomDelta: r2, bearingDelta: n2, pitchDelta: l2, around: c2, pinchAround: h2 } = t2;
            void 0 !== h2 && (c2 = h2), o2._stop(true), c2 = c2 || o2.transform.centerPoint;
            const u2 = a2.pointLocation(s2 ? c2.sub(s2) : c2);
            n2 && (a2.bearing += n2), l2 && (a2.pitch += l2), r2 && (a2.zoom += r2), a2.setLocationAtPoint(u2, c2), this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(e3, i2, true);
          }
          _fireEvents(e3, i2, o2) {
            const a2 = $o(this._eventsInProgress), s2 = $o(e3), r2 = {};
            for (const t2 in e3) {
              const { originalEvent: i3 } = e3[t2];
              this._eventsInProgress[t2] || (r2[`${t2}start`] = i3), this._eventsInProgress[t2] = e3[t2];
            }
            !a2 && s2 && this._fireEvent("movestart", s2.originalEvent);
            for (const t2 in r2)
              this._fireEvent(t2, r2[t2]);
            s2 && this._fireEvent("move", s2.originalEvent);
            for (const t2 in e3) {
              const { originalEvent: i3 } = e3[t2];
              this._fireEvent(t2, i3);
            }
            const n2 = {};
            let l2;
            for (const t2 in this._eventsInProgress) {
              const { handlerName: e4, originalEvent: o3 } = this._eventsInProgress[t2];
              this._handlersById[e4].isActive() || (delete this._eventsInProgress[t2], l2 = i2[e4] || o3, n2[`${t2}end`] = l2);
            }
            for (const t2 in n2)
              this._fireEvent(t2, n2[t2]);
            const c2 = $o(this._eventsInProgress);
            if (o2 && (a2 || s2) && !c2) {
              this._updatingCamera = true;
              const e4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t2) => 0 !== t2 && -this._bearingSnap < t2 && t2 < this._bearingSnap;
              e4 ? (i3(e4.bearing || this._map.getBearing()) && (e4.bearing = 0), this._map.easeTo(e4, { originalEvent: l2 })) : (this._map.fire(new t.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(e3, i2) {
            this._map.fire(new t.Event(e3, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
              delete this._frameId, this.handleEvent(new Wo("renderFrame", { timeStamp: t2 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        const Ko = { extend: (e3, ...i2) => t.extend(e3, ...i2), run(t2) {
          t2();
        }, logToElement(t2, e3 = false, i2 = "log") {
          const o2 = window.document.getElementById(i2);
          o2 && (e3 && (o2.innerHTML = ""), o2.innerHTML += `<br>${t2}`);
        } };
        class Yo extends t.Evented {
          constructor(e3, i2) {
            super(), this._moving = false, this._zooming = false, this.transform = e3, this._bearingSnap = i2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t2, e3) {
            return this.jumpTo({ center: t2 }, e3);
          }
          panBy(e3, i2, o2) {
            return e3 = t.pointGeometry.convert(e3).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e3 }, i2), o2);
          }
          panTo(e3, i2, o2) {
            return this.easeTo(t.extend({ center: e3 }, i2), o2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t2, e3) {
            return this.jumpTo({ zoom: t2 }, e3), this;
          }
          zoomTo(e3, i2, o2) {
            return this.easeTo(t.extend({ zoom: e3 }, i2), o2);
          }
          zoomIn(t2, e3) {
            return this.zoomTo(this.getZoom() + 1, t2, e3), this;
          }
          zoomOut(t2, e3) {
            return this.zoomTo(this.getZoom() - 1, t2, e3), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t2, e3) {
            return this.jumpTo({ bearing: t2 }, e3), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t2, e3) {
            return this.jumpTo({ padding: t2 }, e3), this;
          }
          rotateTo(e3, i2, o2) {
            return this.easeTo(t.extend({ bearing: e3 }, i2), o2);
          }
          resetNorth(e3, i2) {
            return this.rotateTo(0, t.extend({ duration: 1e3 }, e3), i2), this;
          }
          resetNorthPitch(e3, i2) {
            return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e3), i2), this;
          }
          snapToNorth(t2, e3) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e3) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t2, e3) {
            return this.jumpTo({ pitch: t2 }, e3), this;
          }
          cameraForBounds(e3, i2) {
            e3 = t.LngLatBounds.convert(e3);
            const o2 = i2 && i2.bearing || 0;
            return this._cameraForBoxAndBearing(e3.getNorthWest(), e3.getSouthEast(), o2, i2);
          }
          _cameraForBoxAndBearing(e3, i2, o2, a2) {
            const s2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (a2 = t.extend({ padding: s2, offset: [0, 0], maxZoom: this.transform.maxZoom }, a2)).padding) {
              const t2 = a2.padding;
              a2.padding = { top: t2, bottom: t2, right: t2, left: t2 };
            }
            a2.padding = t.extend(s2, a2.padding);
            const r2 = this.transform, n2 = r2.padding, l2 = r2.project(t.LngLat.convert(e3)), c2 = r2.project(t.LngLat.convert(i2)), h2 = l2.rotate(-o2 * Math.PI / 180), u2 = c2.rotate(-o2 * Math.PI / 180), d2 = new t.pointGeometry(Math.max(h2.x, u2.x), Math.max(h2.y, u2.y)), m2 = new t.pointGeometry(Math.min(h2.x, u2.x), Math.min(h2.y, u2.y)), _2 = d2.sub(m2), p2 = (r2.width - (n2.left + n2.right + a2.padding.left + a2.padding.right)) / _2.x, f2 = (r2.height - (n2.top + n2.bottom + a2.padding.top + a2.padding.bottom)) / _2.y;
            if (f2 < 0 || p2 < 0)
              return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            const g2 = Math.min(r2.scaleZoom(r2.scale * Math.min(p2, f2)), a2.maxZoom), x2 = t.pointGeometry.convert(a2.offset), v2 = new t.pointGeometry((a2.padding.left - a2.padding.right) / 2, (a2.padding.top - a2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), y2 = x2.add(v2).mult(r2.scale / r2.zoomScale(g2));
            return { center: r2.unproject(l2.add(c2).div(2).sub(y2)), zoom: g2, bearing: o2 };
          }
          fitBounds(t2, e3, i2) {
            return this._fitInternal(this.cameraForBounds(t2, e3), e3, i2);
          }
          fitScreenCoordinates(e3, i2, o2, a2, s2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.pointGeometry.convert(e3)), this.transform.pointLocation(t.pointGeometry.convert(i2)), o2, a2), a2, s2);
          }
          _fitInternal(e3, i2, o2) {
            return e3 ? (delete (i2 = t.extend(e3, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
          }
          jumpTo(e3, i2) {
            this.stop();
            const o2 = this.transform;
            let a2 = false, s2 = false, r2 = false;
            return "zoom" in e3 && o2.zoom !== +e3.zoom && (a2 = true, o2.zoom = +e3.zoom), void 0 !== e3.center && (o2.center = t.LngLat.convert(e3.center)), "bearing" in e3 && o2.bearing !== +e3.bearing && (s2 = true, o2.bearing = +e3.bearing), "pitch" in e3 && o2.pitch !== +e3.pitch && (r2 = true, o2.pitch = +e3.pitch), null == e3.padding || o2.isPaddingEqual(e3.padding) || (o2.padding = e3.padding), this.fire(new t.Event("movestart", i2)).fire(new t.Event("move", i2)), a2 && this.fire(new t.Event("zoomstart", i2)).fire(new t.Event("zoom", i2)).fire(new t.Event("zoomend", i2)), s2 && this.fire(new t.Event("rotatestart", i2)).fire(new t.Event("rotate", i2)).fire(new t.Event("rotateend", i2)), r2 && this.fire(new t.Event("pitchstart", i2)).fire(new t.Event("pitch", i2)).fire(new t.Event("pitchend", i2)), this.fire(new t.Event("moveend", i2));
          }
          easeTo(e3, i2) {
            this._stop(false, e3.easeId), (false === (e3 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e3)).animate || !e3.essential && t.exported.prefersReducedMotion) && (e3.duration = 0);
            const o2 = this.transform, a2 = this.getZoom(), s2 = this.getBearing(), r2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e3 ? +e3.zoom : a2, c2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, s2) : s2, h2 = "pitch" in e3 ? +e3.pitch : r2, u2 = "padding" in e3 ? e3.padding : o2.padding, d2 = t.pointGeometry.convert(e3.offset);
            let m2 = o2.centerPoint.add(d2);
            const _2 = o2.pointLocation(m2), p2 = t.LngLat.convert(e3.center || _2);
            this._normalizeCenter(p2);
            const f2 = o2.project(_2), g2 = o2.project(p2).sub(f2), x2 = o2.zoomScale(l2 - a2);
            let v2, y2;
            e3.around && (v2 = t.LngLat.convert(e3.around), y2 = o2.locationPoint(v2));
            const b2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || l2 !== a2, this._rotating = this._rotating || s2 !== c2, this._pitching = this._pitching || h2 !== r2, this._padding = !o2.isPaddingEqual(u2), this._easeId = e3.easeId, this._prepareEase(i2, e3.noMoveStart, b2), this._ease((e4) => {
              if (this._zooming && (o2.zoom = t.number(a2, l2, e4)), this._rotating && (o2.bearing = t.number(s2, c2, e4)), this._pitching && (o2.pitch = t.number(r2, h2, e4)), this._padding && (o2.interpolatePadding(n2, u2, e4), m2 = o2.centerPoint.add(d2)), v2)
                o2.setLocationAtPoint(v2, y2);
              else {
                const t2 = o2.zoomScale(o2.zoom - a2), i3 = l2 > a2 ? Math.min(2, x2) : Math.max(0.5, x2), s3 = Math.pow(i3, 1 - e4), r3 = o2.unproject(f2.add(g2.mult(e4 * s3)).mult(t2));
                o2.setLocationAtPoint(o2.renderWorldCopies ? r3.wrap() : r3, m2);
              }
              this._fireMoveEvents(i2);
            }, (t2) => {
              this._afterEase(i2, t2);
            }, e3), this;
          }
          _prepareEase(e3, i2, o2 = {}) {
            this._moving = true, i2 || o2.moving || this.fire(new t.Event("movestart", e3)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e3)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e3)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e3));
          }
          _fireMoveEvents(e3) {
            this.fire(new t.Event("move", e3)), this._zooming && this.fire(new t.Event("zoom", e3)), this._rotating && this.fire(new t.Event("rotate", e3)), this._pitching && this.fire(new t.Event("pitch", e3));
          }
          _afterEase(e3, i2) {
            if (this._easeId && i2 && this._easeId === i2)
              return;
            delete this._easeId;
            const o2 = this._zooming, a2 = this._rotating, s2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new t.Event("zoomend", e3)), a2 && this.fire(new t.Event("rotateend", e3)), s2 && this.fire(new t.Event("pitchend", e3)), this.fire(new t.Event("moveend", e3));
          }
          flyTo(e3, i2) {
            if (!e3.essential && t.exported.prefersReducedMotion) {
              const o3 = t.pick(e3, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o3, i2);
            }
            this.stop(), e3 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e3);
            const o2 = this.transform, a2 = this.getZoom(), s2 = this.getBearing(), r2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e3 ? t.clamp(+e3.zoom, o2.minZoom, o2.maxZoom) : a2, c2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, s2) : s2, h2 = "pitch" in e3 ? +e3.pitch : r2, u2 = "padding" in e3 ? e3.padding : o2.padding, d2 = o2.zoomScale(l2 - a2), m2 = t.pointGeometry.convert(e3.offset);
            let _2 = o2.centerPoint.add(m2);
            const p2 = o2.pointLocation(_2), f2 = t.LngLat.convert(e3.center || p2);
            this._normalizeCenter(f2);
            const g2 = o2.project(p2), x2 = o2.project(f2).sub(g2);
            let v2 = e3.curve;
            const y2 = Math.max(o2.width, o2.height), b2 = y2 / d2, w2 = x2.mag();
            if ("minZoom" in e3) {
              const i3 = t.clamp(Math.min(e3.minZoom, a2, l2), o2.minZoom, o2.maxZoom), s3 = y2 / o2.zoomScale(i3 - a2);
              v2 = Math.sqrt(s3 / w2 * 2);
            }
            const T2 = v2 * v2;
            function E2(t2) {
              const e4 = (b2 * b2 - y2 * y2 + (t2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (t2 ? b2 : y2) * T2 * w2);
              return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
            }
            function I2(t2) {
              return (Math.exp(t2) - Math.exp(-t2)) / 2;
            }
            function S2(t2) {
              return (Math.exp(t2) + Math.exp(-t2)) / 2;
            }
            const C2 = E2(0);
            let P2 = function(t2) {
              return S2(C2) / S2(C2 + v2 * t2);
            }, z2 = function(t2) {
              return y2 * ((S2(C2) * (I2(e4 = C2 + v2 * t2) / S2(e4)) - I2(C2)) / T2) / w2;
              var e4;
            }, D2 = (E2(1) - C2) / v2;
            if (Math.abs(w2) < 1e-6 || !isFinite(D2)) {
              if (Math.abs(y2 - b2) < 1e-6)
                return this.easeTo(e3, i2);
              const t2 = b2 < y2 ? -1 : 1;
              D2 = Math.abs(Math.log(b2 / y2)) / v2, z2 = function() {
                return 0;
              }, P2 = function(e4) {
                return Math.exp(t2 * v2 * e4);
              };
            }
            return e3.duration = "duration" in e3 ? +e3.duration : 1e3 * D2 / ("screenSpeed" in e3 ? +e3.screenSpeed / v2 : +e3.speed), e3.maxDuration && e3.duration > e3.maxDuration && (e3.duration = 0), this._zooming = true, this._rotating = s2 !== c2, this._pitching = h2 !== r2, this._padding = !o2.isPaddingEqual(u2), this._prepareEase(i2, false), this._ease((e4) => {
              const d3 = e4 * D2, p3 = 1 / P2(d3);
              o2.zoom = 1 === e4 ? l2 : a2 + o2.scaleZoom(p3), this._rotating && (o2.bearing = t.number(s2, c2, e4)), this._pitching && (o2.pitch = t.number(r2, h2, e4)), this._padding && (o2.interpolatePadding(n2, u2, e4), _2 = o2.centerPoint.add(m2));
              const v3 = 1 === e4 ? f2 : o2.unproject(g2.add(x2.mult(z2(d3))).mult(p3));
              o2.setLocationAtPoint(o2.renderWorldCopies ? v3.wrap() : v3, _2), this._fireMoveEvents(i2);
            }, () => this._afterEase(i2), e3), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t2, e3) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const t3 = this._onEaseEnd;
              delete this._onEaseEnd, t3.call(this, e3);
            }
            if (!t2) {
              const t3 = this.handlers;
              t3 && t3.stop(false);
            }
            return this;
          }
          _ease(e3, i2, o2) {
            false === o2.animate || 0 === o2.duration ? (e3(1), i2()) : (this._easeStart = t.exported.now(), this._easeOptions = o2, this._onEaseFrame = e3, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const e3 = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(e3, i2) {
            e3 = t.wrap(e3, -180, 180);
            const o2 = Math.abs(e3 - i2);
            return Math.abs(e3 - 360 - i2) < o2 && (e3 -= 360), Math.abs(e3 + 360 - i2) < o2 && (e3 += 360), e3;
          }
          _normalizeCenter(t2) {
            const e3 = this.transform;
            if (!e3.renderWorldCopies || e3.lngRange)
              return;
            const i2 = t2.lng - e3.center.lng;
            t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
        }
        class Jo {
          constructor(e3 = {}) {
            this.options = e3, t.bindAll(["_toggleAttribution", "_updateData", "_updateCompact", "_updateCompactMinimize"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t2) {
            return this._map = t2, this._compact = this.options && this.options.compact, this._container = s.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = s.create("summary", "maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = s.create("div", "maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            s.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t2, e3) {
            const i2 = this._map._getUIString(`AttributionControl.${e3}`);
            t2.title = i2, t2.setAttribute("aria-label", i2);
          }
          _toggleAttribution() {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.classList.add("maplibregl-compact-show", "mapboxgl-compact-show"), this._container.removeAttribute("open")));
          }
          _updateData(t2) {
            !t2 || "metadata" !== t2.sourceDataType && "visibility" !== t2.sourceDataType && "style" !== t2.dataType || this._updateAttributions();
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let t2 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => "string" != typeof t3 ? "" : t3)) : "string" == typeof this.options.customAttribution && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const t3 = this._map.style.stylesheet;
              this.styleOwner = t3.owner, this.styleId = t3.id;
            }
            const e3 = this._map.style.sourceCaches;
            for (const i3 in e3) {
              const o2 = e3[i3];
              if (o2.used) {
                const e4 = o2.getSource();
                e4.attribution && t2.indexOf(e4.attribution) < 0 && t2.push(e4.attribution);
              }
            }
            t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e4) => t3.length - e4.length), t2 = t2.filter((e4, i3) => {
              for (let o2 = i3 + 1; o2 < t2.length; o2++)
                if (t2[o2].indexOf(e4) >= 0)
                  return false;
              return true;
            });
            const i2 = t2.join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty", "mapboxgl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty", "mapboxgl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "mapboxgl-compact", "maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show", "mapboxgl-compact", "mapboxgl-compact-show"));
          }
          _updateCompactMinimize() {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show");
          }
        }
        class Qo {
          constructor(e3 = {}) {
            this.options = e3, t.bindAll(["_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t2) {
            this._map = t2, this._compact = this.options && this.options.compact, this._container = s.create("div", "maplibregl-ctrl mapboxgl-ctrl");
            const e3 = s.create("a", "maplibregl-ctrl-logo mapboxgl-ctrl-logo");
            return e3.target = "_blank", e3.rel = "noopener nofollow", e3.href = "https://maplibre.org/", e3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e3), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            s.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
          _updateCompact() {
            const t2 = this._container.children;
            if (t2.length) {
              const e3 = t2[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e3.classList.add("maplibregl-compact", "mapboxgl-compact") : e3.classList.remove("maplibregl-compact", "mapboxgl-compact");
            }
          }
        }
        class ta {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(t2) {
            const e3 = ++this._id;
            return this._queue.push({ callback: t2, id: e3, cancelled: false }), e3;
          }
          remove(t2) {
            const e3 = this._currentlyRunning, i2 = e3 ? this._queue.concat(e3) : this._queue;
            for (const e4 of i2)
              if (e4.id === t2)
                return void (e4.cancelled = true);
          }
          run(t2 = 0) {
            const e3 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i2 of e3)
              if (!i2.cancelled && (i2.callback(t2), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        const ea = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, ia = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, fadeDuration: 300, crossSourceCollisions: true }, oa = { showCompass: true, showZoom: true, visualizePitch: false };
        class aa {
          constructor(e3, i2, o2 = false) {
            this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Eo({ clickTolerance: e3.dragRotate._mouseRotate._clickTolerance }), this.map = e3, o2 && (this.mousePitch = new Io({ clickTolerance: e3.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), s.addEventListener(i2, "mousedown", this.mousedown), s.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), s.addEventListener(i2, "touchmove", this.touchmove), s.addEventListener(i2, "touchend", this.touchend), s.addEventListener(i2, "touchcancel", this.reset);
          }
          down(t2, e3) {
            this.mouseRotate.mousedown(t2, e3), this.mousePitch && this.mousePitch.mousedown(t2, e3), s.disableDrag();
          }
          move(t2, e3) {
            const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(t2, e3);
            if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
              const o3 = this.mousePitch.mousemoveWindow(t2, e3);
              o3 && o3.pitchDelta && i2.setPitch(i2.getPitch() + o3.pitchDelta);
            }
          }
          off() {
            const t2 = this.element;
            s.removeEventListener(t2, "mousedown", this.mousedown), s.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), s.removeEventListener(t2, "touchmove", this.touchmove), s.removeEventListener(t2, "touchend", this.touchend), s.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            s.enableDrag(), s.removeEventListener(window, "mousemove", this.mousemove), s.removeEventListener(window, "mouseup", this.mouseup);
          }
          mousedown(e3) {
            this.down(t.extend({}, e3, { ctrlKey: true, preventDefault: () => e3.preventDefault() }), s.mousePos(this.element, e3)), s.addEventListener(window, "mousemove", this.mousemove), s.addEventListener(window, "mouseup", this.mouseup);
          }
          mousemove(t2) {
            this.move(t2, s.mousePos(this.element, t2));
          }
          mouseup(t2) {
            this.mouseRotate.mouseupWindow(t2), this.mousePitch && this.mousePitch.mouseupWindow(t2), this.offTemp();
          }
          touchstart(t2) {
            1 !== t2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = s.touchPos(this.element, t2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => t2.preventDefault() }, this._startPos));
          }
          touchmove(t2) {
            1 !== t2.targetTouches.length ? this.reset() : (this._lastPos = s.touchPos(this.element, t2.targetTouches)[0], this.move({ preventDefault: () => t2.preventDefault() }, this._lastPos));
          }
          touchend(t2) {
            0 === t2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        function sa(e3, i2, o2) {
          if (e3 = new t.LngLat(e3.lng, e3.lat), i2) {
            const a2 = new t.LngLat(e3.lng - 360, e3.lat), s2 = new t.LngLat(e3.lng + 360, e3.lat), r2 = o2.locationPoint(e3).distSqr(i2);
            o2.locationPoint(a2).distSqr(i2) < r2 ? e3 = a2 : o2.locationPoint(s2).distSqr(i2) < r2 && (e3 = s2);
          }
          for (; Math.abs(e3.lng - o2.center.lng) > 180; ) {
            const t2 = o2.locationPoint(e3);
            if (t2.x >= 0 && t2.y >= 0 && t2.x <= o2.width && t2.y <= o2.height)
              break;
            e3.lng > o2.center.lng ? e3.lng -= 360 : e3.lng += 360;
          }
          return e3;
        }
        const ra = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function na(t2, e3, i2) {
          const o2 = t2.classList;
          for (const t3 in ra)
            o2.remove(`maplibregl-${i2}-anchor-${t3}`, `mapboxgl-${i2}-anchor-${t3}`);
          o2.add(`maplibregl-${i2}-anchor-${e3}`, `mapboxgl-${i2}-anchor-${e3}`);
        }
        class la extends t.Evented {
          constructor(e3, i2) {
            if (super(), (e3 instanceof HTMLElement || i2) && (e3 = t.extend({ element: e3 }, i2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = e3 && e3.anchor || "center", this._color = e3 && e3.color || "#3FB1CE", this._scale = e3 && e3.scale || 1, this._draggable = e3 && e3.draggable || false, this._clickTolerance = e3 && e3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e3 && e3.rotation || 0, this._rotationAlignment = e3 && e3.rotationAlignment || "auto", this._pitchAlignment = e3 && e3.pitchAlignment && "auto" !== e3.pitchAlignment ? e3.pitchAlignment : this._rotationAlignment, e3 && e3.element)
              this._element = e3.element, this._offset = t.pointGeometry.convert(e3 && e3.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = s.create("div"), this._element.setAttribute("aria-label", "Map marker");
              const i3 = s.createNS("http://www.w3.org/2000/svg", "svg"), o2 = 41, a2 = 27;
              i3.setAttributeNS(null, "display", "block"), i3.setAttributeNS(null, "height", `${o2}px`), i3.setAttributeNS(null, "width", `${a2}px`), i3.setAttributeNS(null, "viewBox", `0 0 ${a2} ${o2}`);
              const r2 = s.createNS("http://www.w3.org/2000/svg", "g");
              r2.setAttributeNS(null, "stroke", "none"), r2.setAttributeNS(null, "stroke-width", "1"), r2.setAttributeNS(null, "fill", "none"), r2.setAttributeNS(null, "fill-rule", "evenodd");
              const n2 = s.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "fill-rule", "nonzero");
              const l2 = s.createNS("http://www.w3.org/2000/svg", "g");
              l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
              const c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const t2 of c2) {
                const e4 = s.createNS("http://www.w3.org/2000/svg", "ellipse");
                e4.setAttributeNS(null, "opacity", "0.04"), e4.setAttributeNS(null, "cx", "10.5"), e4.setAttributeNS(null, "cy", "5.80029008"), e4.setAttributeNS(null, "rx", t2.rx), e4.setAttributeNS(null, "ry", t2.ry), l2.appendChild(e4);
              }
              const h2 = s.createNS("http://www.w3.org/2000/svg", "g");
              h2.setAttributeNS(null, "fill", this._color);
              const u2 = s.createNS("http://www.w3.org/2000/svg", "path");
              u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(u2);
              const d2 = s.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
              const m2 = s.createNS("http://www.w3.org/2000/svg", "path");
              m2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(m2);
              const _2 = s.createNS("http://www.w3.org/2000/svg", "g");
              _2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), _2.setAttributeNS(null, "fill", "#FFFFFF");
              const p2 = s.createNS("http://www.w3.org/2000/svg", "g");
              p2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f2 = s.createNS("http://www.w3.org/2000/svg", "circle");
              f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
              const g2 = s.createNS("http://www.w3.org/2000/svg", "circle");
              g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), p2.appendChild(f2), p2.appendChild(g2), n2.appendChild(l2), n2.appendChild(h2), n2.appendChild(d2), n2.appendChild(_2), n2.appendChild(p2), i3.appendChild(n2), i3.setAttributeNS(null, "height", o2 * this._scale + "px"), i3.setAttributeNS(null, "width", a2 * this._scale + "px"), this._element.appendChild(i3), this._offset = t.pointGeometry.convert(e3 && e3.offset || [0, -14]);
            }
            this._element.classList.add("maplibregl-marker", "mapboxgl-marker"), this._element.addEventListener("dragstart", (t2) => {
              t2.preventDefault();
            }), this._element.addEventListener("mousedown", (t2) => {
              t2.preventDefault();
            }), na(this._element, this._anchor, "marker"), this._popup = null;
          }
          addTo(t2) {
            return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), s.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e3) {
            return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
              if (!("offset" in t2.options)) {
                const e3 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e3], "bottom-left": [o2, -1 * (e3 - i2 + o2)], "bottom-right": [-o2, -1 * (e3 - i2 + o2)], left: [i2, -1 * (e3 - i2)], right: [-i2, -1 * (e3 - i2)] } : this._offset;
              }
              this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          _onKeyPress(t2) {
            const e3 = t2.code, i2 = t2.charCode || t2.keyCode;
            "Space" !== e3 && "Enter" !== e3 && 32 !== i2 && 13 !== i2 || this.togglePopup();
          }
          _onMapClick(t2) {
            const e3 = t2.originalEvent.target, i2 = this._element;
            this._popup && (e3 === i2 || i2.contains(e3)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t2 = this._popup;
            return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
          }
          _update(t2) {
            if (!this._map)
              return;
            this._map.transform.renderWorldCopies && (this._lngLat = sa(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            let e3 = "";
            "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e3 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (e3 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let i2 = "";
            "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? i2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (i2 = `rotateX(${this._map.getPitch()}deg)`), t2 && "moveend" !== t2.type || (this._pos = this._pos.round()), s.setTransform(this._element, `${ra[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i2} ${e3}`);
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e3) {
            return this._offset = t.pointGeometry.convert(e3), this._update(), this;
          }
          _onMove(e3) {
            if (!this._isDragging) {
              const t2 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = e3.point.dist(this._pointerdownPos) >= t2;
            }
            this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";
          }
          _addDragHandler(t2) {
            this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._offset), this._pointerdownPos = t2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }
          setDraggable(t2) {
            return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t2) {
            return this._rotation = t2 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t2) {
            return this._rotationAlignment = t2 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t2) {
            return this._pitchAlignment = t2 && "auto" !== t2 ? t2 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
        }
        const ca = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let ha, ua = 0, da = false;
        const ma = { maxWidth: 100, unit: "metric" };
        function _a2(t2, e3, i2) {
          const o2 = i2 && i2.maxWidth || 100, a2 = t2._container.clientHeight / 2, s2 = t2.unproject([0, a2]), r2 = t2.unproject([o2, a2]), n2 = s2.distanceTo(r2);
          if (i2 && "imperial" === i2.unit) {
            const i3 = 3.2808 * n2;
            i3 > 5280 ? pa(e3, o2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : pa(e3, o2, i3, t2._getUIString("ScaleControl.Feet"));
          } else
            i2 && "nautical" === i2.unit ? pa(e3, o2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1e3 ? pa(e3, o2, n2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : pa(e3, o2, n2, t2._getUIString("ScaleControl.Meters"));
        }
        function pa(t2, e3, i2, o2) {
          const a2 = function(t3) {
            const e4 = Math.pow(10, `${Math.floor(t3)}`.length - 1);
            let i3 = t3 / e4;
            return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
              const e5 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
              return Math.round(t4 * e5) / e5;
            }(i3), e4 * i3;
          }(i2);
          t2.style.width = e3 * (a2 / i2) + "px", t2.innerHTML = `${a2}&nbsp;${o2}`;
        }
        const fa = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, ga = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function xa(e3) {
          if (e3) {
            if ("number" == typeof e3) {
              const i2 = Math.round(Math.sqrt(0.5 * Math.pow(e3, 2)));
              return { center: new t.pointGeometry(0, 0), top: new t.pointGeometry(0, e3), "top-left": new t.pointGeometry(i2, i2), "top-right": new t.pointGeometry(-i2, i2), bottom: new t.pointGeometry(0, -e3), "bottom-left": new t.pointGeometry(i2, -i2), "bottom-right": new t.pointGeometry(-i2, -i2), left: new t.pointGeometry(e3, 0), right: new t.pointGeometry(-e3, 0) };
            }
            if (e3 instanceof t.pointGeometry || Array.isArray(e3)) {
              const i2 = t.pointGeometry.convert(e3);
              return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
            }
            return { center: t.pointGeometry.convert(e3.center || [0, 0]), top: t.pointGeometry.convert(e3.top || [0, 0]), "top-left": t.pointGeometry.convert(e3["top-left"] || [0, 0]), "top-right": t.pointGeometry.convert(e3["top-right"] || [0, 0]), bottom: t.pointGeometry.convert(e3.bottom || [0, 0]), "bottom-left": t.pointGeometry.convert(e3["bottom-left"] || [0, 0]), "bottom-right": t.pointGeometry.convert(e3["bottom-right"] || [0, 0]), left: t.pointGeometry.convert(e3.left || [0, 0]), right: t.pointGeometry.convert(e3.right || [0, 0]) };
          }
          return xa(new t.pointGeometry(0, 0));
        }
        const va = { supported: e2, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: class extends Yo {
          constructor(e3) {
            var i2;
            if (t.PerformanceUtils.mark(t.PerformanceMarkers.create), null != (e3 = t.extend({}, ia, e3)).minZoom && null != e3.maxZoom && e3.minZoom > e3.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != e3.minPitch && null != e3.maxPitch && e3.minPitch > e3.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != e3.minPitch && e3.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != e3.maxPitch && e3.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (super(new to(e3.minZoom, e3.maxZoom, e3.minPitch, e3.maxPitch, e3.renderWorldCopies), { bearingSnap: e3.bearingSnap }), this._interactive = e3.interactive, this._maxTileCacheSize = e3.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e3.preserveDrawingBuffer, this._antialias = e3.antialias, this._trackResize = e3.trackResize, this._bearingSnap = e3.bearingSnap, this._refreshExpiredTiles = e3.refreshExpiredTiles, this._fadeDuration = e3.fadeDuration, this._crossSourceCollisions = e3.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e3.collectResourceTiming, this._renderTaskQueue = new ta(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, ea, e3.locale), this._clickTolerance = e3.clickTolerance, this._pixelRatio = null !== (i2 = e3.pixelRatio) && void 0 !== i2 ? i2 : devicePixelRatio, this._requestManager = new r(e3.transformRequest), "string" == typeof e3.container) {
              if (this._container = document.getElementById(e3.container), !this._container)
                throw new Error(`Container '${e3.container}' not found.`);
            } else {
              if (!(e3.container instanceof HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = e3.container;
            }
            if (e3.maxBounds && this.setMaxBounds(e3.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
              throw new Error("Failed to initialize WebGL.");
            this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), "undefined" != typeof window && (addEventListener("online", this._onWindowOnline, false), addEventListener("resize", this._onWindowResize, false), addEventListener("orientationchange", this._onWindowResize, false)), this.handlers = new Ho(this, e3), this._hash = e3.hash && new eo("string" == typeof e3.hash && e3.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e3.center, zoom: e3.zoom, bearing: e3.bearing, pitch: e3.pitch }), e3.bounds && (this.resize(), this.fitBounds(e3.bounds, t.extend({}, e3.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e3.localIdeographFontFamily, e3.style && this.setStyle(e3.style, { localIdeographFontFamily: e3.localIdeographFontFamily }), e3.attributionControl && this.addControl(new Jo({ customAttribution: e3.customAttribution })), e3.maplibreLogo && this.addControl(new Qo(), e3.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (e4) => {
              this._update("style" === e4.dataType), this.fire(new t.Event(`${e4.dataType}data`, e4));
            }), this.on("dataloading", (e4) => {
              this.fire(new t.Event(`${e4.dataType}dataloading`, e4));
            }), this.on("dataabort", (e4) => {
              this.fire(new t.Event("sourcedataabort", e4));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(e3, i2) {
            if (void 0 === i2 && (i2 = e3.getDefaultPosition ? e3.getDefaultPosition() : "top-right"), !e3 || !e3.onAdd)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o2 = e3.onAdd(this);
            this._controls.push(e3);
            const a2 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? a2.insertBefore(o2, a2.firstChild) : a2.appendChild(o2), this;
          }
          removeControl(e3) {
            if (!e3 || !e3.onRemove)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i2 = this._controls.indexOf(e3);
            return i2 > -1 && this._controls.splice(i2, 1), e3.onRemove(this), this;
          }
          hasControl(t2) {
            return this._controls.indexOf(t2) > -1;
          }
          resize(e3) {
            const i2 = this._containerDimensions(), o2 = i2[0], a2 = i2[1];
            this._resizeCanvas(o2, a2, this.getPixelRatio()), this.transform.resize(o2, a2), this.painter.resize(o2, a2, this.getPixelRatio());
            const s2 = !this._moving;
            return s2 && (this.stop(), this.fire(new t.Event("movestart", e3)).fire(new t.Event("move", e3))), this.fire(new t.Event("resize", e3)), s2 && this.fire(new t.Event("moveend", e3)), this;
          }
          getPixelRatio() {
            return this._pixelRatio;
          }
          setPixelRatio(t2) {
            const [e3, i2] = this._containerDimensions();
            this._pixelRatio = t2, this._resizeCanvas(e3, i2, t2), this.painter.resize(e3, i2, t2);
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(e3) {
            return this.transform.setMaxBounds(t.LngLatBounds.convert(e3)), this._update();
          }
          setMinZoom(t2) {
            if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
              return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t2) {
            if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
              return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t2) {
            if ((t2 = null == t2 ? 0 : t2) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch)
              return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t2) {
            if ((t2 = null == t2 ? 60 : t2) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t2 >= this.transform.minPitch)
              return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t2) {
            return this.transform.renderWorldCopies = t2, this._update();
          }
          project(e3) {
            return this.transform.locationPoint(t.LngLat.convert(e3));
          }
          unproject(e3) {
            return this.transform.pointLocation(t.pointGeometry.convert(e3));
          }
          isMoving() {
            return this._moving || this.handlers.isMoving();
          }
          isZooming() {
            return this._zooming || this.handlers.isZooming();
          }
          isRotating() {
            return this._rotating || this.handlers.isRotating();
          }
          _createDelegatedListener(t2, e3, i2) {
            if ("mouseenter" === t2 || "mouseover" === t2) {
              let o2 = false;
              const a2 = (a3) => {
                const s2 = this.getLayer(e3) ? this.queryRenderedFeatures(a3.point, { layers: [e3] }) : [];
                s2.length ? o2 || (o2 = true, i2.call(this, new ho(t2, this, a3.originalEvent, { features: s2 }))) : o2 = false;
              };
              return { layer: e3, listener: i2, delegates: { mousemove: a2, mouseout: () => {
                o2 = false;
              } } };
            }
            if ("mouseleave" === t2 || "mouseout" === t2) {
              let o2 = false;
              const a2 = (a3) => {
                (this.getLayer(e3) ? this.queryRenderedFeatures(a3.point, { layers: [e3] }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new ho(t2, this, a3.originalEvent)));
              }, s2 = (e4) => {
                o2 && (o2 = false, i2.call(this, new ho(t2, this, e4.originalEvent)));
              };
              return { layer: e3, listener: i2, delegates: { mousemove: a2, mouseout: s2 } };
            }
            {
              const o2 = (t3) => {
                const o3 = this.getLayer(e3) ? this.queryRenderedFeatures(t3.point, { layers: [e3] }) : [];
                o3.length && (t3.features = o3, i2.call(this, t3), delete t3.features);
              };
              return { layer: e3, listener: i2, delegates: { [t2]: o2 } };
            }
          }
          on(t2, e3, i2) {
            if (void 0 === i2)
              return super.on(t2, e3);
            const o2 = this._createDelegatedListener(t2, e3, i2);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(o2);
            for (const t3 in o2.delegates)
              this.on(t3, o2.delegates[t3]);
            return this;
          }
          once(t2, e3, i2) {
            if (void 0 === i2)
              return super.once(t2, e3);
            const o2 = this._createDelegatedListener(t2, e3, i2);
            for (const t3 in o2.delegates)
              this.once(t3, o2.delegates[t3]);
            return this;
          }
          off(t2, e3, i2) {
            return void 0 === i2 ? super.off(t2, e3) : (this._delegatedListeners && this._delegatedListeners[t2] && ((o2) => {
              const a2 = this._delegatedListeners[t2];
              for (let t3 = 0; t3 < a2.length; t3++) {
                const o3 = a2[t3];
                if (o3.layer === e3 && o3.listener === i2) {
                  for (const t4 in o3.delegates)
                    this.off(t4, o3.delegates[t4]);
                  return a2.splice(t3, 1), this;
                }
              }
            })(), this);
          }
          queryRenderedFeatures(e3, i2) {
            if (!this.style)
              return [];
            let o2;
            if (void 0 !== i2 || void 0 === e3 || e3 instanceof t.pointGeometry || Array.isArray(e3) || (i2 = e3, e3 = void 0), i2 = i2 || {}, (e3 = e3 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.pointGeometry || "number" == typeof e3[0])
              o2 = [t.pointGeometry.convert(e3)];
            else {
              const i3 = t.pointGeometry.convert(e3[0]), a2 = t.pointGeometry.convert(e3[1]);
              o2 = [i3, new t.pointGeometry(a2.x, i3.y), a2, new t.pointGeometry(i3.x, a2.y), i3];
            }
            return this.style.queryRenderedFeatures(o2, i2, this.transform);
          }
          querySourceFeatures(t2, e3) {
            return this.style.querySourceFeatures(t2, e3);
          }
          setStyle(e3, i2) {
            return false !== (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e3 ? (this._diffStyle(e3, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e3, i2));
          }
          setTransformRequest(t2) {
            return this._requestManager.setTransformRequest(t2), this;
          }
          _getUIString(t2) {
            const e3 = this._locale[t2];
            if (null == e3)
              throw new Error(`Missing UI string '${t2}'`);
            return e3;
          }
          _updateStyle(t2, e3) {
            return this.style && (this.style.setEventedParent(null), this.style._remove()), t2 ? (this.style = new ie(this, e3 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t2 ? this.style.loadURL(t2) : this.style.loadJSON(t2), this) : (delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new ie(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(e3, i2) {
            if ("string" == typeof e3) {
              const o2 = this._requestManager.transformRequest(e3, t.ResourceType.Style);
              t.getJSON(o2, (e4, o3) => {
                e4 ? this.fire(new t.ErrorEvent(e4)) : o3 && this._updateDiff(o3, i2);
              });
            } else
              "object" == typeof e3 && this._updateDiff(e3, i2);
          }
          _updateDiff(e3, i2) {
            try {
              this.style.setState(e3) && this._update(true);
            } catch (o2) {
              t.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(e3, i2);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
          }
          addSource(t2, e3) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t2, e3), this._update(true);
          }
          isSourceLoaded(e3) {
            const i2 = this.style && this.style.sourceCaches[e3];
            if (void 0 !== i2)
              return i2.loaded();
            this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e3}'`)));
          }
          areTilesLoaded() {
            const t2 = this.style && this.style.sourceCaches;
            for (const e3 in t2) {
              const i2 = t2[e3]._tiles;
              for (const t3 in i2) {
                const e4 = i2[t3];
                if ("loaded" !== e4.state && "errored" !== e4.state)
                  return false;
              }
            }
            return true;
          }
          addSourceType(t2, e3, i2) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e3, i2);
          }
          removeSource(t2) {
            return this.style.removeSource(t2), this._update(true);
          }
          getSource(t2) {
            return this.style.getSource(t2);
          }
          addImage(e3, i2, { pixelRatio: o2 = 1, sdf: a2 = false, stretchX: s2, stretchY: r2, content: n2 } = {}) {
            if (this._lazyInitEmptyStyle(), i2 instanceof HTMLImageElement || t.isImageBitmap(i2)) {
              const { width: l2, height: c2, data: h2 } = t.exported.getImageData(i2);
              this.style.addImage(e3, { data: new t.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: s2, stretchY: r2, content: n2, sdf: a2, version: 0 });
            } else {
              if (void 0 === i2.width || void 0 === i2.height)
                return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: l2, height: c2, data: h2 } = i2, u2 = i2;
                this.style.addImage(e3, { data: new t.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2)), pixelRatio: o2, stretchX: s2, stretchY: r2, content: n2, sdf: a2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e3);
              }
            }
          }
          updateImage(e3, i2) {
            const o2 = this.style.getImage(e3);
            if (!o2)
              return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const a2 = i2 instanceof HTMLImageElement || t.isImageBitmap(i2) ? t.exported.getImageData(i2) : i2, { width: s2, height: r2, data: n2 } = a2;
            if (void 0 === s2 || void 0 === r2)
              return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (s2 !== o2.data.width || r2 !== o2.data.height)
              return this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const l2 = !(i2 instanceof HTMLImageElement || t.isImageBitmap(i2));
            o2.data.replace(n2, l2), this.style.updateImage(e3, o2);
          }
          hasImage(e3) {
            return e3 ? !!this.style.getImage(e3) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
          }
          removeImage(t2) {
            this.style.removeImage(t2);
          }
          loadImage(e3, i2) {
            t.getImage(this._requestManager.transformRequest(e3, t.ResourceType.Image), i2);
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t2, e3) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e3), this._update(true);
          }
          moveLayer(t2, e3) {
            return this.style.moveLayer(t2, e3), this._update(true);
          }
          removeLayer(t2) {
            return this.style.removeLayer(t2), this._update(true);
          }
          getLayer(t2) {
            return this.style.getLayer(t2);
          }
          setLayerZoomRange(t2, e3, i2) {
            return this.style.setLayerZoomRange(t2, e3, i2), this._update(true);
          }
          setFilter(t2, e3, i2 = {}) {
            return this.style.setFilter(t2, e3, i2), this._update(true);
          }
          getFilter(t2) {
            return this.style.getFilter(t2);
          }
          setPaintProperty(t2, e3, i2, o2 = {}) {
            return this.style.setPaintProperty(t2, e3, i2, o2), this._update(true);
          }
          getPaintProperty(t2, e3) {
            return this.style.getPaintProperty(t2, e3);
          }
          setLayoutProperty(t2, e3, i2, o2 = {}) {
            return this.style.setLayoutProperty(t2, e3, i2, o2), this._update(true);
          }
          getLayoutProperty(t2, e3) {
            return this.style.getLayoutProperty(t2, e3);
          }
          setLight(t2, e3 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(t2, e3), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setFeatureState(t2, e3) {
            return this.style.setFeatureState(t2, e3), this._update();
          }
          removeFeatureState(t2, e3) {
            return this.style.removeFeatureState(t2, e3), this._update();
          }
          getFeatureState(t2) {
            return this.style.getFeatureState(t2);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t2 = 0, e3 = 0;
            return this._container && (t2 = this._container.clientWidth || 400, e3 = this._container.clientHeight || 300), [t2, e3];
          }
          _setupContainer() {
            const t2 = this._container;
            t2.classList.add("maplibregl-map", "mapboxgl-map");
            const e3 = this._canvasContainer = s.create("div", "maplibregl-canvas-container mapboxgl-canvas-container", t2);
            this._interactive && e3.classList.add("maplibregl-interactive", "mapboxgl-interactive"), this._canvas = s.create("canvas", "maplibregl-canvas mapboxgl-canvas", e3), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            const i2 = this._containerDimensions();
            this._resizeCanvas(i2[0], i2[1], this.getPixelRatio());
            const o2 = this._controlContainer = s.create("div", "maplibregl-control-container mapboxgl-control-container", t2), a2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
              a2[t3] = s.create("div", `maplibregl-ctrl-${t3} mapboxgl-ctrl-${t3}`, o2);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t2, e3, i2) {
            this._canvas.width = i2 * t2, this._canvas.height = i2 * e3, this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${e3}px`;
          }
          _setupPainter() {
            const i2 = t.extend({}, e2.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
            o2 ? (this.painter = new Ki(o2, this.transform), t.exported$1.testSupport(o2)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
          }
          _contextLost(e3) {
            e3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e3 }));
          }
          _contextRestored(e3) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e3 }));
          }
          _onMapScroll(t2) {
            if (t2.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(t2) {
            return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(t2) {
            return this._update(), this._renderTaskQueue.add(t2);
          }
          _cancelRenderFrame(t2) {
            this._renderTaskQueue.remove(t2);
          }
          _render(e3) {
            let i2, o2 = 0;
            const a2 = this.painter.context.extTimerQuery;
            if (this.listens("gpu-timing-frame") && (i2 = a2.createQueryEXT(), a2.beginQueryEXT(a2.TIME_ELAPSED_EXT, i2), o2 = t.exported.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e3), this._removed)
              return;
            let s2 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const e4 = this.transform.zoom, i3 = t.exported.now();
              this.style.zoomHistory.update(e4, i3);
              const o3 = new t.EvaluationParameters(e4, { now: i3, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), a3 = o3.crossFadingFactor();
              1 === a3 && a3 === this._crossFadingFactor || (s2 = true, this._crossFadingFactor = a3), this.style.update(o3);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, t.PerformanceUtils.mark(t.PerformanceMarkers.load), this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || s2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              const e4 = t.exported.now() - o2;
              a2.endQueryEXT(a2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                const o3 = a2.getQueryObjectEXT(i2, a2.QUERY_RESULT_EXT) / 1e6;
                a2.deleteQueryEXT(i2), this.fire(new t.Event("gpu-timing-frame", { cpuTime: e4, gpuTime: o3 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const e4 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i3 = this.painter.queryGpuTimers(e4);
                this.fire(new t.Event("gpu-timing-layer", { layerTimes: i3 }));
              }, 50);
            }
            const r2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return r2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || r2 || (this._fullyLoaded = true, t.PerformanceUtils.mark(t.PerformanceMarkers.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const t2 of this._controls)
              t2.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && (removeEventListener("resize", this._onWindowResize, false), removeEventListener("orientationchange", this._onWindowResize, false), removeEventListener("online", this._onWindowOnline, false));
            const e3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e3 && e3.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), s.remove(this._canvasContainer), s.remove(this._controlContainer), this._container.classList.remove("maplibregl-map", "mapboxgl-map"), t.PerformanceUtils.clearMetrics(), this._removed = true, this.fire(new t.Event("remove"));
          }
          triggerRepaint() {
            this.style && !this._frame && (this._frame = t.exported.frame((e3) => {
              t.PerformanceUtils.frame(e3), this._frame = null, this._render(e3);
            }));
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(t2) {
            this._trackResize && this.resize({ originalEvent: t2 })._update();
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t2) {
            this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t2) {
            this._showPadding !== t2 && (this._showPadding = t2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t2) {
            this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t2) {
            this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t2) {
            this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t2) {
            this._vertices = t2, this._update();
          }
          _setCacheLimits(e3, i2) {
            t.setCacheLimits(e3, i2);
          }
        }, NavigationControl: class {
          constructor(e3) {
            this.options = t.extend({}, oa, e3), this._container = s.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in", (t2) => this._map.zoomIn({}, { originalEvent: t2 })), s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out", (t2) => this._map.zoomOut({}, { originalEvent: t2 })), s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("maplibregl-ctrl-compass mapboxgl-ctrl-compass", (t2) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t2 }) : this._map.resetNorth({}, { originalEvent: t2 });
            }), this._compassIcon = s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const t2 = this._map.getZoom(), e3 = t2 === this._map.getMaxZoom(), i2 = t2 === this._map.getMinZoom();
            this._zoomInButton.disabled = e3, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e3.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
          }
          _rotateCompassArrow() {
            const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t2;
          }
          onAdd(t2) {
            return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new aa(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            s.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(t2, e3) {
            const i2 = s.create("button", t2, this._container);
            return i2.type = "button", i2.addEventListener("click", e3), i2;
          }
          _setButtonTitle(t2, e3) {
            const i2 = this._map._getUIString(`NavigationControl.${e3}`);
            t2.title = i2, t2.setAttribute("aria-label", i2);
          }
        }, GeolocateControl: class extends t.Evented {
          constructor(e3) {
            super(), this.options = t.extend({}, ca, e3), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
          }
          onAdd(t2) {
            var e3;
            return this._map = t2, this._container = s.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), e3 = this._setupUI, void 0 !== ha ? e3(ha) : void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((t3) => {
              ha = "denied" !== t3.state, e3(ha);
            }) : (ha = !!window.navigator.geolocation, e3(ha)), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), s.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ua = 0, da = false;
          }
          _isOutOfMapMaxBounds(t2) {
            const e3 = this._map.getMaxBounds(), i2 = t2.coords;
            return e3 && (i2.longitude < e3.getWest() || i2.longitude > e3.getEast() || i2.latitude < e3.getSouth() || i2.latitude > e3.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(e3) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e3))
                return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = e3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");
                }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e3)), this._finish();
            }
          }
          _updateCamera(e3) {
            const i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude), o2 = e3.coords.accuracy, a2 = this._map.getBearing(), s2 = t.extend({ bearing: a2 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i2.toBounds(o2), s2, { geolocateSource: true });
          }
          _updateMarker(e3) {
            if (e3) {
              const i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const t2 = this._map._container.clientHeight / 2, e3 = this._map.unproject([0, t2]), i2 = this._map.unproject([1, t2]), o2 = e3.distanceTo(i2), a2 = Math.ceil(2 * this._accuracy / o2);
            this._circleElement.style.width = `${a2}px`, this._circleElement.style.height = `${a2}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _onError(e3) {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (1 === e3.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const t2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === e3.code && da)
                    return;
                  this._setErrorState();
                }
              "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e3)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(e3) {
            if (this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this._geolocateButton = s.create("button", "maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate", this._container), s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e3) {
              t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
            } else {
              const t2 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = s.create("div", "maplibregl-user-location-dot mapboxgl-user-location-dot"), this._userLocationDotMarker = new la(this._dotElement), this._circleElement = s.create("div", "maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new la({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
              e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this.fire(new t.Event("trackuserlocationend")));
            });
          }
          trigger() {
            if (!this._setup)
              return t.warnOnce("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  ua--, da = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let t2;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ua++, ua > 1 ? (t2 = { maximumAge: 6e5, timeout: 0 }, da = true) : (t2 = this.options.positionOptions, da = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
              }
            } else
              window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Jo, LogoControl: Qo, ScaleControl: class {
          constructor(e3) {
            this.options = t.extend({}, ma, e3), t.bindAll(["_onMove", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _onMove() {
            _a2(this._map, this._container, this.options);
          }
          onAdd(t2) {
            return this._map = t2, this._container = s.create("div", "maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            s.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
          setUnit(t2) {
            this.options.unit = t2, _a2(this._map, this._container, this.options);
          }
        }, FullscreenControl: class {
          constructor(e3) {
            this._fullscreen = false, e3 && e3.container && (e3.container instanceof HTMLElement ? this._container = e3.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(e3) {
            return this._map = e3, this._container || (this._container = this._map.getContainer()), this._controlContainer = s.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            s.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const t2 = this._fullscreenButton = s.create("button", "maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen", this._controlContainer);
            s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const t2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen && window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends t.Evented {
          constructor(e3) {
            super(), this.options = t.extend(Object.create(fa), e3), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
          }
          addTo(e3) {
            return this._map && this.remove(), this._map = e3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            return this._content && s.remove(this._content), this._container && (s.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e3) {
            return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t2) {
            return this.setDOMContent(document.createTextNode(t2));
          }
          setHTML(t2) {
            const e3 = document.createDocumentFragment(), i2 = document.createElement("body");
            let o2;
            for (i2.innerHTML = t2; o2 = i2.firstChild, o2; )
              e3.appendChild(o2);
            return this.setDOMContent(e3);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(t2) {
            return this.options.maxWidth = t2, this._update(), this;
          }
          setDOMContent(t2) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else
              this._content = s.create("div", "maplibregl-popup-content mapboxgl-popup-content", this._container);
            return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(t2) {
            this._container && this._container.classList.add(t2);
          }
          removeClassName(t2) {
            this._container && this._container.classList.remove(t2);
          }
          setOffset(t2) {
            return this.options.offset = t2, this._update(), this;
          }
          toggleClassName(t2) {
            if (this._container)
              return this._container.classList.toggle(t2);
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = s.create("button", "maplibregl-popup-close-button mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _onMouseUp(t2) {
            this._update(t2.point);
          }
          _onMouseMove(t2) {
            this._update(t2.point);
          }
          _onDrag(t2) {
            this._update(t2.point);
          }
          _update(t2) {
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
              return;
            if (this._container || (this._container = s.create("div", "maplibregl-popup mapboxgl-popup", this._map.getContainer()), this._tip = s.create("div", "maplibregl-popup-tip mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((t3) => this._container.classList.add(t3)), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = sa(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t2)
              return;
            const e3 = this._pos = this._trackPointer && t2 ? t2 : this._map.project(this._lngLat);
            let i2 = this.options.anchor;
            const o2 = xa(this.options.offset);
            if (!i2) {
              const t3 = this._container.offsetWidth, a3 = this._container.offsetHeight;
              let s2;
              s2 = e3.y + o2.bottom.y < a3 ? ["top"] : e3.y > this._map.transform.height - a3 ? ["bottom"] : [], e3.x < t3 / 2 ? s2.push("left") : e3.x > this._map.transform.width - t3 / 2 && s2.push("right"), i2 = 0 === s2.length ? "bottom" : s2.join("-");
            }
            const a2 = e3.add(o2[i2]).round();
            s.setTransform(this._container, `${ra[i2]} translate(${a2.x}px,${a2.y}px)`), na(this._container, i2, "popup");
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const t2 = this._container.querySelector(ga);
            t2 && t2.focus();
          }
          _onClose() {
            this.remove();
          }
        }, Marker: la, Style: ie, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.pointGeometry, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, AJAXError: t.AJAXError, config: t.config, CanvasSource: R, GeoJSONSource: D, ImageSource: M, RasterDEMTileSource: z, RasterTileSource: C, VectorTileSource: S, VideoSource: L, prewarm: function() {
          H().acquire(j);
        }, clearPrewarmedResources: function() {
          const t2 = X;
          t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(j), X = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get workerCount() {
          return $.workerCount;
        }, set workerCount(t2) {
          $.workerCount = t2;
        }, get maxParallelImageRequests() {
          return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(e3) {
          t.config.MAX_PARALLEL_IMAGE_REQUESTS = e3;
        }, clearStorage(e3) {
          t.clearTileCache(e3);
        }, workerUrl: "", addProtocol(e3, i2) {
          t.config.REGISTERED_PROTOCOLS[e3] = i2;
        }, removeProtocol(e3) {
          delete t.config.REGISTERED_PROTOCOLS[e3];
        } };
        return Ko.extend(va, { isSafari: t.isSafari, getPerformanceMetrics: t.PerformanceUtils.getPerformanceMetrics }), va;
      });
      var maplibregl$1 = maplibregl5;
      return maplibregl$1;
    });
  }
});

// node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/map-obj/index.js"(exports, module) {
    "use strict";
    var isObject2 = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = (value) => isObject2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = {
        deep: false,
        target: {},
        ...options
      };
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module.exports = (object, mapper, options) => {
      if (!isObject2(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    module.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports, module) {
    "use strict";
    var preserveCamelCase = (string) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
      }
      return string;
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
      return postProcess(input);
    };
    module.exports = camelCase;
    module.exports.default = camelCase;
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports, module) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return this._size + oldCacheSize;
      }
    };
    module.exports = QuickLRU;
  }
});

// node_modules/camelcase-keys/index.js
var require_camelcase_keys = __commonJS({
  "node_modules/camelcase-keys/index.js"(exports, module) {
    "use strict";
    var mapObj = require_map_obj();
    var camelCase = require_camelcase();
    var QuickLru = require_quick_lru();
    var has = (array, key) => array.some((x) => {
      if (typeof x === "string") {
        return x === key;
      }
      x.lastIndex = 0;
      return x.test(key);
    });
    var cache = new QuickLru({ maxSize: 1e5 });
    var isObject2 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var camelCaseConvert = (input, options) => {
      if (!isObject2(input)) {
        return input;
      }
      options = {
        deep: false,
        pascalCase: false,
        ...options
      };
      const { exclude, pascalCase, stopPaths, deep } = options;
      const stopPathsSet = new Set(stopPaths);
      const makeMapper = (parentPath) => (key, value) => {
        if (deep && isObject2(value)) {
          const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
          if (!stopPathsSet.has(path)) {
            value = mapObj(value, makeMapper(path));
          }
        }
        if (!(exclude && has(exclude, key))) {
          const cacheKey = pascalCase ? `${key}_` : key;
          if (cache.has(cacheKey)) {
            key = cache.get(cacheKey);
          } else {
            const ret = camelCase(key, { pascalCase });
            if (key.length < 100) {
              cache.set(cacheKey, ret);
            }
            key = ret;
          }
        }
        return [key, value];
      };
      return mapObj(input, makeMapper(void 0));
    };
    module.exports = (input, options) => {
      if (Array.isArray(input)) {
        return Object.keys(input).map((key) => camelCaseConvert(input[key], options));
      }
      return camelCaseConvert(input, options);
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/fuzzy/lib/fuzzy.js
var require_fuzzy = __commonJS({
  "node_modules/fuzzy/lib/fuzzy.js"(exports, module) {
    (function() {
      var root = this;
      var fuzzy = {};
      if (typeof exports !== "undefined") {
        module.exports = fuzzy;
      } else {
        root.fuzzy = fuzzy;
      }
      fuzzy.simpleFilter = function(pattern, array) {
        return array.filter(function(str) {
          return fuzzy.test(pattern, str);
        });
      };
      fuzzy.test = function(pattern, str) {
        return fuzzy.match(pattern, str) !== null;
      };
      fuzzy.match = function(pattern, str, opts) {
        opts = opts || {};
        var patternIdx = 0, result = [], len = str.length, totalScore = 0, currScore = 0, pre = opts.pre || "", post = opts.post || "", compareString = opts.caseSensitive && str || str.toLowerCase(), ch;
        pattern = opts.caseSensitive && pattern || pattern.toLowerCase();
        for (var idx = 0; idx < len; idx++) {
          ch = str[idx];
          if (compareString[idx] === pattern[patternIdx]) {
            ch = pre + ch + post;
            patternIdx += 1;
            currScore += 1 + currScore;
          } else {
            currScore = 0;
          }
          totalScore += currScore;
          result[result.length] = ch;
        }
        if (patternIdx === pattern.length) {
          totalScore = compareString === pattern ? Infinity : totalScore;
          return { rendered: result.join(""), score: totalScore };
        }
        return null;
      };
      fuzzy.filter = function(pattern, arr, opts) {
        if (!arr || arr.length === 0) {
          return [];
        }
        if (typeof pattern !== "string") {
          return arr;
        }
        opts = opts || {};
        return arr.reduce(function(prev, element, idx, arr2) {
          var str = element;
          if (opts.extract) {
            str = opts.extract(element);
          }
          var rendered = fuzzy.match(pattern, str, opts);
          if (rendered != null) {
            prev[prev.length] = {
              string: rendered.rendered,
              score: rendered.score,
              index: idx,
              original: element
            };
          }
          return prev;
        }, []).sort(function(a, b) {
          var compare = b.score - a.score;
          if (compare)
            return compare;
          return a.index - b.index;
        });
      };
    })();
  }
});

// node_modules/suggestions-list/src/list.js
var require_list = __commonJS({
  "node_modules/suggestions-list/src/list.js"(exports, module) {
    "use strict";
    var List = function(component) {
      this.component = component;
      this.items = [];
      this.active = component.options.noInitialSelection ? -1 : 0;
      this.wrapper = document.createElement("div");
      this.wrapper.className = "suggestions-wrapper";
      this.element = document.createElement("ul");
      this.element.className = "suggestions";
      this.wrapper.appendChild(this.element);
      this.selectingListItem = false;
      component.el.parentNode.insertBefore(this.wrapper, component.el.nextSibling);
      return this;
    };
    List.prototype.show = function() {
      this.element.style.display = "block";
    };
    List.prototype.hide = function() {
      this.element.style.display = "none";
    };
    List.prototype.add = function(item) {
      this.items.push(item);
    };
    List.prototype.clear = function() {
      this.items = [];
      this.active = this.component.options.noInitialSelection ? -1 : 0;
    };
    List.prototype.isEmpty = function() {
      return !this.items.length;
    };
    List.prototype.isVisible = function() {
      return this.element.style.display === "block";
    };
    List.prototype.draw = function() {
      this.element.innerHTML = "";
      if (this.items.length === 0) {
        this.hide();
        return;
      }
      for (var i = 0; i < this.items.length; i++) {
        this.drawItem(this.items[i], this.active === i);
      }
      this.show();
    };
    List.prototype.drawItem = function(item, active) {
      var li = document.createElement("li"), a = document.createElement("a");
      if (active)
        li.className += " active";
      a.innerHTML = item.string;
      li.appendChild(a);
      this.element.appendChild(li);
      li.addEventListener("mousedown", (function() {
        this.selectingListItem = true;
      }).bind(this));
      li.addEventListener("mouseup", (function() {
        this.handleMouseUp.call(this, item);
      }).bind(this));
    };
    List.prototype.handleMouseUp = function(item) {
      this.selectingListItem = false;
      this.component.value(item.original);
      this.clear();
      this.draw();
    };
    List.prototype.move = function(index) {
      this.active = index;
      this.draw();
    };
    List.prototype.previous = function() {
      this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
    };
    List.prototype.next = function() {
      this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
    };
    List.prototype.drawError = function(msg) {
      var li = document.createElement("li");
      li.innerHTML = msg;
      this.element.appendChild(li);
      this.show();
    };
    module.exports = List;
  }
});

// node_modules/suggestions-list/src/suggestions.js
var require_suggestions = __commonJS({
  "node_modules/suggestions-list/src/suggestions.js"(exports, module) {
    "use strict";
    var extend = require_immutable();
    var fuzzy = require_fuzzy();
    var List = require_list();
    var Suggestions = function(el, data, options) {
      options = options || {};
      this.options = extend({
        minLength: 2,
        limit: 5,
        filter: true,
        hideOnBlur: true,
        noInitialSelection: true
      }, options);
      this.el = el;
      this.data = data || [];
      this.list = new List(this);
      this.query = "";
      this.selected = null;
      this.list.draw();
      this.el.addEventListener("keyup", (function(e2) {
        this.handleKeyUp(e2.keyCode, e2);
      }).bind(this), false);
      this.el.addEventListener("keydown", (function(e2) {
        this.handleKeyDown(e2);
      }).bind(this));
      this.el.addEventListener("focus", (function() {
        this.handleFocus();
      }).bind(this));
      this.el.addEventListener("blur", (function() {
        this.handleBlur();
      }).bind(this));
      this.el.addEventListener("paste", (function(e2) {
        this.handlePaste(e2);
      }).bind(this));
      this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this);
      this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this);
      return this;
    };
    Suggestions.prototype.handleKeyUp = function(keyCode, e2) {
      if (keyCode === 40 || keyCode === 38 || keyCode === 27 || keyCode === 9)
        return;
      if (keyCode === 13) {
        if (this.list.items[this.list.active]) {
          this.list.handleMouseUp(this.list.items[this.list.active]);
          e2.stopPropagation();
        }
        return;
      }
      this.handleInputChange(this.el.value);
    };
    Suggestions.prototype.handleKeyDown = function(e2) {
      switch (e2.keyCode) {
        case 13:
          if (this.list.active >= 0) {
            this.list.selectingListItem = true;
          }
          break;
        case 9:
          if (!this.list.isEmpty()) {
            if (this.list.isVisible()) {
              e2.preventDefault();
            }
            this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null);
            this.list.hide();
          }
          break;
        case 27:
          if (!this.list.isEmpty())
            this.list.hide();
          break;
        case 38:
          this.list.previous();
          break;
        case 40:
          this.list.next();
          break;
      }
    };
    Suggestions.prototype.handleBlur = function() {
      if (!this.list.selectingListItem && this.options.hideOnBlur) {
        this.list.hide();
      }
    };
    Suggestions.prototype.handlePaste = function(e2) {
      if (e2.clipboardData) {
        this.handleInputChange(e2.clipboardData.getData("Text"));
      } else {
        var self2 = this;
        setTimeout(function() {
          self2.handleInputChange(e2.target.value);
        }, 100);
      }
    };
    Suggestions.prototype.handleInputChange = function(query) {
      this.query = this.normalize(query);
      this.list.clear();
      if (this.query.length < this.options.minLength) {
        this.list.draw();
        return;
      }
      this.getCandidates((function(data) {
        for (var i = 0; i < data.length; i++) {
          this.list.add(data[i]);
          if (i === this.options.limit - 1)
            break;
        }
        this.list.draw();
      }).bind(this));
    };
    Suggestions.prototype.handleFocus = function() {
      if (!this.list.isEmpty())
        this.list.show();
      this.list.selectingListItem = false;
    };
    Suggestions.prototype.update = function(revisedData) {
      this.data = revisedData;
      this.handleKeyUp();
    };
    Suggestions.prototype.clear = function() {
      this.data = [];
      this.list.clear();
    };
    Suggestions.prototype.normalize = function(value) {
      value = value.toLowerCase();
      return value;
    };
    Suggestions.prototype.match = function(candidate, query) {
      return candidate.indexOf(query) > -1;
    };
    Suggestions.prototype.value = function(value) {
      this.selected = value;
      this.el.value = this.getItemValue(value || { place_name: this.query });
      if (document.createEvent) {
        var e2 = document.createEvent("HTMLEvents");
        e2.initEvent("change", true, false);
        this.el.dispatchEvent(e2);
      } else {
        this.el.fireEvent("onchange");
      }
    };
    Suggestions.prototype.getCandidates = function(callback) {
      var options = {
        pre: "<strong>",
        post: "</strong>",
        extract: (function(d) {
          return this.getItemValue(d);
        }).bind(this)
      };
      var results;
      if (this.options.filter) {
        results = fuzzy.filter(this.query, this.data, options);
        results = results.map((function(item) {
          return {
            original: item.original,
            string: this.render(item.original, item.string)
          };
        }).bind(this));
      } else {
        results = this.data.map((function(d) {
          var renderedString = this.render(d);
          return {
            original: d,
            string: renderedString
          };
        }).bind(this));
      }
      callback(results);
    };
    Suggestions.prototype.getItemValue = function(item) {
      return item;
    };
    Suggestions.prototype.render = function(item, sourceFormatting) {
      if (sourceFormatting) {
        return sourceFormatting;
      }
      var boldString = item.original ? this.getItemValue(item.original) : this.getItemValue(item);
      var indexString = this.normalize(boldString);
      var indexOfQuery = indexString.lastIndexOf(this.query);
      while (indexOfQuery > -1) {
        var endIndexOfQuery = indexOfQuery + this.query.length;
        boldString = boldString.slice(0, indexOfQuery) + "<strong>" + boldString.slice(indexOfQuery, endIndexOfQuery) + "</strong>" + boldString.slice(endIndexOfQuery);
        indexOfQuery = indexString.slice(0, indexOfQuery).lastIndexOf(this.query);
      }
      return boldString;
    };
    Suggestions.prototype.renderError = function(msg) {
      this.list.drawError(msg);
    };
    module.exports = Suggestions;
  }
});

// node_modules/suggestions-list/index.js
var require_suggestions_list = __commonJS({
  "node_modules/suggestions-list/index.js"(exports, module) {
    "use strict";
    var Suggestions = require_suggestions();
    module.exports = Suggestions;
    if (typeof window !== "undefined") {
      window.Suggestions = Suggestions;
    }
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce2;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@maplibre/maplibre-gl-geocoder/lib/exceptions.js
var require_exceptions = __commonJS({
  "node_modules/@maplibre/maplibre-gl-geocoder/lib/exceptions.js"(exports, module) {
    module.exports = {
      "fr": {
        "name": "France",
        "bbox": [[-4.59235, 41.380007], [9.560016, 51.148506]]
      },
      "us": {
        "name": "United States",
        "bbox": [[-171.791111, 18.91619], [-66.96466, 71.357764]]
      },
      "ru": {
        "name": "Russia",
        "bbox": [[19.66064, 41.151416], [190.10042, 81.2504]]
      },
      "ca": {
        "name": "Canada",
        "bbox": [[-140.99778, 41.675105], [-52.648099, 83.23324]]
      }
    };
  }
});

// node_modules/@maplibre/maplibre-gl-geocoder/lib/localization.js
var require_localization = __commonJS({
  "node_modules/@maplibre/maplibre-gl-geocoder/lib/localization.js"(exports, module) {
    "use strict";
    var placeholder = {
      // list drawn from https://docs.mapbox.com/api/search/#language-coverage
      "de": "Suche",
      // german
      "it": "Ricerca",
      //italian
      "en": "Search",
      // english
      "nl": "Zoeken",
      //dutch
      "fr": "Chercher",
      //french
      "ca": "Cerca",
      //catalan
      "he": "",
      //hebrew
      "ja": "",
      //japanese
      "lv": "Meklt",
      //latvian
      "pt": "Procurar",
      //portuguese 
      "sr": "",
      //serbian
      "zh": "",
      //chinese-simplified
      "cs": "Vyhledvn",
      //czech
      "hu": "Keress",
      //hungarian
      "ka": "",
      // georgian
      "nb": "Ske",
      //norwegian
      "sk": "Vyhadvanie",
      //slovak
      "th": "",
      //thai
      "fi": "Hae",
      //finnish
      "is": "Leita",
      //icelandic
      "ko": "",
      //korean
      "pl": "Szukaj",
      //polish
      "sl": "Iskanje",
      //slovenian
      "fa": "",
      //persian(aka farsi)
      "ru": ""
      //russian
    };
    module.exports = { placeholder };
  }
});

// node_modules/subtag/subtag.js
var require_subtag = __commonJS({
  "node_modules/subtag/subtag.js"(exports, module) {
    !function(root, name, make) {
      if (typeof module != "undefined" && module.exports)
        module.exports = make();
      else
        root[name] = make();
    }(exports, "subtag", function() {
      var empty = "";
      var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
      function match(tag) {
        return tag.match(pattern) || [];
      }
      function split(tag) {
        return match(tag).filter(function(v, i) {
          return v && i;
        });
      }
      function api(tag) {
        tag = match(tag);
        return {
          language: tag[1] || empty,
          extlang: tag[2] || empty,
          script: tag[3] || empty,
          region: tag[4] || empty
        };
      }
      function expose(target, key, value) {
        Object.defineProperty(target, key, {
          value,
          enumerable: true
        });
      }
      function part(position, pattern2, type) {
        function method(tag) {
          return match(tag)[position] || empty;
        }
        expose(method, "pattern", pattern2);
        expose(api, type, method);
      }
      part(1, /^[a-zA-Z]{2,3}$/, "language");
      part(2, /^[a-zA-Z]{3}$/, "extlang");
      part(3, /^[a-zA-Z]{4}$/, "script");
      part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region");
      expose(api, "split", split);
      return api;
    });
  }
});

// node_modules/@maplibre/maplibre-gl-geocoder/lib/index.js
var require_lib = __commonJS({
  "node_modules/@maplibre/maplibre-gl-geocoder/lib/index.js"(exports, module) {
    "use strict";
    var Typeahead = require_suggestions_list();
    var debounce2 = require_lodash();
    var extend = require_immutable();
    var EventEmitter = require_events().EventEmitter;
    var exceptions = require_exceptions();
    var localization = require_localization();
    var subtag = require_subtag();
    function MaplibreGeocoder2(geocoderApi, options) {
      this._eventEmitter = new EventEmitter();
      this.options = extend({}, this.options, options);
      this.inputString = "";
      this.fresh = true;
      this.lastSelected = null;
      this.geocoderApi = geocoderApi;
    }
    MaplibreGeocoder2.prototype = {
      options: {
        zoom: 16,
        flyTo: true,
        trackProximity: true,
        showResultsWhileTyping: false,
        minLength: 2,
        reverseGeocode: false,
        limit: 5,
        enableEventLogging: true,
        marker: true,
        popup: false,
        maplibregl: null,
        collapsed: false,
        clearAndBlurOnEsc: false,
        clearOnBlur: false,
        getItemValue: function(item) {
          return item.text !== void 0 ? item.text : item.place_name;
        },
        render: function(item) {
          if (!item.geometry) {
            var suggestionString = item.text;
            var indexOfMatch = suggestionString.toLowerCase().indexOf(this.query.toLowerCase());
            var lengthOfMatch = this.query.length;
            var beforeMatch = suggestionString.substring(0, indexOfMatch);
            var match = suggestionString.substring(
              indexOfMatch,
              indexOfMatch + lengthOfMatch
            );
            var afterMatch = suggestionString.substring(
              indexOfMatch + lengthOfMatch
            );
            return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibregl-ctrl-geocoder--suggestion"><svg class="mapboxgl-ctrl-geocoder--suggestion-icon maplibre-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="mapboxgl-ctrl-geocoder--suggestion-info maplibregl-ctrl-geocoder--suggestion-info"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibregl-ctrl-geocoder--suggestion-title">' + beforeMatch + '<span class="mapboxgl-ctrl-geocoder--suggestion-match maplibregl-ctrl-geocoder--suggestion-match">' + match + "</span>" + afterMatch + "</div></div></div>";
          } else {
            var placeName = item.place_name.split(",");
            return '<div class="mapboxgl-ctrl-geocoder--result maplibregl-ctrl-geocoder--result"><svg class="mapboxgl-ctrl-geocoder--result-icon maplibre-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="mapboxgl-ctrl-geocoder--result-title maplibregl-ctrl-geocoder--result-title">' + placeName[0] + '</div><div class="mapboxgl-ctrl-geocoder--result-address maplibregl-ctrl-geocoder--result-address">' + placeName.splice(1, placeName.length).join(",") + "</div></div></div>";
          }
        },
        popupRender: function(item) {
          var placeName = item.place_name.split(",");
          return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibre-ctrl-geocoder--suggestion popup-suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibre-ctrl-geocoder--suggestion-title popup-suggestion-title">' + placeName[0] + '</div><div class="mapboxgl-ctrl-geocoder--suggestion-address maplibre-ctrl-geocoder--suggestion-address popup-suggestion-address">' + placeName.splice(1, placeName.length).join(",") + "</div></div>";
        },
        showResultMarkers: true,
        debounceSearch: 200
      },
      /**
       * Add the geocoder to a container. The container can be either a `maplibregl.Map`, an `HTMLElement` or a CSS selector string.
       *
       * If the container is a [`maplibregl.Map`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#addcontrol).
       * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
       * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
       *
       * This function will throw an error if the container is none of the above.
       * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
       *
       * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
       *
       * ```javascript
       * var GeoApi = {
       *   forwardGeocode: (config) => { return { features: [] } },
       *   reverseGeocode: (config) => { return { features: [] } }
       * }
       * var geocoder = new MaplibreGeocoder(GeoAPI, {});
       * geocoder.addTo('#geocoder-container');
       * ```
       * @param {String|HTMLElement|maplibregl.Map} container A reference to the container to which to add the geocoder
       */
      addTo: function(container) {
        function addToExistingContainer(geocoder, container2) {
          if (!document.body.contains(container2)) {
            throw new Error(
              "Element provided to #addTo() exists, but is not in the DOM"
            );
          }
          var el = geocoder.onAdd();
          container2.appendChild(el);
        }
        if (container._controlContainer) {
          container.addControl(this);
        } else if (container instanceof HTMLElement) {
          addToExistingContainer(this, container);
        } else if (typeof container == "string") {
          var parent = document.querySelectorAll(container);
          if (parent.length === 0) {
            throw new Error("Element ", container, "not found.");
          }
          if (parent.length > 1) {
            throw new Error("Geocoder can only be added to a single html element");
          }
          addToExistingContainer(this, parent[0]);
        } else {
          throw new Error(
            "Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element"
          );
        }
      },
      onAdd: function(map) {
        if (map && typeof map != "string") {
          this._map = map;
        }
        this.setLanguage();
        if (this.options.localGeocoderOnly && !this.options.localGeocoder) {
          throw new Error(
            "A localGeocoder function must be specified to use localGeocoderOnly mode"
          );
        }
        this._onChange = this._onChange.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onPaste = this._onPaste.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this._showButton = this._showButton.bind(this);
        this._hideButton = this._hideButton.bind(this);
        this._onQueryResult = this._onQueryResult.bind(this);
        this.clear = this.clear.bind(this);
        this._updateProximity = this._updateProximity.bind(this);
        this._collapse = this._collapse.bind(this);
        this._unCollapse = this._unCollapse.bind(this);
        this._clear = this._clear.bind(this);
        this._clearOnBlur = this._clearOnBlur.bind(this);
        var el = this.container = document.createElement("div");
        el.className = "mapboxgl-ctrl-geocoder mapboxgl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
        var searchIcon = this.createIcon(
          "search",
          '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>'
        );
        this._inputEl = document.createElement("input");
        this._inputEl.type = "text";
        this._inputEl.className = "mapboxgl-ctrl-geocoder--input maplibregl-ctrl-geocoder--input";
        this.setPlaceholder();
        if (this.options.collapsed) {
          this._collapse();
          this.container.addEventListener("mouseenter", this._unCollapse);
          this.container.addEventListener("mouseleave", this._collapse);
          this._inputEl.addEventListener("focus", this._unCollapse);
        }
        if (this.options.collapsed || this.options.clearOnBlur) {
          this._inputEl.addEventListener("blur", this._onBlur);
        }
        this._inputEl.addEventListener(
          "keydown",
          debounce2(this._onKeyDown, this.options.debounceSearch)
        );
        this._inputEl.addEventListener("paste", this._onPaste);
        this._inputEl.addEventListener("change", this._onChange);
        this.container.addEventListener("mouseenter", this._showButton);
        this.container.addEventListener("mouseleave", this._hideButton);
        var actions = document.createElement("div");
        actions.classList.add(
          "mapboxgl-ctrl-geocoder--pin-right",
          "maplibregl-ctrl-geocoder--pin-right"
        );
        this._clearEl = document.createElement("button");
        this._clearEl.setAttribute("aria-label", "Clear");
        this._clearEl.addEventListener("click", this.clear);
        this._clearEl.className = "mapboxgl-ctrl-geocoder--button maplibregl-ctrl-geocoder--button";
        var buttonIcon = this.createIcon(
          "close",
          '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>'
        );
        this._clearEl.appendChild(buttonIcon);
        this._loadingEl = this.createIcon(
          "loading",
          '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'
        );
        actions.appendChild(this._clearEl);
        actions.appendChild(this._loadingEl);
        el.appendChild(searchIcon);
        el.appendChild(this._inputEl);
        el.appendChild(actions);
        this._typeahead = new Typeahead(this._inputEl, [], {
          filter: false,
          minLength: this.options.minLength,
          limit: this.options.limit,
          noInitialSelection: true
        });
        this.setRenderFunction(this.options.render);
        this._typeahead.getItemValue = this.options.getItemValue;
        this.mapMarker = null;
        this.resultMarkers = [];
        this._handleMarker = this._handleMarker.bind(this);
        this._handleResultMarkers = this._handleResultMarkers.bind(this);
        if (this._map) {
          if (this.options.trackProximity) {
            this._updateProximity();
            this._map.on("moveend", this._updateProximity);
          }
          this._maplibregl = this.options.maplibregl;
          if (!this._maplibregl && this.options.marker) {
            console.error(
              "No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."
            );
            this.options.marker = false;
          }
        }
        return el;
      },
      createIcon: function(name, path) {
        var icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        icon.setAttribute(
          "class",
          "mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-" + name + " maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + name
        );
        icon.setAttribute("viewBox", "0 0 18 18");
        icon.setAttribute("xml:space", "preserve");
        icon.setAttribute("width", 18);
        icon.setAttribute("height", 18);
        if (!("innerHTML" in icon)) {
          var SVGNodeContainer = document.createElement("div");
          SVGNodeContainer.innerHTML = "<svg>" + path.valueOf().toString() + "</svg>";
          var SVGNode = SVGNodeContainer.firstChild, SVGPath = SVGNode.firstChild;
          icon.appendChild(SVGPath);
        } else {
          icon.innerHTML = path;
        }
        return icon;
      },
      onRemove: function() {
        this.container.parentNode.removeChild(this.container);
        if (this.options.trackProximity && this._map) {
          this._map.off("moveend", this._updateProximity);
        }
        this._removeMarker();
        this._map = null;
        return this;
      },
      _onPaste: function(e2) {
        var value = (e2.clipboardData || window.clipboardData).getData("text");
        if (value.length >= this.options.minLength && this.options.showResultsWhileTyping) {
          this._geocode(value);
        }
      },
      _onKeyDown: function(e2) {
        var ESC_KEY_CODE = 27, TAB_KEY_CODE = 9;
        if (e2.keyCode === ESC_KEY_CODE && this.options.clearAndBlurOnEsc) {
          this._clear(e2);
          return this._inputEl.blur();
        }
        var target = e2.target && e2.target.shadowRoot ? e2.target.shadowRoot.activeElement : e2.target;
        var value = target ? target.value : "";
        if (!value) {
          this.fresh = true;
          if (e2.keyCode !== TAB_KEY_CODE)
            this.clear(e2);
          return this._clearEl.style.display = "none";
        }
        if (e2.metaKey || [TAB_KEY_CODE, ESC_KEY_CODE, 37, 39, 38, 40].indexOf(e2.keyCode) !== -1)
          return;
        if (e2.keyCode === 13) {
          if (!this.options.showResultsWhileTyping) {
            if (!this._typeahead.selected) {
              this._geocode(target.value);
            }
          } else {
            if (this._typeahead.selected == null && this.geocoderApi.getSuggestions) {
              this._geocode(target.value, true);
            } else if (this._typeahead.selected == null) {
              if (this.options.showResultMarkers) {
                this._fitBoundsForMarkers();
              }
            }
            return;
          }
        }
        if (target.value.length >= this.options.minLength && this.options.showResultsWhileTyping) {
          this._geocode(target.value);
        }
      },
      _showButton: function() {
        if (this._inputEl.value.length > 0)
          this._clearEl.style.display = "block";
      },
      _hideButton: function() {
        if (this._typeahead.selected)
          this._clearEl.style.display = "none";
      },
      _onBlur: function(e2) {
        if (this.options.clearOnBlur) {
          this._clearOnBlur(e2);
        }
        if (this.options.collapsed) {
          this._collapse();
        }
      },
      // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
      // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
      //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
      //  our onKeyDown handler.
      _onChange: function() {
        var selected = this._typeahead.selected;
        if (selected && !selected.geometry) {
          if (selected.placeId)
            this._geocode(selected.placeId, true, true);
          else
            this._geocode(selected.text, true);
        } else if (selected && JSON.stringify(selected) !== this.lastSelected) {
          this._clearEl.style.display = "none";
          if (this.options.flyTo) {
            var flyOptions;
            this._removeResultMarkers();
            if (selected.properties && exceptions[selected.properties.short_code]) {
              flyOptions = extend({}, this.options.flyTo);
              if (this._map) {
                this._map.fitBounds(
                  exceptions[selected.properties.short_code].bbox,
                  flyOptions
                );
              }
            } else if (selected.bbox) {
              var bbox = selected.bbox;
              flyOptions = extend({}, this.options.flyTo);
              if (this._map) {
                this._map.fitBounds(
                  [
                    [bbox[0], bbox[1]],
                    [bbox[2], bbox[3]]
                  ],
                  flyOptions
                );
              }
            } else {
              var defaultFlyOptions = {
                zoom: this.options.zoom
              };
              flyOptions = extend({}, defaultFlyOptions, this.options.flyTo);
              if (selected.center) {
                flyOptions.center = selected.center;
              } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
                flyOptions.center = selected.geometry.coordinates;
              }
              if (this._map) {
                this._map.flyTo(flyOptions);
              }
            }
          }
          if (this.options.marker && this._maplibregl) {
            this._handleMarker(selected);
          }
          this._inputEl.focus();
          this._inputEl.scrollLeft = 0;
          this._inputEl.setSelectionRange(0, 0);
          this.lastSelected = JSON.stringify(selected);
          this._typeahead.selected = null;
          this._eventEmitter.emit("result", { result: selected });
        }
      },
      _getConfigForRequest: function() {
        var keys = [
          "bbox",
          "limit",
          "proximity",
          "countries",
          "types",
          "language",
          "reverseMode"
        ];
        var self2 = this;
        var config = keys.reduce(function(config2, key) {
          if (self2.options[key]) {
            ["countries", "types", "language"].indexOf(key) > -1 ? config2[key] = self2.options[key].split(/[\s,]+/) : config2[key] = self2.options[key];
            if (key === "proximity" && self2.options[key] && typeof self2.options[key].longitude === "number" && typeof self2.options[key].latitude === "number") {
              config2[key] = [
                self2.options[key].longitude,
                self2.options[key].latitude
              ];
            }
          }
          return config2;
        }, {});
        return config;
      },
      _geocode: function(searchInput, isSuggestion, isPlaceId) {
        this._loadingEl.style.display = "block";
        this._eventEmitter.emit("loading", { query: searchInput });
        this.inputString = searchInput;
        var geocoderError = null;
        var config = this._getConfigForRequest();
        var request;
        if (this.options.localGeocoderOnly) {
          request = Promise.resolve();
        } else if (this.options.reverseGeocode && /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/.test(searchInput)) {
          var coords = searchInput.split(/[\s(,)?]+/).map(function(c) {
            return parseFloat(c, 10);
          }).reverse();
          config.types ? [config.types[0]] : ["poi"];
          config = extend(config, { query: coords, limit: 1 });
          if ("proximity" in config) {
            delete config.proximity;
          }
          request = this.geocoderApi.reverseGeocode(config);
        } else {
          config = extend(config, { query: searchInput });
          if (!this.geocoderApi.getSuggestions) {
            request = this.geocoderApi.forwardGeocode(config);
          } else {
            if (isSuggestion) {
              if (this.geocoderApi.searchByPlaceId && isPlaceId) {
                request = this.geocoderApi.searchByPlaceId(config);
              } else {
                request = this.geocoderApi.forwardGeocode(config);
              }
            } else {
              request = this.geocoderApi.getSuggestions(config);
            }
          }
        }
        var localGeocoderRes = [];
        if (this.options.localGeocoder) {
          localGeocoderRes = this.options.localGeocoder(searchInput);
          if (!localGeocoderRes) {
            localGeocoderRes = [];
          }
        }
        var externalGeocoderRes = [];
        request.catch(
          (function(error) {
            geocoderError = error;
          }).bind(this)
        ).then(
          (function(response) {
            this._loadingEl.style.display = "none";
            var res = {};
            if (!response) {
              res = {
                type: "FeatureCollection",
                features: []
              };
            } else {
              res = response;
            }
            res.config = config;
            if (this.fresh) {
              this.fresh = false;
            }
            res.features = res.features ? localGeocoderRes.concat(res.features) : localGeocoderRes;
            if (this.options.externalGeocoder) {
              externalGeocoderRes = this.options.externalGeocoder(
                searchInput,
                res.features,
                config
              ) || [];
              return externalGeocoderRes.then(
                function(features) {
                  res.features = res.features ? features.concat(res.features) : features;
                  return res;
                },
                function() {
                  return res;
                }
              );
            }
            return res;
          }).bind(this)
        ).then(
          (function(res) {
            if (geocoderError) {
              throw geocoderError;
            }
            if (this.options.filter && res.features.length) {
              res.features = res.features.filter(this.options.filter);
            }
            var results = [];
            if (res.suggestions) {
              results = res.suggestions;
            } else if (res.place) {
              results = [res.place];
            } else {
              results = res.features;
            }
            if (results.length) {
              this._clearEl.style.display = "block";
              this._typeahead.update(results);
              if ((!this.options.showResultsWhileTyping || isSuggestion) && this.options.showResultMarkers && (res.features.length > 0 || res.place)) {
                this._fitBoundsForMarkers();
              }
              this._eventEmitter.emit("results", res);
            } else {
              this._clearEl.style.display = "none";
              this._typeahead.selected = null;
              this._renderNoResults();
              this._eventEmitter.emit("results", res);
            }
          }).bind(this)
        ).catch(
          (function(err) {
            this._loadingEl.style.display = "none";
            if (localGeocoderRes.length && this.options.localGeocoder || externalGeocoderRes.length && this.options.externalGeocoder) {
              this._clearEl.style.display = "block";
              this._typeahead.update(localGeocoderRes);
            } else {
              this._clearEl.style.display = "none";
              this._typeahead.selected = null;
              this._renderError();
            }
            this._eventEmitter.emit("results", { features: localGeocoderRes });
            this._eventEmitter.emit("error", { error: err });
          }).bind(this)
        );
        return request;
      },
      /**
       * Shared logic for clearing input
       * @param {Event} [ev] the event that triggered the clear, if available
       * @private
       *
       */
      _clear: function(ev) {
        if (ev)
          ev.preventDefault();
        this._inputEl.value = "";
        this._typeahead.selected = null;
        this._typeahead.clear();
        this._onChange();
        this._clearEl.style.display = "none";
        this._removeMarker();
        this._removeResultMarkers();
        this.lastSelected = null;
        this._eventEmitter.emit("clear");
        this.fresh = true;
      },
      /**
       * Clear and then focus the input.
       * @param {Event} [ev] the event that triggered the clear, if available
       *
       */
      clear: function(ev) {
        this._clear(ev);
        this._inputEl.focus();
      },
      /**
       * Clear the input, without refocusing it. Used to implement clearOnBlur
       * constructor option.
       * @param {Event} [ev] the blur event
       * @private
       */
      _clearOnBlur: function(ev) {
        var ctx = this;
        if (ev.relatedTarget) {
          ctx._clear(ev);
        }
      },
      _onQueryResult: function(response) {
        var results = response;
        if (!results.features.length)
          return;
        var result = results.features[0];
        this._typeahead.selected = result;
        this._inputEl.value = result.place_name;
        this._onChange();
      },
      _updateProximity: function() {
        if (!this._map) {
          return;
        }
        if (this._map.getZoom() > 9) {
          var center = this._map.getCenter().wrap();
          this.setProximity({ longitude: center.lng, latitude: center.lat });
        } else {
          this.setProximity(null);
        }
      },
      _collapse: function() {
        if (!this._inputEl.value && this._inputEl !== document.activeElement)
          this.container.classList.add(
            "mapboxgl-ctrl-geocoder--collapsed",
            "maplibregl-ctrl-geocoder--collapsed"
          );
      },
      _unCollapse: function() {
        this.container.classList.remove(
          "mapboxgl-ctrl-geocoder--collapsed",
          "maplibregl-ctrl-geocoder--collapsed"
        );
      },
      /**
       * Set & query the input
       * @param {string} searchInput location name or other search input
       * @returns {MaplibreGeocoder} this
       */
      query: function(searchInput) {
        this._geocode(searchInput).then(this._onQueryResult);
        return this;
      },
      _renderError: function() {
        var errorMessage = "<div class='mapbox-gl-geocoder--error maplibre-gl-geocoder--error'>There was an error reaching the server</div>";
        this._renderMessage(errorMessage);
      },
      _renderNoResults: function() {
        var errorMessage = "<div class='mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>No results found</div>";
        this._renderMessage(errorMessage);
      },
      _renderMessage: function(msg) {
        this._typeahead.update([]);
        this._typeahead.selected = null;
        this._typeahead.clear();
        this._typeahead.renderError(msg);
      },
      /**
       * Get the text to use as the search bar placeholder
       *
       * If placeholder is provided in options, then use options.placeholder
       * Otherwise, if language is provided in options, then use the localized string of the first language if available
       * Otherwise use the default
       *
       * @returns {String} the value to use as the search bar placeholder
       * @private
       */
      _getPlaceholderText: function() {
        if (this.options.placeholder)
          return this.options.placeholder;
        if (this.options.language) {
          var firstLanguage = this.options.language.split(",")[0];
          var language = subtag.language(firstLanguage);
          var localizedValue = localization.placeholder[language];
          if (localizedValue)
            return localizedValue;
        }
        return "Search";
      },
      /**
       * Fits the map to the current bounds for the searched results
       *
       * @returns {MaplibreGeocoder} this
       * @private
       */
      _fitBoundsForMarkers: function() {
        if (this._typeahead.data.length < 1)
          return;
        var results = this._typeahead.data.filter(function(result) {
          return typeof result === "string" ? false : true;
        }).slice(0, this.options.limit);
        this._clearEl.style.display = "none";
        if (this.options.flyTo && this._maplibregl) {
          if (this._map) {
            var defaultFlyOptions = { padding: 100 };
            var flyOptions = extend({}, defaultFlyOptions, this.options.flyTo);
            var bounds = new this._maplibregl.LngLatBounds();
            results.forEach(function(feature2) {
              bounds.extend(feature2.geometry.coordinates);
            });
            this._map.fitBounds(bounds.toArray(), flyOptions);
          }
        }
        if (results.length > 0 && this._maplibregl) {
          this._handleResultMarkers(results);
        }
        return this;
      },
      /**
       * Set input
       * @param {string} searchInput location name or other search input
       * @returns {MaplibreGeocoder} this
       */
      setInput: function(searchInput) {
        this._inputEl.value = searchInput;
        this._typeahead.selected = null;
        this._typeahead.clear();
        if (searchInput.length >= this.options.minLength && this.options.showResultsWhileTyping) {
          this._geocode(searchInput);
        }
        return this;
      },
      /**
       * Set proximity
       * @param {Object} proximity The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
       * @returns {MaplibreGeocoder} this
       */
      setProximity: function(proximity) {
        this.options.proximity = proximity;
        return this;
      },
      /**
       * Get proximity
       * @returns {Object} The geocoder proximity
       */
      getProximity: function() {
        return this.options.proximity;
      },
      /**
       * Set the render function used in the results dropdown
       * @param {Function} fn The function to use as a render function. This function accepts a single [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) object as input and returns a string.
       * @returns {MaplibreGeocoder} this
       */
      setRenderFunction: function(fn) {
        if (fn && typeof fn == "function") {
          this._typeahead.render = fn;
        }
        return this;
      },
      /**
       * Get the function used to render the results dropdown
       *
       * @returns {Function} the render function
       */
      getRenderFunction: function() {
        return this._typeahead.render;
      },
      /**
       * Get the language to use in UI elements and when making search requests
       *
       * Look first at the explicitly set options otherwise use the browser's language settings
       * @param {String} language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
       * @returns {MaplibreGeocoder} this
       */
      setLanguage: function(language) {
        var browserLocale = navigator.language || navigator.userLanguage || navigator.browserLanguage;
        this.options.language = language || this.options.language || browserLocale;
        return this;
      },
      /**
       * Get the language to use in UI elements and when making search requests
       * @returns {String} The language(s) used by the plugin, if any
       */
      getLanguage: function() {
        return this.options.language;
      },
      /**
       * Get the zoom level the map will move to when there is no bounding box on the selected result
       * @returns {Number} the map zoom
       */
      getZoom: function() {
        return this.options.zoom;
      },
      /**
       * Set the zoom level
       * @param {Number} zoom The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
       * @returns {MaplibreGeocoder} this
       */
      setZoom: function(zoom) {
        this.options.zoom = zoom;
        return this;
      },
      /**
       * Get the parameters used to fly to the selected response, if any
       * @returns {Boolean|Object} The `flyTo` option
       */
      getFlyTo: function() {
        return this.options.flyTo;
      },
      /**
       * Set the flyTo options
       * @param {Boolean|Object} flyTo If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#fitbounds) method providing control over the animation of the transition.
       */
      setFlyTo: function(flyTo) {
        this.options.flyTo = flyTo;
        return this;
      },
      /**
       * Get the value of the placeholder string
       * @returns {String} The input element's placeholder value
       */
      getPlaceholder: function() {
        return this.options.placeholder;
      },
      /**
       * Set the value of the input element's placeholder
       * @param {String} placeholder the text to use as the input element's placeholder
       * @returns {MaplibreGeocoder} this
       */
      setPlaceholder: function(placeholder) {
        this.placeholder = placeholder ? placeholder : this._getPlaceholderText();
        this._inputEl.placeholder = this.placeholder;
        this._inputEl.setAttribute("aria-label", this.placeholder);
        return this;
      },
      /**
       * Get the bounding box used by the plugin
       * @returns {Array<Number>} the bounding box, if any
       */
      getBbox: function() {
        return this.options.bbox;
      },
      /**
       * Set the bounding box to limit search results to
       * @param {Array<Number>} bbox a bounding box given as an array in the format [minX, minY, maxX, maxY].
       * @returns {MaplibreGeocoder} this
       */
      setBbox: function(bbox) {
        this.options.bbox = bbox;
        return this;
      },
      /**
       * Get a list of the countries to limit search results to
       * @returns {String} a comma separated list of countries to limit to, if any
       */
      getCountries: function() {
        return this.options.countries;
      },
      /**
       * Set the countries to limit search results to
       * @param {String} countries a comma separated list of countries to limit to
       * @returns {MaplibreGeocoder} this
       */
      setCountries: function(countries) {
        this.options.countries = countries;
        return this;
      },
      /**
       * Get a list of the types to limit search results to
       * @returns {String} a comma separated list of types to limit to
       */
      getTypes: function() {
        return this.options.types;
      },
      /**
       * Set the types to limit search results to
       * @param {String} countries a comma separated list of types to limit to
       * @returns {MaplibreGeocoder} this
       */
      setTypes: function(types) {
        this.options.types = types;
        return this;
      },
      /**
       * Get the minimum number of characters typed to trigger results used in the plugin
       * @returns {Number} The minimum length in characters before a search is triggered
       */
      getMinLength: function() {
        return this.options.minLength;
      },
      /**
       * Set the minimum number of characters typed to trigger results used by the plugin
       * @param {Number} minLength the minimum length in characters
       * @returns {MaplibreGeocoder} this
       */
      setMinLength: function(minLength) {
        this.options.minLength = minLength;
        if (this._typeahead)
          this._typeahead.options.minLength = minLength;
        return this;
      },
      /**
       * Get the limit value for the number of results to display used by the plugin
       * @returns {Number} The limit value for the number of results to display used by the plugin
       */
      getLimit: function() {
        return this.options.limit;
      },
      /**
       * Set the limit value for the number of results to display used by the plugin
       * @param {Number} limit the number of search results to return
       * @returns {MaplibreGeocoder}
       */
      setLimit: function(limit) {
        this.options.limit = limit;
        if (this._typeahead)
          this._typeahead.options.limit = limit;
        return this;
      },
      /**
       * Get the filter function used by the plugin
       * @returns {Function} the filter function
       */
      getFilter: function() {
        return this.options.filter;
      },
      /**
       * Set the filter function used by the plugin.
       * @param {Function} filter A function which accepts a Feature in the [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
       * @returns {MaplibreGeocoder} this
       */
      setFilter: function(filter) {
        this.options.filter = filter;
        return this;
      },
      /**
       * Set the geocoding api used by the plugin.
       * @param {Object} geocoderApi An API which contains reverseGeocode and forwardGeocode functions to be used by this plugin
       * @param {Function} geocoderApi.forwardGeocode Forward geocode function should return an object including a collection of Features in [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format
       * @param {Object} geocoderApi.forwardGeocode.config Query parameters
       * @param {String} geocoderApi.forwardGeocode.config.query Search query string
       * @param {Number} geocoderApi.forwardGeocode.config.limit Number of results to limit by
       * @param {Array} geocoderApi.forwardGeocode.config.bbox a bounding box given as an array in the format `[minX, minY, maxX, maxY]`. Search results will be limited to the bounding box.
       * @param {Object} geocoderApi.forwardGeocode.config.proximity a geographical point given as an object with `latitude` and `longitude` properties. Search results closer to this point will be given higher priority.
       * @param {Array} geocoderApi.forwardGeocode.config.countries a comma separated list of country codes to limit results to specified country or countries.
       * @param {Array} geocoderApi.forwardGeocode.config.types a comma seperated list of types that filter results to match those specified. See https://docs.mapbox.com/api/search/#data-types for available types. If reverseGeocode is enabled, you should specify one type. If you configure more than one type, the first type will be used.
       * @param {String} geocoderApi.forwardGeocode.config.language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas. Defaults to the browser's language settings.
       * @param {distance|score} geocoderApi.forwardGeocode.config.reverseMode Set the factors that are used to sort nearby results.
       *
       * @param {Function} geocoderApi.reverseGeocode Reverse geocode function should return an object including a collection of Features in [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format
       * @param {Object} geocoderApi.reverseGeocode.config Query parameters
       * @param {Object} geocoderApi.reverseGeocode.config.query Search query coordinates
       * @param {Number} geocoderApi.reverseGeocode.config.limit Number of results to limit by
       * @param {Array} geocoderApi.reverseGeocode.config.bbox a bounding box given as an array in the format `[minX, minY, maxX, maxY]`. Search results will be limited to the bounding box.
       * @param {Object} geocoderApi.reverseGeocode.config.proximity a geographical point given as an object with `latitude` and `longitude` properties. Search results closer to this point will be given higher priority.
       * @param {Array} geocoderApi.reverseGeocode.config.countries a comma separated list of country codes to limit results to specified country or countries.
       * @param {Array} geocoderApi.reverseGeocode.config.types a comma seperated list of types that filter results to match those specified. See https://docs.mapbox.com/api/search/#data-types for available types. If reverseGeocode is enabled, you should specify one type. If you configure more than one type, the first type will be used.
       * @param {String} geocoderApi.reverseGeocode.config.language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas. Defaults to the browser's language settings.
       * @param {distance|score} geocoderApi.reverseGeocode.config.reverseMode Set the factors that are used to sort nearby results.
       * @returns {MaplibreGeocoder} this
       */
      setGeocoderApi: function(geocoderApi) {
        this.geocoderApi = geocoderApi;
        return this;
      },
      /**
       * Get the geocoding endpoint the plugin is currently set to
       * @returns {Object} the geocoding API
       */
      getGeocoderApi: function() {
        return this.geocoderApi;
      },
      /**
       * Handle the placement of a result marking the selected result
       * @private
       * @param {Object} selected the selected geojson feature
       * @returns {MaplibreGeocoder} this
       */
      _handleMarker: function(selected) {
        if (!this._map) {
          return;
        }
        this._removeMarker();
        var defaultMarkerOptions = {
          color: "#4668F2"
        };
        var markerOptions = extend({}, defaultMarkerOptions, this.options.marker);
        this.mapMarker = new this._maplibregl.Marker(markerOptions);
        var popup;
        if (this.options.popup) {
          var defaultPopupOptions = {};
          var popupOptions = extend({}, defaultPopupOptions, this.options.popup);
          popup = new this._maplibregl.Popup(popupOptions).setHTML(
            this.options.popupRender(selected)
          );
        }
        if (selected.center) {
          this.mapMarker.setLngLat(selected.center).addTo(this._map);
          if (this.options.popup)
            this.mapMarker.setPopup(popup);
        } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
          this.mapMarker.setLngLat(selected.geometry.coordinates).addTo(this._map);
          if (this.options.popup)
            this.mapMarker.setPopup(popup);
        }
        return this;
      },
      /**
       * Handle the removal of a result marker
       * @private
       */
      _removeMarker: function() {
        if (this.mapMarker) {
          this.mapMarker.remove();
          this.mapMarker = null;
        }
      },
      /**
       * Handle the placement of a result marking the selected result
       * @private
       * @param {Object[]} results the top results to display on the map
       * @returns {MaplibreGeocoder} this
       */
      _handleResultMarkers: function(results) {
        if (!this._map) {
          return;
        }
        this._removeResultMarkers();
        var defaultMarkerOptions = {
          color: "#4668F2"
        };
        var markerOptions = extend(
          {},
          defaultMarkerOptions,
          this.options.showResultMarkers
        );
        results.forEach(
          (function(result) {
            if (this.options.showResultMarkers && this.options.showResultMarkers.element) {
              var el = this.options.showResultMarkers.element.cloneNode(true);
              markerOptions = extend(markerOptions, { element: el });
            }
            var marker = new this._maplibregl.Marker(
              extend({}, markerOptions, { element: el })
            );
            var popup;
            if (this.options.popup) {
              var defaultPopupOptions = {};
              var popupOptions = extend(
                {},
                defaultPopupOptions,
                this.options.popup
              );
              popup = new this._maplibregl.Popup(popupOptions).setHTML(
                this.options.popupRender(result)
              );
            }
            if (result.center) {
              marker.setLngLat(result.center).addTo(this._map);
              if (this.options.popup)
                marker.setPopup(popup);
            } else if (result.geometry && result.geometry.type && result.geometry.type === "Point" && result.geometry.coordinates) {
              marker.setLngLat(result.geometry.coordinates).addTo(this._map);
              if (this.options.popup)
                marker.setPopup(popup);
            }
            this.resultMarkers.push(marker);
          }).bind(this)
        );
        return this;
      },
      /**
       * Handle the removal of a result marker
       * @private
       */
      _removeResultMarkers: function() {
        if (this.resultMarkers && this.resultMarkers.length > 0) {
          this.resultMarkers.forEach(function(marker) {
            marker.remove();
          });
          this.resultMarkers = [];
        }
      },
      /**
       * Subscribe to events that happen within the plugin.
       * @param {String} type name of event. Available events and the data passed into their respective event objects are:
       *
       * - __clear__ `Emitted when the input is cleared`
       * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
       * - __results__ `{ results } Fired when the geocoder returns a response`
       * - __result__ `{ result } Fired when input is set`
       * - __error__ `{ error } Error as string`
       * @param {Function} fn function that's called when the event is emitted.
       * @returns {MaplibreGeocoder} this;
       */
      on: function(type, fn) {
        this._eventEmitter.on(type, fn);
        return this;
      },
      /**
       * Remove an event
       * @returns {MaplibreGeocoder} this
       * @param {String} type Event name.
       * @param {Function} fn Function that should unsubscribe to the event emitted.
       */
      off: function(type, fn) {
        this._eventEmitter.removeListener(type, fn);
        return this;
      }
    };
    module.exports = MaplibreGeocoder2;
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports, module) {
    function debounce2(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (null == wait)
        wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce2.debounce = debounce2;
    module.exports = debounce2;
  }
});

// node_modules/maplibre-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.js
var require_mapbox_gl_draw2 = __commonJS({
  "node_modules/maplibre-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.js"(exports, module) {
    !function(t, e2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t = t || self).MapboxDraw = e2();
    }(exports, function() {
      "use strict";
      var t = function(t2, e3) {
        var n2 = { drag: [], click: [], mousemove: [], mousedown: [], mouseup: [], mouseout: [], keydown: [], keyup: [], touchstart: [], touchmove: [], touchend: [], tap: [] }, o2 = { on: function(t3, e4, o3) {
          if (void 0 === n2[t3])
            throw new Error("Invalid event type: " + t3);
          n2[t3].push({ selector: e4, fn: o3 });
        }, render: function(t3) {
          e3.store.featureChanged(t3);
        } }, r2 = function(t3, r3) {
          for (var i2 = n2[t3], a2 = i2.length; a2--; ) {
            var s2 = i2[a2];
            if (s2.selector(r3)) {
              s2.fn.call(o2, r3) || e3.store.render(), e3.ui.updateMapClasses();
              break;
            }
          }
        };
        return t2.start.call(o2), { render: t2.render, stop: function() {
          t2.stop && t2.stop();
        }, trash: function() {
          t2.trash && (t2.trash(), e3.store.render());
        }, combineFeatures: function() {
          t2.combineFeatures && t2.combineFeatures();
        }, uncombineFeatures: function() {
          t2.uncombineFeatures && t2.uncombineFeatures();
        }, drag: function(t3) {
          r2("drag", t3);
        }, click: function(t3) {
          r2("click", t3);
        }, mousemove: function(t3) {
          r2("mousemove", t3);
        }, mousedown: function(t3) {
          r2("mousedown", t3);
        }, mouseup: function(t3) {
          r2("mouseup", t3);
        }, mouseout: function(t3) {
          r2("mouseout", t3);
        }, keydown: function(t3) {
          r2("keydown", t3);
        }, keyup: function(t3) {
          r2("keyup", t3);
        }, touchstart: function(t3) {
          r2("touchstart", t3);
        }, touchmove: function(t3) {
          r2("touchmove", t3);
        }, touchend: function(t3) {
          r2("touchend", t3);
        }, tap: function(t3) {
          r2("tap", t3);
        } };
      }, e2 = 6378137;
      function n(t2) {
        var e3 = 0;
        if (t2 && t2.length > 0) {
          e3 += Math.abs(o(t2[0]));
          for (var n2 = 1; n2 < t2.length; n2++)
            e3 -= Math.abs(o(t2[n2]));
        }
        return e3;
      }
      function o(t2) {
        var n2, o2, i2, a2, s2, u2, c2 = 0, l2 = t2.length;
        if (l2 > 2) {
          for (u2 = 0; u2 < l2; u2++)
            u2 === l2 - 2 ? (i2 = l2 - 2, a2 = l2 - 1, s2 = 0) : u2 === l2 - 1 ? (i2 = l2 - 1, a2 = 0, s2 = 1) : (i2 = u2, a2 = u2 + 1, s2 = u2 + 2), n2 = t2[i2], o2 = t2[a2], c2 += (r(t2[s2][0]) - r(n2[0])) * Math.sin(r(o2[1]));
          c2 = c2 * e2 * e2 / 2;
        }
        return c2;
      }
      function r(t2) {
        return t2 * Math.PI / 180;
      }
      var i = { geometry: function t2(e3) {
        var o2, r2 = 0;
        switch (e3.type) {
          case "Polygon":
            return n(e3.coordinates);
          case "MultiPolygon":
            for (o2 = 0; o2 < e3.coordinates.length; o2++)
              r2 += n(e3.coordinates[o2]);
            return r2;
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
            return 0;
          case "GeometryCollection":
            for (o2 = 0; o2 < e3.geometries.length; o2++)
              r2 += t2(e3.geometries[o2]);
            return r2;
        }
      }, ring: o }, a = "mapboxgl-ctrl", s = "mapbox-gl-draw_ctrl-draw-btn", u = "mapbox-gl-draw_line", c = "mapbox-gl-draw_polygon", l = "mapbox-gl-draw_point", d = "mapbox-gl-draw_trash", p = "mapbox-gl-draw_combine", f = "mapbox-gl-draw_uncombine", h = "mapboxgl-ctrl-group", g = "active", y = "mapbox-gl-draw_boxselect", v = "mapbox-gl-draw-hot", m = "mapbox-gl-draw-cold", b = "add", _ = "move", S = "drag", x = "pointer", C = "none", E = { POLYGON: "polygon", LINE: "line_string", POINT: "point" }, M = "Feature", w = "Polygon", I = "LineString", L = "Point", P = "FeatureCollection", F = "Multi", O = "MultiPoint", k = "MultiLineString", T = "MultiPolygon", j = { DRAW_LINE_STRING: "draw_line_string", DRAW_POLYGON: "draw_polygon", DRAW_POINT: "draw_point", SIMPLE_SELECT: "simple_select", DIRECT_SELECT: "direct_select", STATIC: "static" }, A = "draw.create", D = "draw.delete", N = "draw.update", U = "draw.selectionchange", R = "draw.modechange", B = "draw.actionable", V = "draw.render", J = "draw.combine", G = "draw.uncombine", z = "move", $ = "change_coordinates", W = "feature", q = "midpoint", Y = "vertex", Z = "true", K = "false", X = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"], H = { Point: 0, LineString: 1, Polygon: 2 };
      function Q(t2, e3) {
        var n2 = H[t2.geometry.type] - H[e3.geometry.type];
        return 0 === n2 && t2.geometry.type === w ? t2.area - e3.area : n2;
      }
      function tt(t2) {
        if (this._items = {}, this._nums = {}, this._length = t2 ? t2.length : 0, t2)
          for (var e3 = 0, n2 = t2.length; e3 < n2; e3++)
            this.add(t2[e3]), void 0 !== t2[e3] && ("string" == typeof t2[e3] ? this._items[t2[e3]] = e3 : this._nums[t2[e3]] = e3);
      }
      tt.prototype.add = function(t2) {
        return this.has(t2) || (this._length++, "string" == typeof t2 ? this._items[t2] = this._length : this._nums[t2] = this._length), this;
      }, tt.prototype.delete = function(t2) {
        return false === this.has(t2) || (this._length--, delete this._items[t2], delete this._nums[t2]), this;
      }, tt.prototype.has = function(t2) {
        return ("string" == typeof t2 || "number" == typeof t2) && (void 0 !== this._items[t2] || void 0 !== this._nums[t2]);
      }, tt.prototype.values = function() {
        var t2 = this, e3 = [];
        return Object.keys(this._items).forEach(function(n2) {
          e3.push({ k: n2, v: t2._items[n2] });
        }), Object.keys(this._nums).forEach(function(n2) {
          e3.push({ k: JSON.parse(n2), v: t2._nums[n2] });
        }), e3.sort(function(t3, e4) {
          return t3.v - e4.v;
        }).map(function(t3) {
          return t3.k;
        });
      }, tt.prototype.clear = function() {
        return this._length = 0, this._items = {}, this._nums = {}, this;
      };
      var et = [W, q, Y], nt = { click: function(t2, e3, n2) {
        return ot(t2, e3, n2, n2.options.clickBuffer);
      }, touch: function(t2, e3, n2) {
        return ot(t2, e3, n2, n2.options.touchBuffer);
      } };
      function ot(t2, e3, n2, o2) {
        if (null === n2.map)
          return [];
        var r2 = t2 ? function(t3, e4) {
          return void 0 === e4 && (e4 = 0), [[t3.point.x - e4, t3.point.y - e4], [t3.point.x + e4, t3.point.y + e4]];
        }(t2, o2) : e3, a2 = {};
        n2.options.styles && (a2.layers = n2.options.styles.map(function(t3) {
          return t3.id;
        }));
        var s2 = n2.map.queryRenderedFeatures(r2, a2).filter(function(t3) {
          return -1 !== et.indexOf(t3.properties.meta);
        }), u2 = new tt(), c2 = [];
        return s2.forEach(function(t3) {
          var e4 = t3.properties.id;
          u2.has(e4) || (u2.add(e4), c2.push(t3));
        }), function(t3) {
          return t3.map(function(t4) {
            return t4.geometry.type === w && (t4.area = i.geometry({ type: M, property: {}, geometry: t4.geometry })), t4;
          }).sort(Q).map(function(t4) {
            return delete t4.area, t4;
          });
        }(c2);
      }
      function rt(t2, e3) {
        var n2 = nt.click(t2, null, e3), o2 = { mouse: C };
        return n2[0] && (o2.mouse = n2[0].properties.active === Z ? _ : x, o2.feature = n2[0].properties.meta), -1 !== e3.events.currentModeName().indexOf("draw") && (o2.mouse = b), e3.ui.queueMapClasses(o2), e3.ui.updateMapClasses(), n2[0];
      }
      function it(t2, e3) {
        var n2 = t2.x - e3.x, o2 = t2.y - e3.y;
        return Math.sqrt(n2 * n2 + o2 * o2);
      }
      function at(t2, e3, n2) {
        void 0 === n2 && (n2 = {});
        var o2 = null != n2.fineTolerance ? n2.fineTolerance : 4, r2 = null != n2.grossTolerance ? n2.grossTolerance : 12, i2 = null != n2.interval ? n2.interval : 500;
        t2.point = t2.point || e3.point, t2.time = t2.time || e3.time;
        var a2 = it(t2.point, e3.point);
        return a2 < o2 || a2 < r2 && e3.time - t2.time < i2;
      }
      function st(t2, e3, n2) {
        void 0 === n2 && (n2 = {});
        var o2 = null != n2.tolerance ? n2.tolerance : 25, r2 = null != n2.interval ? n2.interval : 250;
        return t2.point = t2.point || e3.point, t2.time = t2.time || e3.time, it(t2.point, e3.point) < o2 && e3.time - t2.time < r2;
      }
      function ut(t2, e3) {
        return t2(e3 = { exports: {} }, e3.exports), e3.exports;
      }
      var ct = ut(function(t2) {
        var e3 = t2.exports = function(t3, n2) {
          if (n2 || (n2 = 16), void 0 === t3 && (t3 = 128), t3 <= 0)
            return "0";
          for (var o2 = Math.log(Math.pow(2, t3)) / Math.log(n2), r2 = 2; o2 === 1 / 0; r2 *= 2)
            o2 = Math.log(Math.pow(2, t3 / r2)) / Math.log(n2) * r2;
          var i2 = o2 - Math.floor(o2), a2 = "";
          for (r2 = 0; r2 < Math.floor(o2); r2++) {
            a2 = Math.floor(Math.random() * n2).toString(n2) + a2;
          }
          if (i2) {
            var s2 = Math.pow(n2, i2);
            a2 = Math.floor(Math.random() * s2).toString(n2) + a2;
          }
          var u2 = parseInt(a2, n2);
          return u2 !== 1 / 0 && u2 >= Math.pow(2, t3) ? e3(t3, n2) : a2;
        };
        e3.rack = function(t3, n2, o2) {
          var r2 = function(r3) {
            var a2 = 0;
            do {
              if (a2++ > 10) {
                if (!o2)
                  throw new Error("too many ID collisions, use more bits");
                t3 += o2;
              }
              var s2 = e3(t3, n2);
            } while (Object.hasOwnProperty.call(i2, s2));
            return i2[s2] = r3, s2;
          }, i2 = r2.hats = {};
          return r2.get = function(t4) {
            return r2.hats[t4];
          }, r2.set = function(t4, e4) {
            return r2.hats[t4] = e4, r2;
          }, r2.bits = t3 || 128, r2.base = n2 || 16, r2;
        };
      }), lt = function(t2, e3) {
        this.ctx = t2, this.properties = e3.properties || {}, this.coordinates = e3.geometry.coordinates, this.id = e3.id || ct(), this.type = e3.geometry.type;
      };
      lt.prototype.changed = function() {
        this.ctx.store.featureChanged(this.id);
      }, lt.prototype.incomingCoords = function(t2) {
        this.setCoordinates(t2);
      }, lt.prototype.setCoordinates = function(t2) {
        this.coordinates = t2, this.changed();
      }, lt.prototype.getCoordinates = function() {
        return JSON.parse(JSON.stringify(this.coordinates));
      }, lt.prototype.setProperty = function(t2, e3) {
        this.properties[t2] = e3;
      }, lt.prototype.toGeoJSON = function() {
        return JSON.parse(JSON.stringify({ id: this.id, type: M, properties: this.properties, geometry: { coordinates: this.getCoordinates(), type: this.type } }));
      }, lt.prototype.internal = function(t2) {
        var e3 = { id: this.id, meta: W, "meta:type": this.type, active: K, mode: t2 };
        if (this.ctx.options.userProperties)
          for (var n2 in this.properties)
            e3["user_" + n2] = this.properties[n2];
        return { type: M, properties: e3, geometry: { coordinates: this.getCoordinates(), type: this.type } };
      };
      var dt = function(t2, e3) {
        lt.call(this, t2, e3);
      };
      (dt.prototype = Object.create(lt.prototype)).isValid = function() {
        return "number" == typeof this.coordinates[0] && "number" == typeof this.coordinates[1];
      }, dt.prototype.updateCoordinate = function(t2, e3, n2) {
        this.coordinates = 3 === arguments.length ? [e3, n2] : [t2, e3], this.changed();
      }, dt.prototype.getCoordinate = function() {
        return this.getCoordinates();
      };
      var pt = function(t2, e3) {
        lt.call(this, t2, e3);
      };
      (pt.prototype = Object.create(lt.prototype)).isValid = function() {
        return this.coordinates.length > 1;
      }, pt.prototype.addCoordinate = function(t2, e3, n2) {
        this.changed();
        var o2 = parseInt(t2, 10);
        this.coordinates.splice(o2, 0, [e3, n2]);
      }, pt.prototype.getCoordinate = function(t2) {
        var e3 = parseInt(t2, 10);
        return JSON.parse(JSON.stringify(this.coordinates[e3]));
      }, pt.prototype.removeCoordinate = function(t2) {
        this.changed(), this.coordinates.splice(parseInt(t2, 10), 1);
      }, pt.prototype.updateCoordinate = function(t2, e3, n2) {
        var o2 = parseInt(t2, 10);
        this.coordinates[o2] = [e3, n2], this.changed();
      };
      var ft = function(t2, e3) {
        lt.call(this, t2, e3), this.coordinates = this.coordinates.map(function(t3) {
          return t3.slice(0, -1);
        });
      };
      (ft.prototype = Object.create(lt.prototype)).isValid = function() {
        return 0 !== this.coordinates.length && this.coordinates.every(function(t2) {
          return t2.length > 2;
        });
      }, ft.prototype.incomingCoords = function(t2) {
        this.coordinates = t2.map(function(t3) {
          return t3.slice(0, -1);
        }), this.changed();
      }, ft.prototype.setCoordinates = function(t2) {
        this.coordinates = t2, this.changed();
      }, ft.prototype.addCoordinate = function(t2, e3, n2) {
        this.changed();
        var o2 = t2.split(".").map(function(t3) {
          return parseInt(t3, 10);
        });
        this.coordinates[o2[0]].splice(o2[1], 0, [e3, n2]);
      }, ft.prototype.removeCoordinate = function(t2) {
        this.changed();
        var e3 = t2.split(".").map(function(t3) {
          return parseInt(t3, 10);
        }), n2 = this.coordinates[e3[0]];
        n2 && (n2.splice(e3[1], 1), n2.length < 3 && this.coordinates.splice(e3[0], 1));
      }, ft.prototype.getCoordinate = function(t2) {
        var e3 = t2.split(".").map(function(t3) {
          return parseInt(t3, 10);
        }), n2 = this.coordinates[e3[0]];
        return JSON.parse(JSON.stringify(n2[e3[1]]));
      }, ft.prototype.getCoordinates = function() {
        return this.coordinates.map(function(t2) {
          return t2.concat([t2[0]]);
        });
      }, ft.prototype.updateCoordinate = function(t2, e3, n2) {
        this.changed();
        var o2 = t2.split("."), r2 = parseInt(o2[0], 10), i2 = parseInt(o2[1], 10);
        void 0 === this.coordinates[r2] && (this.coordinates[r2] = []), this.coordinates[r2][i2] = [e3, n2];
      };
      var ht = { MultiPoint: dt, MultiLineString: pt, MultiPolygon: ft }, gt = function(t2, e3, n2, o2, r2) {
        var i2 = n2.split("."), a2 = parseInt(i2[0], 10), s2 = i2[1] ? i2.slice(1).join(".") : null;
        return t2[a2][e3](s2, o2, r2);
      }, yt = function(t2, e3) {
        if (lt.call(this, t2, e3), delete this.coordinates, this.model = ht[e3.geometry.type], void 0 === this.model)
          throw new TypeError(e3.geometry.type + " is not a valid type");
        this.features = this._coordinatesToFeatures(e3.geometry.coordinates);
      };
      function vt(t2) {
        this.map = t2.map, this.drawConfig = JSON.parse(JSON.stringify(t2.options || {})), this._ctx = t2;
      }
      (yt.prototype = Object.create(lt.prototype))._coordinatesToFeatures = function(t2) {
        var e3 = this, n2 = this.model.bind(this);
        return t2.map(function(t3) {
          return new n2(e3.ctx, { id: ct(), type: M, properties: {}, geometry: { coordinates: t3, type: e3.type.replace("Multi", "") } });
        });
      }, yt.prototype.isValid = function() {
        return this.features.every(function(t2) {
          return t2.isValid();
        });
      }, yt.prototype.setCoordinates = function(t2) {
        this.features = this._coordinatesToFeatures(t2), this.changed();
      }, yt.prototype.getCoordinate = function(t2) {
        return gt(this.features, "getCoordinate", t2);
      }, yt.prototype.getCoordinates = function() {
        return JSON.parse(JSON.stringify(this.features.map(function(t2) {
          return t2.type === w ? t2.getCoordinates() : t2.coordinates;
        })));
      }, yt.prototype.updateCoordinate = function(t2, e3, n2) {
        gt(this.features, "updateCoordinate", t2, e3, n2), this.changed();
      }, yt.prototype.addCoordinate = function(t2, e3, n2) {
        gt(this.features, "addCoordinate", t2, e3, n2), this.changed();
      }, yt.prototype.removeCoordinate = function(t2) {
        gt(this.features, "removeCoordinate", t2), this.changed();
      }, yt.prototype.getFeatures = function() {
        return this.features;
      }, vt.prototype.setSelected = function(t2) {
        return this._ctx.store.setSelected(t2);
      }, vt.prototype.setSelectedCoordinates = function(t2) {
        var e3 = this;
        this._ctx.store.setSelectedCoordinates(t2), t2.reduce(function(t3, n2) {
          return void 0 === t3[n2.feature_id] && (t3[n2.feature_id] = true, e3._ctx.store.get(n2.feature_id).changed()), t3;
        }, {});
      }, vt.prototype.getSelected = function() {
        return this._ctx.store.getSelected();
      }, vt.prototype.getSelectedIds = function() {
        return this._ctx.store.getSelectedIds();
      }, vt.prototype.isSelected = function(t2) {
        return this._ctx.store.isSelected(t2);
      }, vt.prototype.getFeature = function(t2) {
        return this._ctx.store.get(t2);
      }, vt.prototype.select = function(t2) {
        return this._ctx.store.select(t2);
      }, vt.prototype.deselect = function(t2) {
        return this._ctx.store.deselect(t2);
      }, vt.prototype.deleteFeature = function(t2, e3) {
        return void 0 === e3 && (e3 = {}), this._ctx.store.delete(t2, e3);
      }, vt.prototype.addFeature = function(t2) {
        return this._ctx.store.add(t2);
      }, vt.prototype.clearSelectedFeatures = function() {
        return this._ctx.store.clearSelected();
      }, vt.prototype.clearSelectedCoordinates = function() {
        return this._ctx.store.clearSelectedCoordinates();
      }, vt.prototype.setActionableState = function(t2) {
        void 0 === t2 && (t2 = {});
        var e3 = { trash: t2.trash || false, combineFeatures: t2.combineFeatures || false, uncombineFeatures: t2.uncombineFeatures || false };
        return this._ctx.events.actionable(e3);
      }, vt.prototype.changeMode = function(t2, e3, n2) {
        return void 0 === e3 && (e3 = {}), void 0 === n2 && (n2 = {}), this._ctx.events.changeMode(t2, e3, n2);
      }, vt.prototype.updateUIClasses = function(t2) {
        return this._ctx.ui.queueMapClasses(t2);
      }, vt.prototype.activateUIButton = function(t2) {
        return this._ctx.ui.setActiveButton(t2);
      }, vt.prototype.featuresAt = function(t2, e3, n2) {
        if (void 0 === n2 && (n2 = "click"), "click" !== n2 && "touch" !== n2)
          throw new Error("invalid buffer type");
        return nt[n2](t2, e3, this._ctx);
      }, vt.prototype.newFeature = function(t2) {
        var e3 = t2.geometry.type;
        return e3 === L ? new dt(this._ctx, t2) : e3 === I ? new pt(this._ctx, t2) : e3 === w ? new ft(this._ctx, t2) : new yt(this._ctx, t2);
      }, vt.prototype.isInstanceOf = function(t2, e3) {
        if (t2 === L)
          return e3 instanceof dt;
        if (t2 === I)
          return e3 instanceof pt;
        if (t2 === w)
          return e3 instanceof ft;
        if ("MultiFeature" === t2)
          return e3 instanceof yt;
        throw new Error("Unknown feature class: " + t2);
      }, vt.prototype.doRender = function(t2) {
        return this._ctx.store.featureChanged(t2);
      }, vt.prototype.onSetup = function() {
      }, vt.prototype.onDrag = function() {
      }, vt.prototype.onClick = function() {
      }, vt.prototype.onMouseMove = function() {
      }, vt.prototype.onMouseDown = function() {
      }, vt.prototype.onMouseUp = function() {
      }, vt.prototype.onMouseOut = function() {
      }, vt.prototype.onKeyUp = function() {
      }, vt.prototype.onKeyDown = function() {
      }, vt.prototype.onTouchStart = function() {
      }, vt.prototype.onTouchMove = function() {
      }, vt.prototype.onTouchEnd = function() {
      }, vt.prototype.onTap = function() {
      }, vt.prototype.onStop = function() {
      }, vt.prototype.onTrash = function() {
      }, vt.prototype.onCombineFeature = function() {
      }, vt.prototype.onUncombineFeature = function() {
      }, vt.prototype.toDisplayFeatures = function() {
        throw new Error("You must overwrite toDisplayFeatures");
      };
      var mt = { drag: "onDrag", click: "onClick", mousemove: "onMouseMove", mousedown: "onMouseDown", mouseup: "onMouseUp", mouseout: "onMouseOut", keyup: "onKeyUp", keydown: "onKeyDown", touchstart: "onTouchStart", touchmove: "onTouchMove", touchend: "onTouchEnd", tap: "onTap" }, bt = Object.keys(mt);
      function _t(t2) {
        var e3 = Object.keys(t2);
        return function(n2, o2) {
          void 0 === o2 && (o2 = {});
          var r2 = {}, i2 = e3.reduce(function(e4, n3) {
            return e4[n3] = t2[n3], e4;
          }, new vt(n2));
          return { start: function() {
            var e4 = this;
            r2 = i2.onSetup(o2), bt.forEach(function(n3) {
              var o3, a2 = mt[n3], s2 = function() {
                return false;
              };
              t2[a2] && (s2 = function() {
                return true;
              }), e4.on(n3, s2, (o3 = a2, function(t3) {
                return i2[o3](r2, t3);
              }));
            });
          }, stop: function() {
            i2.onStop(r2);
          }, trash: function() {
            i2.onTrash(r2);
          }, combineFeatures: function() {
            i2.onCombineFeatures(r2);
          }, uncombineFeatures: function() {
            i2.onUncombineFeatures(r2);
          }, render: function(t3, e4) {
            i2.toDisplayFeatures(r2, t3, e4);
          } };
        };
      }
      function St(t2) {
        return [].concat(t2).filter(function(t3) {
          return void 0 !== t3;
        });
      }
      function xt() {
        var t2 = this;
        if (!(t2.ctx.map && void 0 !== t2.ctx.map.getSource(v)))
          return u2();
        var e3 = t2.ctx.events.currentModeName();
        t2.ctx.ui.queueMapClasses({ mode: e3 });
        var n2 = [], o2 = [];
        t2.isDirty ? o2 = t2.getAllIds() : (n2 = t2.getChangedIds().filter(function(e4) {
          return void 0 !== t2.get(e4);
        }), o2 = t2.sources.hot.filter(function(e4) {
          return e4.properties.id && -1 === n2.indexOf(e4.properties.id) && void 0 !== t2.get(e4.properties.id);
        }).map(function(t3) {
          return t3.properties.id;
        })), t2.sources.hot = [];
        var r2 = t2.sources.cold.length;
        t2.sources.cold = t2.isDirty ? [] : t2.sources.cold.filter(function(t3) {
          var e4 = t3.properties.id || t3.properties.parent;
          return -1 === n2.indexOf(e4);
        });
        var i2 = r2 !== t2.sources.cold.length || o2.length > 0;
        function a2(n3, o3) {
          var r3 = t2.get(n3).internal(e3);
          t2.ctx.events.currentModeRender(r3, function(e4) {
            t2.sources[o3].push(e4);
          });
        }
        if (n2.forEach(function(t3) {
          return a2(t3, "hot");
        }), o2.forEach(function(t3) {
          return a2(t3, "cold");
        }), i2 && t2.ctx.map.getSource(m).setData({ type: P, features: t2.sources.cold }), t2.ctx.map.getSource(v).setData({ type: P, features: t2.sources.hot }), t2._emitSelectionChange && (t2.ctx.map.fire(U, { features: t2.getSelected().map(function(t3) {
          return t3.toGeoJSON();
        }), points: t2.getSelectedCoordinates().map(function(t3) {
          return { type: M, properties: {}, geometry: { type: L, coordinates: t3.coordinates } };
        }) }), t2._emitSelectionChange = false), t2._deletedFeaturesToEmit.length) {
          var s2 = t2._deletedFeaturesToEmit.map(function(t3) {
            return t3.toGeoJSON();
          });
          t2._deletedFeaturesToEmit = [], t2.ctx.map.fire(D, { features: s2 });
        }
        function u2() {
          t2.isDirty = false, t2.clearChangedIds();
        }
        u2(), t2.ctx.map.fire(V, {});
      }
      function Ct(t2) {
        var e3, n2 = this;
        this._features = {}, this._featureIds = new tt(), this._selectedFeatureIds = new tt(), this._selectedCoordinates = [], this._changedFeatureIds = new tt(), this._deletedFeaturesToEmit = [], this._emitSelectionChange = false, this._mapInitialConfig = {}, this.ctx = t2, this.sources = { hot: [], cold: [] }, this.render = function() {
          e3 || (e3 = requestAnimationFrame(function() {
            e3 = null, xt.call(n2);
          }));
        }, this.isDirty = false;
      }
      function Et(t2, e3) {
        var n2 = t2._selectedCoordinates.filter(function(e4) {
          return t2._selectedFeatureIds.has(e4.feature_id);
        });
        t2._selectedCoordinates.length === n2.length || e3.silent || (t2._emitSelectionChange = true), t2._selectedCoordinates = n2;
      }
      Ct.prototype.createRenderBatch = function() {
        var t2 = this, e3 = this.render, n2 = 0;
        return this.render = function() {
          n2++;
        }, function() {
          t2.render = e3, n2 > 0 && t2.render();
        };
      }, Ct.prototype.setDirty = function() {
        return this.isDirty = true, this;
      }, Ct.prototype.featureChanged = function(t2) {
        return this._changedFeatureIds.add(t2), this;
      }, Ct.prototype.getChangedIds = function() {
        return this._changedFeatureIds.values();
      }, Ct.prototype.clearChangedIds = function() {
        return this._changedFeatureIds.clear(), this;
      }, Ct.prototype.getAllIds = function() {
        return this._featureIds.values();
      }, Ct.prototype.add = function(t2) {
        return this.featureChanged(t2.id), this._features[t2.id] = t2, this._featureIds.add(t2.id), this;
      }, Ct.prototype.delete = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), St(t2).forEach(function(t3) {
          n2._featureIds.has(t3) && (n2._featureIds.delete(t3), n2._selectedFeatureIds.delete(t3), e3.silent || -1 === n2._deletedFeaturesToEmit.indexOf(n2._features[t3]) && n2._deletedFeaturesToEmit.push(n2._features[t3]), delete n2._features[t3], n2.isDirty = true);
        }), Et(this, e3), this;
      }, Ct.prototype.get = function(t2) {
        return this._features[t2];
      }, Ct.prototype.getAll = function() {
        var t2 = this;
        return Object.keys(this._features).map(function(e3) {
          return t2._features[e3];
        });
      }, Ct.prototype.select = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), St(t2).forEach(function(t3) {
          n2._selectedFeatureIds.has(t3) || (n2._selectedFeatureIds.add(t3), n2._changedFeatureIds.add(t3), e3.silent || (n2._emitSelectionChange = true));
        }), this;
      }, Ct.prototype.deselect = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), St(t2).forEach(function(t3) {
          n2._selectedFeatureIds.has(t3) && (n2._selectedFeatureIds.delete(t3), n2._changedFeatureIds.add(t3), e3.silent || (n2._emitSelectionChange = true));
        }), Et(this, e3), this;
      }, Ct.prototype.clearSelected = function(t2) {
        return void 0 === t2 && (t2 = {}), this.deselect(this._selectedFeatureIds.values(), { silent: t2.silent }), this;
      }, Ct.prototype.setSelected = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), t2 = St(t2), this.deselect(this._selectedFeatureIds.values().filter(function(e4) {
          return -1 === t2.indexOf(e4);
        }), { silent: e3.silent }), this.select(t2.filter(function(t3) {
          return !n2._selectedFeatureIds.has(t3);
        }), { silent: e3.silent }), this;
      }, Ct.prototype.setSelectedCoordinates = function(t2) {
        return this._selectedCoordinates = t2, this._emitSelectionChange = true, this;
      }, Ct.prototype.clearSelectedCoordinates = function() {
        return this._selectedCoordinates = [], this._emitSelectionChange = true, this;
      }, Ct.prototype.getSelectedIds = function() {
        return this._selectedFeatureIds.values();
      }, Ct.prototype.getSelected = function() {
        var t2 = this;
        return this._selectedFeatureIds.values().map(function(e3) {
          return t2.get(e3);
        });
      }, Ct.prototype.getSelectedCoordinates = function() {
        var t2 = this;
        return this._selectedCoordinates.map(function(e3) {
          return { coordinates: t2.get(e3.feature_id).getCoordinate(e3.coord_path) };
        });
      }, Ct.prototype.isSelected = function(t2) {
        return this._selectedFeatureIds.has(t2);
      }, Ct.prototype.setFeatureProperty = function(t2, e3, n2) {
        this.get(t2).setProperty(e3, n2), this.featureChanged(t2);
      }, Ct.prototype.storeMapConfig = function() {
        var t2 = this;
        X.forEach(function(e3) {
          t2.ctx.map[e3] && (t2._mapInitialConfig[e3] = t2.ctx.map[e3].isEnabled());
        });
      }, Ct.prototype.restoreMapConfig = function() {
        var t2 = this;
        Object.keys(this._mapInitialConfig).forEach(function(e3) {
          t2._mapInitialConfig[e3] ? t2.ctx.map[e3].enable() : t2.ctx.map[e3].disable();
        });
      }, Ct.prototype.getInitialConfigValue = function(t2) {
        return void 0 === this._mapInitialConfig[t2] || this._mapInitialConfig[t2];
      };
      var Mt = function() {
        for (var t2 = arguments, e3 = {}, n2 = 0; n2 < arguments.length; n2++) {
          var o2 = t2[n2];
          for (var r2 in o2)
            wt.call(o2, r2) && (e3[r2] = o2[r2]);
        }
        return e3;
      }, wt = Object.prototype.hasOwnProperty;
      var It = ["mode", "feature", "mouse"];
      function Lt(e3) {
        var n2 = null, o2 = null, r2 = { onRemove: function() {
          return e3.map.off("load", r2.connect), clearInterval(o2), r2.removeLayers(), e3.store.restoreMapConfig(), e3.ui.removeButtons(), e3.events.removeEventListeners(), e3.ui.clearMapClasses(), e3.map = null, e3.container = null, e3.store = null, n2 && n2.parentNode && n2.parentNode.removeChild(n2), n2 = null, this;
        }, connect: function() {
          e3.map.off("load", r2.connect), clearInterval(o2), r2.addLayers(), e3.store.storeMapConfig(), e3.events.addEventListeners();
        }, onAdd: function(i2) {
          var y2 = i2.fire;
          return i2.fire = function(t2, e4) {
            var n3 = arguments;
            return 1 === y2.length && 1 !== arguments.length && (n3 = [Mt({}, { type: t2 }, e4)]), y2.apply(i2, n3);
          }, e3.map = i2, e3.events = function(e4) {
            var n3 = Object.keys(e4.options.modes).reduce(function(t2, n4) {
              return t2[n4] = _t(e4.options.modes[n4]), t2;
            }, {}), o3 = {}, r3 = {}, i3 = {}, a2 = null, s2 = null;
            i3.drag = function(t2, n4) {
              n4({ point: t2.point, time: (/* @__PURE__ */ new Date()).getTime() }) ? (e4.ui.queueMapClasses({ mouse: S }), s2.drag(t2)) : t2.originalEvent.stopPropagation();
            }, i3.mousedrag = function(t2) {
              i3.drag(t2, function(t3) {
                return !at(o3, t3);
              });
            }, i3.touchdrag = function(t2) {
              i3.drag(t2, function(t3) {
                return !st(r3, t3);
              });
            }, i3.mousemove = function(t2) {
              if (1 === (void 0 !== t2.originalEvent.buttons ? t2.originalEvent.buttons : t2.originalEvent.which))
                return i3.mousedrag(t2);
              var n4 = rt(t2, e4);
              t2.featureTarget = n4, s2.mousemove(t2);
            }, i3.mousedown = function(t2) {
              o3 = { time: (/* @__PURE__ */ new Date()).getTime(), point: t2.point };
              var n4 = rt(t2, e4);
              t2.featureTarget = n4, s2.mousedown(t2);
            }, i3.mouseup = function(t2) {
              var n4 = rt(t2, e4);
              t2.featureTarget = n4, at(o3, { point: t2.point, time: (/* @__PURE__ */ new Date()).getTime() }) ? s2.click(t2) : s2.mouseup(t2);
            }, i3.mouseout = function(t2) {
              s2.mouseout(t2);
            }, i3.touchstart = function(t2) {
              if (t2.originalEvent.preventDefault(), e4.options.touchEnabled) {
                r3 = { time: (/* @__PURE__ */ new Date()).getTime(), point: t2.point };
                var n4 = nt.touch(t2, null, e4)[0];
                t2.featureTarget = n4, s2.touchstart(t2);
              }
            }, i3.touchmove = function(t2) {
              if (t2.originalEvent.preventDefault(), e4.options.touchEnabled)
                return s2.touchmove(t2), i3.touchdrag(t2);
            }, i3.touchend = function(t2) {
              if (t2.originalEvent.preventDefault(), e4.options.touchEnabled) {
                var n4 = nt.touch(t2, null, e4)[0];
                t2.featureTarget = n4, st(r3, { time: (/* @__PURE__ */ new Date()).getTime(), point: t2.point }) ? s2.tap(t2) : s2.touchend(t2);
              }
            };
            var u2 = function(t2) {
              return !(8 === t2 || 46 === t2 || t2 >= 48 && t2 <= 57);
            };
            function c2(o4, r4, i4) {
              void 0 === i4 && (i4 = {}), s2.stop();
              var u3 = n3[o4];
              if (void 0 === u3)
                throw new Error(o4 + " is not valid");
              a2 = o4;
              var c3 = u3(e4, r4);
              s2 = t(c3, e4), i4.silent || e4.map.fire(R, { mode: o4 }), e4.store.setDirty(), e4.store.render();
            }
            i3.keydown = function(t2) {
              "mapboxgl-canvas" === (t2.srcElement || t2.target).classList[0] && (8 !== t2.keyCode && 46 !== t2.keyCode || !e4.options.controls.trash ? u2(t2.keyCode) ? s2.keydown(t2) : 49 === t2.keyCode && e4.options.controls.point ? c2(j.DRAW_POINT) : 50 === t2.keyCode && e4.options.controls.line_string ? c2(j.DRAW_LINE_STRING) : 51 === t2.keyCode && e4.options.controls.polygon && c2(j.DRAW_POLYGON) : (t2.preventDefault(), s2.trash()));
            }, i3.keyup = function(t2) {
              u2(t2.keyCode) && s2.keyup(t2);
            }, i3.zoomend = function() {
              e4.store.changeZoom();
            }, i3.data = function(t2) {
              if ("style" === t2.dataType) {
                var n4 = e4.setup, o4 = e4.map, r4 = e4.options, i4 = e4.store;
                r4.styles.some(function(t3) {
                  return o4.getLayer(t3.id);
                }) || (n4.addLayers(), i4.setDirty(), i4.render());
              }
            };
            var l2 = { trash: false, combineFeatures: false, uncombineFeatures: false };
            return { start: function() {
              a2 = e4.options.defaultMode, s2 = t(n3[a2](e4), e4);
            }, changeMode: c2, actionable: function(t2) {
              var n4 = false;
              Object.keys(t2).forEach(function(e5) {
                if (void 0 === l2[e5])
                  throw new Error("Invalid action type");
                l2[e5] !== t2[e5] && (n4 = true), l2[e5] = t2[e5];
              }), n4 && e4.map.fire(B, { actions: l2 });
            }, currentModeName: function() {
              return a2;
            }, currentModeRender: function(t2, e5) {
              return s2.render(t2, e5);
            }, fire: function(t2, e5) {
              i3[t2] && i3[t2](e5);
            }, addEventListeners: function() {
              e4.map.on("mousemove", i3.mousemove), e4.map.on("mousedown", i3.mousedown), e4.map.on("mouseup", i3.mouseup), e4.map.on("data", i3.data), e4.map.on("touchmove", i3.touchmove), e4.map.on("touchstart", i3.touchstart), e4.map.on("touchend", i3.touchend), e4.container.addEventListener("mouseout", i3.mouseout), e4.options.keybindings && (e4.container.addEventListener("keydown", i3.keydown), e4.container.addEventListener("keyup", i3.keyup));
            }, removeEventListeners: function() {
              e4.map.off("mousemove", i3.mousemove), e4.map.off("mousedown", i3.mousedown), e4.map.off("mouseup", i3.mouseup), e4.map.off("data", i3.data), e4.map.off("touchmove", i3.touchmove), e4.map.off("touchstart", i3.touchstart), e4.map.off("touchend", i3.touchend), e4.container.removeEventListener("mouseout", i3.mouseout), e4.options.keybindings && (e4.container.removeEventListener("keydown", i3.keydown), e4.container.removeEventListener("keyup", i3.keyup));
            }, trash: function(t2) {
              s2.trash(t2);
            }, combineFeatures: function() {
              s2.combineFeatures();
            }, uncombineFeatures: function() {
              s2.uncombineFeatures();
            }, getMode: function() {
              return a2;
            } };
          }(e3), e3.ui = function(t2) {
            var e4 = {}, n3 = null, o3 = { mode: null, feature: null, mouse: null }, r3 = { mode: null, feature: null, mouse: null };
            function i3(t3) {
              r3 = Mt(r3, t3);
            }
            function y3() {
              var e5, n4;
              if (t2.container) {
                var i4 = [], a2 = [];
                It.forEach(function(t3) {
                  r3[t3] !== o3[t3] && (i4.push(t3 + "-" + o3[t3]), null !== r3[t3] && a2.push(t3 + "-" + r3[t3]));
                }), i4.length > 0 && (e5 = t2.container.classList).remove.apply(e5, i4), a2.length > 0 && (n4 = t2.container.classList).add.apply(n4, a2), o3 = Mt(o3, r3);
              }
            }
            function v2(t3, e5) {
              void 0 === e5 && (e5 = {});
              var o4 = document.createElement("button");
              return o4.className = s + " " + e5.className, o4.setAttribute("title", e5.title), e5.container.appendChild(o4), o4.addEventListener("click", function(o5) {
                if (o5.preventDefault(), o5.stopPropagation(), o5.target === n3)
                  return m2(), void e5.onDeactivate();
                b2(t3), e5.onActivate();
              }, true), o4;
            }
            function m2() {
              n3 && (n3.classList.remove(g), n3 = null);
            }
            function b2(t3) {
              m2();
              var o4 = e4[t3];
              o4 && o4 && "trash" !== t3 && (o4.classList.add(g), n3 = o4);
            }
            return { setActiveButton: b2, queueMapClasses: i3, updateMapClasses: y3, clearMapClasses: function() {
              i3({ mode: null, feature: null, mouse: null }), y3();
            }, addButtons: function() {
              var n4 = t2.options.controls, o4 = document.createElement("div");
              return o4.className = h + " " + a, n4 ? (n4[E.LINE] && (e4[E.LINE] = v2(E.LINE, { container: o4, className: u, title: "LineString tool " + (t2.options.keybindings ? "(l)" : ""), onActivate: function() {
                return t2.events.changeMode(j.DRAW_LINE_STRING);
              }, onDeactivate: function() {
                return t2.events.trash();
              } })), n4[E.POLYGON] && (e4[E.POLYGON] = v2(E.POLYGON, { container: o4, className: c, title: "Polygon tool " + (t2.options.keybindings ? "(p)" : ""), onActivate: function() {
                return t2.events.changeMode(j.DRAW_POLYGON);
              }, onDeactivate: function() {
                return t2.events.trash();
              } })), n4[E.POINT] && (e4[E.POINT] = v2(E.POINT, { container: o4, className: l, title: "Marker tool " + (t2.options.keybindings ? "(m)" : ""), onActivate: function() {
                return t2.events.changeMode(j.DRAW_POINT);
              }, onDeactivate: function() {
                return t2.events.trash();
              } })), n4.trash && (e4.trash = v2("trash", { container: o4, className: d, title: "Delete", onActivate: function() {
                t2.events.trash();
              } })), n4.combine_features && (e4.combine_features = v2("combineFeatures", { container: o4, className: p, title: "Combine", onActivate: function() {
                t2.events.combineFeatures();
              } })), n4.uncombine_features && (e4.uncombine_features = v2("uncombineFeatures", { container: o4, className: f, title: "Uncombine", onActivate: function() {
                t2.events.uncombineFeatures();
              } })), o4) : o4;
            }, removeButtons: function() {
              Object.keys(e4).forEach(function(t3) {
                var n4 = e4[t3];
                n4.parentNode && n4.parentNode.removeChild(n4), delete e4[t3];
              });
            } };
          }(e3), e3.container = i2.getContainer(), e3.store = new Ct(e3), n2 = e3.ui.addButtons(), e3.options.boxSelect && (i2.boxZoom.disable(), i2.dragPan.disable(), i2.dragPan.enable()), i2.loaded() ? r2.connect() : (i2.on("load", r2.connect), o2 = setInterval(function() {
            i2.loaded() && r2.connect();
          }, 16)), e3.events.start(), n2;
        }, addLayers: function() {
          e3.map.addSource(m, { data: { type: P, features: [] }, type: "geojson" }), e3.map.addSource(v, { data: { type: P, features: [] }, type: "geojson" }), e3.options.styles.forEach(function(t2) {
            e3.map.addLayer(t2);
          }), e3.store.setDirty(true), e3.store.render();
        }, removeLayers: function() {
          e3.options.styles.forEach(function(t2) {
            e3.map.getLayer(t2.id) && e3.map.removeLayer(t2.id);
          }), e3.map.getSource(m) && e3.map.removeSource(m), e3.map.getSource(v) && e3.map.removeSource(v);
        } };
        return e3.setup = r2, r2;
      }
      function Pt(t2) {
        return function(e3) {
          var n2 = e3.featureTarget;
          return !!n2 && (!!n2.properties && n2.properties.meta === t2);
        };
      }
      function Ft(t2) {
        return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === Z && t2.featureTarget.properties.meta === W));
      }
      function Ot(t2) {
        return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === K && t2.featureTarget.properties.meta === W));
      }
      function kt(t2) {
        return void 0 === t2.featureTarget;
      }
      function Tt(t2) {
        var e3 = t2.featureTarget;
        return !!e3 && (!!e3.properties && e3.properties.meta === Y);
      }
      function jt(t2) {
        return !!t2.originalEvent && true === t2.originalEvent.shiftKey;
      }
      function At(t2) {
        return 27 === t2.keyCode;
      }
      function Dt(t2) {
        return 13 === t2.keyCode;
      }
      var Nt = Ut;
      function Ut(t2, e3) {
        this.x = t2, this.y = e3;
      }
      function Rt(t2, e3) {
        var n2 = e3.getBoundingClientRect();
        return new Nt(t2.clientX - n2.left - (e3.clientLeft || 0), t2.clientY - n2.top - (e3.clientTop || 0));
      }
      function Bt(t2, e3, n2, o2) {
        return { type: M, properties: { meta: Y, parent: t2, coord_path: n2, active: o2 ? Z : K }, geometry: { type: L, coordinates: e3 } };
      }
      function Vt(t2, e3, n2) {
        void 0 === e3 && (e3 = {}), void 0 === n2 && (n2 = null);
        var o2, r2 = t2.geometry, i2 = r2.type, a2 = r2.coordinates, s2 = t2.properties && t2.properties.id, u2 = [];
        function c2(t3, n3) {
          var o3 = "", r3 = null;
          t3.forEach(function(t4, i3) {
            var a3 = null != n3 ? n3 + "." + i3 : String(i3), c3 = Bt(s2, t4, a3, l2(a3));
            if (e3.midpoints && r3) {
              var d2 = function(t5, e4, n4) {
                var o4 = e4.geometry.coordinates, r4 = n4.geometry.coordinates;
                if (o4[1] > 85 || o4[1] < -85 || r4[1] > 85 || r4[1] < -85)
                  return null;
                var i4 = { lng: (o4[0] + r4[0]) / 2, lat: (o4[1] + r4[1]) / 2 };
                return { type: M, properties: { meta: q, parent: t5, lng: i4.lng, lat: i4.lat, coord_path: n4.properties.coord_path }, geometry: { type: L, coordinates: [i4.lng, i4.lat] } };
              }(s2, r3, c3);
              d2 && u2.push(d2);
            }
            r3 = c3;
            var p2 = JSON.stringify(t4);
            o3 !== p2 && u2.push(c3), 0 === i3 && (o3 = p2);
          });
        }
        function l2(t3) {
          return !!e3.selectedPaths && -1 !== e3.selectedPaths.indexOf(t3);
        }
        return i2 === L ? u2.push(Bt(s2, a2, n2, l2(n2))) : i2 === w ? a2.forEach(function(t3, e4) {
          c2(t3, null !== n2 ? n2 + "." + e4 : String(e4));
        }) : i2 === I ? c2(a2, n2) : 0 === i2.indexOf(F) && (o2 = i2.replace(F, ""), a2.forEach(function(n3, r3) {
          var i3 = { type: M, properties: t2.properties, geometry: { type: o2, coordinates: n3 } };
          u2 = u2.concat(Vt(i3, e3, r3));
        })), u2;
      }
      Ut.prototype = { clone: function() {
        return new Ut(this.x, this.y);
      }, add: function(t2) {
        return this.clone()._add(t2);
      }, sub: function(t2) {
        return this.clone()._sub(t2);
      }, multByPoint: function(t2) {
        return this.clone()._multByPoint(t2);
      }, divByPoint: function(t2) {
        return this.clone()._divByPoint(t2);
      }, mult: function(t2) {
        return this.clone()._mult(t2);
      }, div: function(t2) {
        return this.clone()._div(t2);
      }, rotate: function(t2) {
        return this.clone()._rotate(t2);
      }, rotateAround: function(t2, e3) {
        return this.clone()._rotateAround(t2, e3);
      }, matMult: function(t2) {
        return this.clone()._matMult(t2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t2) {
        return this.x === t2.x && this.y === t2.y;
      }, dist: function(t2) {
        return Math.sqrt(this.distSqr(t2));
      }, distSqr: function(t2) {
        var e3 = t2.x - this.x, n2 = t2.y - this.y;
        return e3 * e3 + n2 * n2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t2) {
        return Math.atan2(this.y - t2.y, this.x - t2.x);
      }, angleWith: function(t2) {
        return this.angleWithSep(t2.x, t2.y);
      }, angleWithSep: function(t2, e3) {
        return Math.atan2(this.x * e3 - this.y * t2, this.x * t2 + this.y * e3);
      }, _matMult: function(t2) {
        var e3 = t2[0] * this.x + t2[1] * this.y, n2 = t2[2] * this.x + t2[3] * this.y;
        return this.x = e3, this.y = n2, this;
      }, _add: function(t2) {
        return this.x += t2.x, this.y += t2.y, this;
      }, _sub: function(t2) {
        return this.x -= t2.x, this.y -= t2.y, this;
      }, _mult: function(t2) {
        return this.x *= t2, this.y *= t2, this;
      }, _div: function(t2) {
        return this.x /= t2, this.y /= t2, this;
      }, _multByPoint: function(t2) {
        return this.x *= t2.x, this.y *= t2.y, this;
      }, _divByPoint: function(t2) {
        return this.x /= t2.x, this.y /= t2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t2 = this.y;
        return this.y = this.x, this.x = -t2, this;
      }, _rotate: function(t2) {
        var e3 = Math.cos(t2), n2 = Math.sin(t2), o2 = e3 * this.x - n2 * this.y, r2 = n2 * this.x + e3 * this.y;
        return this.x = o2, this.y = r2, this;
      }, _rotateAround: function(t2, e3) {
        var n2 = Math.cos(t2), o2 = Math.sin(t2), r2 = e3.x + n2 * (this.x - e3.x) - o2 * (this.y - e3.y), i2 = e3.y + o2 * (this.x - e3.x) + n2 * (this.y - e3.y);
        return this.x = r2, this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, Ut.convert = function(t2) {
        return t2 instanceof Ut ? t2 : Array.isArray(t2) ? new Ut(t2[0], t2[1]) : t2;
      };
      var Jt = function(t2) {
        setTimeout(function() {
          t2.map && t2.map.doubleClickZoom && t2._ctx && t2._ctx.store && t2._ctx.store.getInitialConfigValue && t2._ctx.store.getInitialConfigValue("doubleClickZoom") && t2.map.doubleClickZoom.enable();
        }, 0);
      }, Gt = function(t2) {
        setTimeout(function() {
          t2.map && t2.map.doubleClickZoom && t2.map.doubleClickZoom.disable();
        }, 0);
      }, zt = function(t2) {
        if (!t2 || !t2.type)
          return null;
        var e3 = $t[t2.type];
        if (!e3)
          return null;
        if ("geometry" === e3)
          return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: t2 }] };
        if ("feature" === e3)
          return { type: "FeatureCollection", features: [t2] };
        if ("featurecollection" === e3)
          return t2;
      }, $t = { Point: "geometry", MultiPoint: "geometry", LineString: "geometry", MultiLineString: "geometry", Polygon: "geometry", MultiPolygon: "geometry", GeometryCollection: "geometry", Feature: "feature", FeatureCollection: "featurecollection" };
      function Wt(t2) {
        switch (t2 && t2.type || null) {
          case "FeatureCollection":
            return t2.features = t2.features.reduce(function(t3, e3) {
              return t3.concat(Wt(e3));
            }, []), t2;
          case "Feature":
            return t2.geometry ? Wt(t2.geometry).map(function(e3) {
              var n2 = { type: "Feature", properties: JSON.parse(JSON.stringify(t2.properties)), geometry: e3 };
              return void 0 !== t2.id && (n2.id = t2.id), n2;
            }) : [t2];
          case "MultiPoint":
            return t2.coordinates.map(function(t3) {
              return { type: "Point", coordinates: t3 };
            });
          case "MultiPolygon":
            return t2.coordinates.map(function(t3) {
              return { type: "Polygon", coordinates: t3 };
            });
          case "MultiLineString":
            return t2.coordinates.map(function(t3) {
              return { type: "LineString", coordinates: t3 };
            });
          case "GeometryCollection":
            return t2.geometries.map(Wt).reduce(function(t3, e3) {
              return t3.concat(e3);
            }, []);
          case "Point":
          case "Polygon":
          case "LineString":
            return [t2];
        }
      }
      var qt = function(t2) {
        if (!t2)
          return [];
        var e3 = Wt(zt(t2)), n2 = [];
        return e3.features.forEach(function(t3) {
          t3.geometry && (n2 = n2.concat(function t4(e4) {
            return Array.isArray(e4) && e4.length && "number" == typeof e4[0] ? [e4] : e4.reduce(function(e5, n3) {
              return Array.isArray(n3) && Array.isArray(n3[0]) ? e5.concat(t4(n3)) : (e5.push(n3), e5);
            }, []);
          }(t3.geometry.coordinates)));
        }), n2;
      }, Yt = ut(function(t2) {
        var e3 = t2.exports = function(t3) {
          return new n2(t3);
        };
        function n2(t3) {
          this.value = t3;
        }
        function o2(t3, e4, n3) {
          var o3 = [], a3 = [], l2 = true;
          return function t4(d2) {
            var p2 = n3 ? r2(d2) : d2, f2 = {}, h2 = true, g2 = { node: p2, node_: d2, path: [].concat(o3), parent: a3[a3.length - 1], parents: a3, key: o3.slice(-1)[0], isRoot: 0 === o3.length, level: o3.length, circular: null, update: function(t5, e5) {
              g2.isRoot || (g2.parent.node[g2.key] = t5), g2.node = t5, e5 && (h2 = false);
            }, delete: function(t5) {
              delete g2.parent.node[g2.key], t5 && (h2 = false);
            }, remove: function(t5) {
              s2(g2.parent.node) ? g2.parent.node.splice(g2.key, 1) : delete g2.parent.node[g2.key], t5 && (h2 = false);
            }, keys: null, before: function(t5) {
              f2.before = t5;
            }, after: function(t5) {
              f2.after = t5;
            }, pre: function(t5) {
              f2.pre = t5;
            }, post: function(t5) {
              f2.post = t5;
            }, stop: function() {
              l2 = false;
            }, block: function() {
              h2 = false;
            } };
            if (!l2)
              return g2;
            function y2() {
              if ("object" == typeof g2.node && null !== g2.node) {
                g2.keys && g2.node_ === g2.node || (g2.keys = i2(g2.node)), g2.isLeaf = 0 == g2.keys.length;
                for (var t5 = 0; t5 < a3.length; t5++)
                  if (a3[t5].node_ === d2) {
                    g2.circular = a3[t5];
                    break;
                  }
              } else
                g2.isLeaf = true, g2.keys = null;
              g2.notLeaf = !g2.isLeaf, g2.notRoot = !g2.isRoot;
            }
            y2();
            var v2 = e4.call(g2, g2.node);
            return void 0 !== v2 && g2.update && g2.update(v2), f2.before && f2.before.call(g2, g2.node), h2 ? ("object" != typeof g2.node || null === g2.node || g2.circular || (a3.push(g2), y2(), u2(g2.keys, function(e5, r3) {
              o3.push(e5), f2.pre && f2.pre.call(g2, g2.node[e5], e5);
              var i3 = t4(g2.node[e5]);
              n3 && c2.call(g2.node, e5) && (g2.node[e5] = i3.node), i3.isLast = r3 == g2.keys.length - 1, i3.isFirst = 0 == r3, f2.post && f2.post.call(g2, i3), o3.pop();
            }), a3.pop()), f2.after && f2.after.call(g2, g2.node), g2) : g2;
          }(t3).node;
        }
        function r2(t3) {
          if ("object" == typeof t3 && null !== t3) {
            var e4;
            if (s2(t3))
              e4 = [];
            else if ("[object Date]" === a2(t3))
              e4 = new Date(t3.getTime ? t3.getTime() : t3);
            else if (function(t4) {
              return "[object RegExp]" === a2(t4);
            }(t3))
              e4 = new RegExp(t3);
            else if (function(t4) {
              return "[object Error]" === a2(t4);
            }(t3))
              e4 = { message: t3.message };
            else if (function(t4) {
              return "[object Boolean]" === a2(t4);
            }(t3))
              e4 = new Boolean(t3);
            else if (function(t4) {
              return "[object Number]" === a2(t4);
            }(t3))
              e4 = new Number(t3);
            else if (function(t4) {
              return "[object String]" === a2(t4);
            }(t3))
              e4 = new String(t3);
            else if (Object.create && Object.getPrototypeOf)
              e4 = Object.create(Object.getPrototypeOf(t3));
            else if (t3.constructor === Object)
              e4 = {};
            else {
              var n3 = t3.constructor && t3.constructor.prototype || t3.__proto__ || {}, o3 = function() {
              };
              o3.prototype = n3, e4 = new o3();
            }
            return u2(i2(t3), function(n4) {
              e4[n4] = t3[n4];
            }), e4;
          }
          return t3;
        }
        n2.prototype.get = function(t3) {
          for (var e4 = this.value, n3 = 0; n3 < t3.length; n3++) {
            var o3 = t3[n3];
            if (!e4 || !c2.call(e4, o3)) {
              e4 = void 0;
              break;
            }
            e4 = e4[o3];
          }
          return e4;
        }, n2.prototype.has = function(t3) {
          for (var e4 = this.value, n3 = 0; n3 < t3.length; n3++) {
            var o3 = t3[n3];
            if (!e4 || !c2.call(e4, o3))
              return false;
            e4 = e4[o3];
          }
          return true;
        }, n2.prototype.set = function(t3, e4) {
          for (var n3 = this.value, o3 = 0; o3 < t3.length - 1; o3++) {
            var r3 = t3[o3];
            c2.call(n3, r3) || (n3[r3] = {}), n3 = n3[r3];
          }
          return n3[t3[o3]] = e4, e4;
        }, n2.prototype.map = function(t3) {
          return o2(this.value, t3, true);
        }, n2.prototype.forEach = function(t3) {
          return this.value = o2(this.value, t3, false), this.value;
        }, n2.prototype.reduce = function(t3, e4) {
          var n3 = 1 === arguments.length, o3 = n3 ? this.value : e4;
          return this.forEach(function(e5) {
            this.isRoot && n3 || (o3 = t3.call(this, o3, e5));
          }), o3;
        }, n2.prototype.paths = function() {
          var t3 = [];
          return this.forEach(function(e4) {
            t3.push(this.path);
          }), t3;
        }, n2.prototype.nodes = function() {
          var t3 = [];
          return this.forEach(function(e4) {
            t3.push(this.node);
          }), t3;
        }, n2.prototype.clone = function() {
          var t3 = [], e4 = [];
          return function n3(o3) {
            for (var a3 = 0; a3 < t3.length; a3++)
              if (t3[a3] === o3)
                return e4[a3];
            if ("object" == typeof o3 && null !== o3) {
              var s3 = r2(o3);
              return t3.push(o3), e4.push(s3), u2(i2(o3), function(t4) {
                s3[t4] = n3(o3[t4]);
              }), t3.pop(), e4.pop(), s3;
            }
            return o3;
          }(this.value);
        };
        var i2 = Object.keys || function(t3) {
          var e4 = [];
          for (var n3 in t3)
            e4.push(n3);
          return e4;
        };
        function a2(t3) {
          return Object.prototype.toString.call(t3);
        }
        var s2 = Array.isArray || function(t3) {
          return "[object Array]" === Object.prototype.toString.call(t3);
        }, u2 = function(t3, e4) {
          if (t3.forEach)
            return t3.forEach(e4);
          for (var n3 = 0; n3 < t3.length; n3++)
            e4(t3[n3], n3, t3);
        };
        u2(i2(n2.prototype), function(t3) {
          e3[t3] = function(e4) {
            var o3 = [].slice.call(arguments, 1), r3 = new n2(e4);
            return r3[t3].apply(r3, o3);
          };
        });
        var c2 = Object.hasOwnProperty || function(t3, e4) {
          return e4 in t3;
        };
      }), Zt = Kt;
      function Kt(t2) {
        if (!(this instanceof Kt))
          return new Kt(t2);
        this._bbox = t2 || [1 / 0, 1 / 0, -1 / 0, -1 / 0], this._valid = !!t2;
      }
      Kt.prototype.include = function(t2) {
        return this._valid = true, this._bbox[0] = Math.min(this._bbox[0], t2[0]), this._bbox[1] = Math.min(this._bbox[1], t2[1]), this._bbox[2] = Math.max(this._bbox[2], t2[0]), this._bbox[3] = Math.max(this._bbox[3], t2[1]), this;
      }, Kt.prototype.equals = function(t2) {
        var e3;
        return e3 = t2 instanceof Kt ? t2.bbox() : t2, this._bbox[0] == e3[0] && this._bbox[1] == e3[1] && this._bbox[2] == e3[2] && this._bbox[3] == e3[3];
      }, Kt.prototype.center = function(t2) {
        return this._valid ? [(this._bbox[0] + this._bbox[2]) / 2, (this._bbox[1] + this._bbox[3]) / 2] : null;
      }, Kt.prototype.union = function(t2) {
        var e3;
        return this._valid = true, e3 = t2 instanceof Kt ? t2.bbox() : t2, this._bbox[0] = Math.min(this._bbox[0], e3[0]), this._bbox[1] = Math.min(this._bbox[1], e3[1]), this._bbox[2] = Math.max(this._bbox[2], e3[2]), this._bbox[3] = Math.max(this._bbox[3], e3[3]), this;
      }, Kt.prototype.bbox = function() {
        return this._valid ? this._bbox : null;
      }, Kt.prototype.contains = function(t2) {
        if (!t2)
          return this._fastContains();
        if (!this._valid)
          return null;
        var e3 = t2[0], n2 = t2[1];
        return this._bbox[0] <= e3 && this._bbox[1] <= n2 && this._bbox[2] >= e3 && this._bbox[3] >= n2;
      }, Kt.prototype.intersect = function(t2) {
        return this._valid ? (e3 = t2 instanceof Kt ? t2.bbox() : t2, !(this._bbox[0] > e3[2] || this._bbox[2] < e3[0] || this._bbox[3] < e3[1] || this._bbox[1] > e3[3])) : null;
        var e3;
      }, Kt.prototype._fastContains = function() {
        if (!this._valid)
          return new Function("return null;");
        var t2 = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]";
        return new Function("ll", t2);
      }, Kt.prototype.polygon = function() {
        return this._valid ? { type: "Polygon", coordinates: [[[this._bbox[0], this._bbox[1]], [this._bbox[2], this._bbox[1]], [this._bbox[2], this._bbox[3]], [this._bbox[0], this._bbox[3]], [this._bbox[0], this._bbox[1]]]] } : null;
      };
      var Xt = { features: ["FeatureCollection"], coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], geometry: ["Feature"], geometries: ["GeometryCollection"] }, Ht = Object.keys(Xt), Qt = function(t2) {
        return te(t2).bbox();
      };
      function te(t2) {
        for (var e3 = Zt(), n2 = qt(t2), o2 = 0; o2 < n2.length; o2++)
          e3.include(n2[o2]);
        return e3;
      }
      Qt.polygon = function(t2) {
        return te(t2).polygon();
      }, Qt.bboxify = function(t2) {
        return Yt(t2).map(function(t3) {
          t3 && (Ht.some(function(e3) {
            return !!t3[e3] && -1 !== Xt[e3].indexOf(t3.type);
          }) && (t3.bbox = te(t3).bbox(), this.update(t3)));
        });
      };
      function ee(t2, e3) {
        var n2 = -90, o2 = 90, r2 = -90, i2 = 90, a2 = 270, s2 = -270;
        t2.forEach(function(t3) {
          var e4 = Qt(t3), u3 = e4[1], c2 = e4[3], l2 = e4[0], d2 = e4[2];
          u3 > n2 && (n2 = u3), c2 < o2 && (o2 = c2), c2 > r2 && (r2 = c2), u3 < i2 && (i2 = u3), l2 < a2 && (a2 = l2), d2 > s2 && (s2 = d2);
        });
        var u2 = e3;
        return n2 + u2.lat > 85 && (u2.lat = 85 - n2), r2 + u2.lat > 90 && (u2.lat = 90 - r2), o2 + u2.lat < -85 && (u2.lat = -85 - o2), i2 + u2.lat < -90 && (u2.lat = -90 - i2), a2 + u2.lng <= -270 && (u2.lng += 360 * Math.ceil(Math.abs(u2.lng) / 360)), s2 + u2.lng >= 270 && (u2.lng -= 360 * Math.ceil(Math.abs(u2.lng) / 360)), u2;
      }
      function ne(t2, e3) {
        var n2 = ee(t2.map(function(t3) {
          return t3.toGeoJSON();
        }), e3);
        t2.forEach(function(t3) {
          var e4, o2 = t3.getCoordinates(), r2 = function(t4) {
            var e5 = { lng: t4[0] + n2.lng, lat: t4[1] + n2.lat };
            return [e5.lng, e5.lat];
          }, i2 = function(t4) {
            return t4.map(function(t5) {
              return r2(t5);
            });
          };
          t3.type === L ? e4 = r2(o2) : t3.type === I || t3.type === O ? e4 = o2.map(r2) : t3.type === w || t3.type === k ? e4 = o2.map(i2) : t3.type === T && (e4 = o2.map(function(t4) {
            return t4.map(function(t5) {
              return i2(t5);
            });
          })), t3.incomingCoords(e4);
        });
      }
      var oe = { onSetup: function(t2) {
        var e3 = this, n2 = { dragMoveLocation: null, boxSelectStartLocation: null, boxSelectElement: void 0, boxSelecting: false, canBoxSelect: false, dragMoving: false, canDragMove: false, initiallySelectedFeatureIds: t2.featureIds || [] };
        return this.setSelected(n2.initiallySelectedFeatureIds.filter(function(t3) {
          return void 0 !== e3.getFeature(t3);
        })), this.fireActionable(), this.setActionableState({ combineFeatures: true, uncombineFeatures: true, trash: true }), n2;
      }, fireUpdate: function() {
        this.map.fire(N, { action: z, features: this.getSelected().map(function(t2) {
          return t2.toGeoJSON();
        }) });
      }, fireActionable: function() {
        var t2 = this, e3 = this.getSelected(), n2 = e3.filter(function(e4) {
          return t2.isInstanceOf("MultiFeature", e4);
        }), o2 = false;
        if (e3.length > 1) {
          o2 = true;
          var r2 = e3[0].type.replace("Multi", "");
          e3.forEach(function(t3) {
            t3.type.replace("Multi", "") !== r2 && (o2 = false);
          });
        }
        var i2 = n2.length > 0, a2 = e3.length > 0;
        this.setActionableState({ combineFeatures: o2, uncombineFeatures: i2, trash: a2 });
      }, getUniqueIds: function(t2) {
        return t2.length ? t2.map(function(t3) {
          return t3.properties.id;
        }).filter(function(t3) {
          return void 0 !== t3;
        }).reduce(function(t3, e3) {
          return t3.add(e3), t3;
        }, new tt()).values() : [];
      }, stopExtendedInteractions: function(t2) {
        t2.boxSelectElement && (t2.boxSelectElement.parentNode && t2.boxSelectElement.parentNode.removeChild(t2.boxSelectElement), t2.boxSelectElement = null), this.map.dragPan.enable(), t2.boxSelecting = false, t2.canBoxSelect = false, t2.dragMoving = false, t2.canDragMove = false;
      }, onStop: function() {
        Jt(this);
      }, onMouseMove: function(t2) {
        return this.stopExtendedInteractions(t2), true;
      }, onMouseOut: function(t2) {
        return !t2.dragMoving || this.fireUpdate();
      } };
      oe.onTap = oe.onClick = function(t2, e3) {
        return kt(e3) ? this.clickAnywhere(t2, e3) : Pt(Y)(e3) ? this.clickOnVertex(t2, e3) : function(t3) {
          return !!t3.featureTarget && (!!t3.featureTarget.properties && t3.featureTarget.properties.meta === W);
        }(e3) ? this.clickOnFeature(t2, e3) : void 0;
      }, oe.clickAnywhere = function(t2) {
        var e3 = this, n2 = this.getSelectedIds();
        n2.length && (this.clearSelectedFeatures(), n2.forEach(function(t3) {
          return e3.doRender(t3);
        })), Jt(this), this.stopExtendedInteractions(t2);
      }, oe.clickOnVertex = function(t2, e3) {
        this.changeMode(j.DIRECT_SELECT, { featureId: e3.featureTarget.properties.parent, coordPath: e3.featureTarget.properties.coord_path, startPos: e3.lngLat }), this.updateUIClasses({ mouse: _ });
      }, oe.startOnActiveFeature = function(t2, e3) {
        this.stopExtendedInteractions(t2), this.map.dragPan.disable(), this.doRender(e3.featureTarget.properties.id), t2.canDragMove = true, t2.dragMoveLocation = e3.lngLat;
      }, oe.clickOnFeature = function(t2, e3) {
        var n2 = this;
        Gt(this), this.stopExtendedInteractions(t2);
        var o2 = jt(e3), r2 = this.getSelectedIds(), i2 = e3.featureTarget.properties.id, a2 = this.isSelected(i2);
        if (!o2 && a2 && this.getFeature(i2).type !== L)
          return this.changeMode(j.DIRECT_SELECT, { featureId: i2 });
        a2 && o2 ? (this.deselect(i2), this.updateUIClasses({ mouse: x }), 1 === r2.length && Jt(this)) : !a2 && o2 ? (this.select(i2), this.updateUIClasses({ mouse: _ })) : a2 || o2 || (r2.forEach(function(t3) {
          return n2.doRender(t3);
        }), this.setSelected(i2), this.updateUIClasses({ mouse: _ })), this.doRender(i2);
      }, oe.onMouseDown = function(t2, e3) {
        return Ft(e3) ? this.startOnActiveFeature(t2, e3) : this.drawConfig.boxSelect && function(t3) {
          return !!t3.originalEvent && (!!t3.originalEvent.shiftKey && 0 === t3.originalEvent.button);
        }(e3) ? this.startBoxSelect(t2, e3) : void 0;
      }, oe.startBoxSelect = function(t2, e3) {
        this.stopExtendedInteractions(t2), this.map.dragPan.disable(), t2.boxSelectStartLocation = Rt(e3.originalEvent, this.map.getContainer()), t2.canBoxSelect = true;
      }, oe.onTouchStart = function(t2, e3) {
        if (Ft(e3))
          return this.startOnActiveFeature(t2, e3);
      }, oe.onDrag = function(t2, e3) {
        return t2.canDragMove ? this.dragMove(t2, e3) : this.drawConfig.boxSelect && t2.canBoxSelect ? this.whileBoxSelect(t2, e3) : void 0;
      }, oe.whileBoxSelect = function(t2, e3) {
        t2.boxSelecting = true, this.updateUIClasses({ mouse: b }), t2.boxSelectElement || (t2.boxSelectElement = document.createElement("div"), t2.boxSelectElement.classList.add(y), this.map.getContainer().appendChild(t2.boxSelectElement));
        var n2 = Rt(e3.originalEvent, this.map.getContainer()), o2 = Math.min(t2.boxSelectStartLocation.x, n2.x), r2 = Math.max(t2.boxSelectStartLocation.x, n2.x), i2 = Math.min(t2.boxSelectStartLocation.y, n2.y), a2 = Math.max(t2.boxSelectStartLocation.y, n2.y), s2 = "translate(" + o2 + "px, " + i2 + "px)";
        t2.boxSelectElement.style.transform = s2, t2.boxSelectElement.style.WebkitTransform = s2, t2.boxSelectElement.style.width = r2 - o2 + "px", t2.boxSelectElement.style.height = a2 - i2 + "px";
      }, oe.dragMove = function(t2, e3) {
        t2.dragMoving = true, e3.originalEvent.stopPropagation();
        var n2 = { lng: e3.lngLat.lng - t2.dragMoveLocation.lng, lat: e3.lngLat.lat - t2.dragMoveLocation.lat };
        ne(this.getSelected(), n2), t2.dragMoveLocation = e3.lngLat;
      }, oe.onMouseUp = function(t2, e3) {
        var n2 = this;
        if (t2.dragMoving)
          this.fireUpdate();
        else if (t2.boxSelecting) {
          var o2 = [t2.boxSelectStartLocation, Rt(e3.originalEvent, this.map.getContainer())], r2 = this.featuresAt(null, o2, "click"), i2 = this.getUniqueIds(r2).filter(function(t3) {
            return !n2.isSelected(t3);
          });
          i2.length && (this.select(i2), i2.forEach(function(t3) {
            return n2.doRender(t3);
          }), this.updateUIClasses({ mouse: _ }));
        }
        this.stopExtendedInteractions(t2);
      }, oe.toDisplayFeatures = function(t2, e3, n2) {
        e3.properties.active = this.isSelected(e3.properties.id) ? Z : K, n2(e3), this.fireActionable(), e3.properties.active === Z && e3.geometry.type !== L && Vt(e3).forEach(n2);
      }, oe.onTrash = function() {
        this.deleteFeature(this.getSelectedIds()), this.fireActionable();
      }, oe.onCombineFeatures = function() {
        var t2 = this.getSelected();
        if (!(0 === t2.length || t2.length < 2)) {
          for (var e3 = [], n2 = [], o2 = t2[0].type.replace("Multi", ""), r2 = 0; r2 < t2.length; r2++) {
            var i2 = t2[r2];
            if (i2.type.replace("Multi", "") !== o2)
              return;
            i2.type.includes("Multi") ? i2.getCoordinates().forEach(function(t3) {
              e3.push(t3);
            }) : e3.push(i2.getCoordinates()), n2.push(i2.toGeoJSON());
          }
          if (n2.length > 1) {
            var a2 = this.newFeature({ type: M, properties: n2[0].properties, geometry: { type: "Multi" + o2, coordinates: e3 } });
            this.addFeature(a2), this.deleteFeature(this.getSelectedIds(), { silent: true }), this.setSelected([a2.id]), this.map.fire(J, { createdFeatures: [a2.toGeoJSON()], deletedFeatures: n2 });
          }
          this.fireActionable();
        }
      }, oe.onUncombineFeatures = function() {
        var t2 = this, e3 = this.getSelected();
        if (0 !== e3.length) {
          for (var n2 = [], o2 = [], r2 = function(r3) {
            var i3 = e3[r3];
            t2.isInstanceOf("MultiFeature", i3) && (i3.getFeatures().forEach(function(e4) {
              t2.addFeature(e4), e4.properties = i3.properties, n2.push(e4.toGeoJSON()), t2.select([e4.id]);
            }), t2.deleteFeature(i3.id, { silent: true }), o2.push(i3.toGeoJSON()));
          }, i2 = 0; i2 < e3.length; i2++)
            r2(i2);
          n2.length > 1 && this.map.fire(G, { createdFeatures: n2, deletedFeatures: o2 }), this.fireActionable();
        }
      };
      var re = Pt(Y), ie = Pt(q), ae = { fireUpdate: function() {
        this.map.fire(N, { action: $, features: this.getSelected().map(function(t2) {
          return t2.toGeoJSON();
        }) });
      }, fireActionable: function(t2) {
        this.setActionableState({ combineFeatures: false, uncombineFeatures: false, trash: t2.selectedCoordPaths.length > 0 });
      }, startDragging: function(t2, e3) {
        this.map.dragPan.disable(), t2.canDragMove = true, t2.dragMoveLocation = e3.lngLat;
      }, stopDragging: function(t2) {
        this.map.dragPan.enable(), t2.dragMoving = false, t2.canDragMove = false, t2.dragMoveLocation = null;
      }, onVertex: function(t2, e3) {
        this.startDragging(t2, e3);
        var n2 = e3.featureTarget.properties, o2 = t2.selectedCoordPaths.indexOf(n2.coord_path);
        jt(e3) || -1 !== o2 ? jt(e3) && -1 === o2 && t2.selectedCoordPaths.push(n2.coord_path) : t2.selectedCoordPaths = [n2.coord_path];
        var r2 = this.pathsToCoordinates(t2.featureId, t2.selectedCoordPaths);
        this.setSelectedCoordinates(r2);
      }, onMidpoint: function(t2, e3) {
        this.startDragging(t2, e3);
        var n2 = e3.featureTarget.properties;
        t2.feature.addCoordinate(n2.coord_path, n2.lng, n2.lat), this.fireUpdate(), t2.selectedCoordPaths = [n2.coord_path];
      }, pathsToCoordinates: function(t2, e3) {
        return e3.map(function(e4) {
          return { feature_id: t2, coord_path: e4 };
        });
      }, onFeature: function(t2, e3) {
        0 === t2.selectedCoordPaths.length ? this.startDragging(t2, e3) : this.stopDragging(t2);
      }, dragFeature: function(t2, e3, n2) {
        ne(this.getSelected(), n2), t2.dragMoveLocation = e3.lngLat;
      }, dragVertex: function(t2, e3, n2) {
        for (var o2 = t2.selectedCoordPaths.map(function(e4) {
          return t2.feature.getCoordinate(e4);
        }), r2 = ee(o2.map(function(t3) {
          return { type: M, properties: {}, geometry: { type: L, coordinates: t3 } };
        }), n2), i2 = 0; i2 < o2.length; i2++) {
          var a2 = o2[i2];
          t2.feature.updateCoordinate(t2.selectedCoordPaths[i2], a2[0] + r2.lng, a2[1] + r2.lat);
        }
      }, clickNoTarget: function() {
        this.changeMode(j.SIMPLE_SELECT);
      }, clickInactive: function() {
        this.changeMode(j.SIMPLE_SELECT);
      }, clickActiveFeature: function(t2) {
        t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), t2.feature.changed();
      }, onSetup: function(t2) {
        var e3 = t2.featureId, n2 = this.getFeature(e3);
        if (!n2)
          throw new Error("You must provide a featureId to enter direct_select mode");
        if (n2.type === L)
          throw new TypeError("direct_select mode doesn't handle point features");
        var o2 = { featureId: e3, feature: n2, dragMoveLocation: t2.startPos || null, dragMoving: false, canDragMove: false, selectedCoordPaths: t2.coordPath ? [t2.coordPath] : [] };
        return this.setSelectedCoordinates(this.pathsToCoordinates(e3, o2.selectedCoordPaths)), this.setSelected(e3), Gt(this), this.setActionableState({ trash: true }), o2;
      }, onStop: function() {
        Jt(this), this.clearSelectedCoordinates();
      }, toDisplayFeatures: function(t2, e3, n2) {
        t2.featureId === e3.properties.id ? (e3.properties.active = Z, n2(e3), Vt(e3, { map: this.map, midpoints: true, selectedPaths: t2.selectedCoordPaths }).forEach(n2)) : (e3.properties.active = K, n2(e3)), this.fireActionable(t2);
      }, onTrash: function(t2) {
        t2.selectedCoordPaths.sort(function(t3, e3) {
          return e3.localeCompare(t3, "en", { numeric: true });
        }).forEach(function(e3) {
          return t2.feature.removeCoordinate(e3);
        }), this.fireUpdate(), t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), this.fireActionable(t2), false === t2.feature.isValid() && (this.deleteFeature([t2.featureId]), this.changeMode(j.SIMPLE_SELECT, {}));
      }, onMouseMove: function(t2, e3) {
        var n2 = Ft(e3), o2 = re(e3), r2 = 0 === t2.selectedCoordPaths.length;
        return n2 && r2 || o2 && !r2 ? this.updateUIClasses({ mouse: _ }) : this.updateUIClasses({ mouse: C }), this.stopDragging(t2), true;
      }, onMouseOut: function(t2) {
        return t2.dragMoving && this.fireUpdate(), true;
      } };
      ae.onTouchStart = ae.onMouseDown = function(t2, e3) {
        return re(e3) ? this.onVertex(t2, e3) : Ft(e3) ? this.onFeature(t2, e3) : ie(e3) ? this.onMidpoint(t2, e3) : void 0;
      }, ae.onDrag = function(t2, e3) {
        if (true === t2.canDragMove) {
          t2.dragMoving = true, e3.originalEvent.stopPropagation();
          var n2 = { lng: e3.lngLat.lng - t2.dragMoveLocation.lng, lat: e3.lngLat.lat - t2.dragMoveLocation.lat };
          t2.selectedCoordPaths.length > 0 ? this.dragVertex(t2, e3, n2) : this.dragFeature(t2, e3, n2), t2.dragMoveLocation = e3.lngLat;
        }
      }, ae.onClick = function(t2, e3) {
        return kt(e3) ? this.clickNoTarget(t2, e3) : Ft(e3) ? this.clickActiveFeature(t2, e3) : Ot(e3) ? this.clickInactive(t2, e3) : void this.stopDragging(t2);
      }, ae.onTap = function(t2, e3) {
        return kt(e3) ? this.clickNoTarget(t2, e3) : Ft(e3) ? this.clickActiveFeature(t2, e3) : Ot(e3) ? this.clickInactive(t2, e3) : void 0;
      }, ae.onTouchEnd = ae.onMouseUp = function(t2) {
        t2.dragMoving && this.fireUpdate(), this.stopDragging(t2);
      };
      var se = {};
      function ue(t2, e3) {
        return !!t2.lngLat && (t2.lngLat.lng === e3[0] && t2.lngLat.lat === e3[1]);
      }
      se.onSetup = function() {
        var t2 = this.newFeature({ type: M, properties: {}, geometry: { type: L, coordinates: [] } });
        return this.addFeature(t2), this.clearSelectedFeatures(), this.updateUIClasses({ mouse: b }), this.activateUIButton(E.POINT), this.setActionableState({ trash: true }), { point: t2 };
      }, se.stopDrawingAndRemove = function(t2) {
        this.deleteFeature([t2.point.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT);
      }, se.onTap = se.onClick = function(t2, e3) {
        this.updateUIClasses({ mouse: _ }), t2.point.updateCoordinate("", e3.lngLat.lng, e3.lngLat.lat), this.map.fire(A, { features: [t2.point.toGeoJSON()] }), this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.point.id] });
      }, se.onStop = function(t2) {
        this.activateUIButton(), t2.point.getCoordinate().length || this.deleteFeature([t2.point.id], { silent: true });
      }, se.toDisplayFeatures = function(t2, e3, n2) {
        var o2 = e3.properties.id === t2.point.id;
        if (e3.properties.active = o2 ? Z : K, !o2)
          return n2(e3);
      }, se.onTrash = se.stopDrawingAndRemove, se.onKeyUp = function(t2, e3) {
        if (At(e3) || Dt(e3))
          return this.stopDrawingAndRemove(t2, e3);
      };
      var ce = { onSetup: function() {
        var t2 = this.newFeature({ type: M, properties: {}, geometry: { type: w, coordinates: [[]] } });
        return this.addFeature(t2), this.clearSelectedFeatures(), Gt(this), this.updateUIClasses({ mouse: b }), this.activateUIButton(E.POLYGON), this.setActionableState({ trash: true }), { polygon: t2, currentVertexPosition: 0 };
      }, clickAnywhere: function(t2, e3) {
        if (t2.currentVertexPosition > 0 && ue(e3, t2.polygon.coordinates[0][t2.currentVertexPosition - 1]))
          return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
        this.updateUIClasses({ mouse: b }), t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), t2.currentVertexPosition++, t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat);
      }, clickOnVertex: function(t2) {
        return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
      }, onMouseMove: function(t2, e3) {
        t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), Tt(e3) && this.updateUIClasses({ mouse: x });
      } };
      ce.onTap = ce.onClick = function(t2, e3) {
        return Tt(e3) ? this.clickOnVertex(t2, e3) : this.clickAnywhere(t2, e3);
      }, ce.onKeyUp = function(t2, e3) {
        At(e3) ? (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT)) : Dt(e3) && this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
      }, ce.onStop = function(t2) {
        this.updateUIClasses({ mouse: C }), Jt(this), this.activateUIButton(), void 0 !== this.getFeature(t2.polygon.id) && (t2.polygon.removeCoordinate("0." + t2.currentVertexPosition), t2.polygon.isValid() ? this.map.fire(A, { features: [t2.polygon.toGeoJSON()] }) : (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT, {}, { silent: true })));
      }, ce.toDisplayFeatures = function(t2, e3, n2) {
        var o2 = e3.properties.id === t2.polygon.id;
        if (e3.properties.active = o2 ? Z : K, !o2)
          return n2(e3);
        if (0 !== e3.geometry.coordinates.length) {
          var r2 = e3.geometry.coordinates[0].length;
          if (!(r2 < 3)) {
            if (e3.properties.meta = W, n2(Bt(t2.polygon.id, e3.geometry.coordinates[0][0], "0.0", false)), r2 > 3) {
              var i2 = e3.geometry.coordinates[0].length - 3;
              n2(Bt(t2.polygon.id, e3.geometry.coordinates[0][i2], "0." + i2, false));
            }
            if (r2 <= 4) {
              var a2 = [[e3.geometry.coordinates[0][0][0], e3.geometry.coordinates[0][0][1]], [e3.geometry.coordinates[0][1][0], e3.geometry.coordinates[0][1][1]]];
              if (n2({ type: M, properties: e3.properties, geometry: { coordinates: a2, type: I } }), 3 === r2)
                return;
            }
            return n2(e3);
          }
        }
      }, ce.onTrash = function(t2) {
        this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT);
      };
      var le = { onSetup: function(t2) {
        var e3, n2, o2 = (t2 = t2 || {}).featureId, r2 = "forward";
        if (o2) {
          if (!(e3 = this.getFeature(o2)))
            throw new Error("Could not find a feature with the provided featureId");
          var i2 = t2.from;
          if (i2 && "Feature" === i2.type && i2.geometry && "Point" === i2.geometry.type && (i2 = i2.geometry), i2 && "Point" === i2.type && i2.coordinates && 2 === i2.coordinates.length && (i2 = i2.coordinates), !i2 || !Array.isArray(i2))
            throw new Error("Please use the `from` property to indicate which point to continue the line from");
          var a2 = e3.coordinates.length - 1;
          if (e3.coordinates[a2][0] === i2[0] && e3.coordinates[a2][1] === i2[1])
            n2 = a2 + 1, e3.addCoordinate.apply(e3, [n2].concat(e3.coordinates[a2]));
          else {
            if (e3.coordinates[0][0] !== i2[0] || e3.coordinates[0][1] !== i2[1])
              throw new Error("`from` should match the point at either the start or the end of the provided LineString");
            r2 = "backwards", n2 = 0, e3.addCoordinate.apply(e3, [n2].concat(e3.coordinates[0]));
          }
        } else
          e3 = this.newFeature({ type: M, properties: {}, geometry: { type: I, coordinates: [] } }), n2 = 0, this.addFeature(e3);
        return this.clearSelectedFeatures(), Gt(this), this.updateUIClasses({ mouse: b }), this.activateUIButton(E.LINE), this.setActionableState({ trash: true }), { line: e3, currentVertexPosition: n2, direction: r2 };
      }, clickAnywhere: function(t2, e3) {
        if (t2.currentVertexPosition > 0 && ue(e3, t2.line.coordinates[t2.currentVertexPosition - 1]) || "backwards" === t2.direction && ue(e3, t2.line.coordinates[t2.currentVertexPosition + 1]))
          return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.line.id] });
        this.updateUIClasses({ mouse: b }), t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), "forward" === t2.direction ? (t2.currentVertexPosition++, t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat)) : t2.line.addCoordinate(0, e3.lngLat.lng, e3.lngLat.lat);
      }, clickOnVertex: function(t2) {
        return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.line.id] });
      }, onMouseMove: function(t2, e3) {
        t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), Tt(e3) && this.updateUIClasses({ mouse: x });
      } };
      le.onTap = le.onClick = function(t2, e3) {
        if (Tt(e3))
          return this.clickOnVertex(t2, e3);
        this.clickAnywhere(t2, e3);
      }, le.onKeyUp = function(t2, e3) {
        Dt(e3) ? this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.line.id] }) : At(e3) && (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT));
      }, le.onStop = function(t2) {
        Jt(this), this.activateUIButton(), void 0 !== this.getFeature(t2.line.id) && (t2.line.removeCoordinate("" + t2.currentVertexPosition), t2.line.isValid() ? this.map.fire(A, { features: [t2.line.toGeoJSON()] }) : (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT, {}, { silent: true })));
      }, le.onTrash = function(t2) {
        this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT);
      }, le.toDisplayFeatures = function(t2, e3, n2) {
        var o2 = e3.properties.id === t2.line.id;
        if (e3.properties.active = o2 ? Z : K, !o2)
          return n2(e3);
        e3.geometry.coordinates.length < 2 || (e3.properties.meta = W, n2(Bt(t2.line.id, e3.geometry.coordinates["forward" === t2.direction ? e3.geometry.coordinates.length - 2 : 1], "" + ("forward" === t2.direction ? e3.geometry.coordinates.length - 2 : 1), false)), n2(e3));
      };
      var de = { simple_select: oe, direct_select: ae, draw_point: se, draw_polygon: ce, draw_line_string: le }, pe = { defaultMode: j.SIMPLE_SELECT, keybindings: true, touchEnabled: true, clickBuffer: 2, touchBuffer: 25, boxSelect: true, displayControlsDefault: true, styles: [{ id: "gl-draw-polygon-fill-inactive", type: "fill", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], paint: { "fill-color": "#3bb2d0", "fill-outline-color": "#3bb2d0", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-fill-active", type: "fill", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#fbb03b", "fill-outline-color": "#fbb03b", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-midpoint", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-stroke-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-polygon-stroke-active", type: "line", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-line-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-line-active", type: "line", filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-polygon-and-line-vertex-stroke-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-color": "#fff" } }, { id: "gl-draw-polygon-and-line-vertex-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-point-point-stroke-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-opacity": 1, "circle-color": "#fff" } }, { id: "gl-draw-point-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#3bb2d0" } }, { id: "gl-draw-point-stroke-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]], paint: { "circle-radius": 7, "circle-color": "#fff" } }, { id: "gl-draw-point-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]], paint: { "circle-radius": 5, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-fill-static", type: "fill", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#404040", "fill-outline-color": "#404040", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-stroke-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-line-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-point-static", type: "circle", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]], paint: { "circle-radius": 5, "circle-color": "#404040" } }], modes: de, controls: {}, userProperties: false }, fe = { point: true, line_string: true, polygon: true, trash: true, combine_features: true, uncombine_features: true }, he = { point: false, line_string: false, polygon: false, trash: false, combine_features: false, uncombine_features: false };
      function ge(t2, e3) {
        return t2.map(function(t3) {
          return t3.source ? t3 : Mt(t3, { id: t3.id + "." + e3, source: "hot" === e3 ? v : m });
        });
      }
      var ye = ut(function(t2, e3) {
        var n2 = "[object Arguments]", o2 = "[object Map]", r2 = "[object Object]", i2 = "[object Set]", a2 = /^\[object .+?Constructor\]$/, s2 = /^(?:0|[1-9]\d*)$/, u2 = {};
        u2["[object Float32Array]"] = u2["[object Float64Array]"] = u2["[object Int8Array]"] = u2["[object Int16Array]"] = u2["[object Int32Array]"] = u2["[object Uint8Array]"] = u2["[object Uint8ClampedArray]"] = u2["[object Uint16Array]"] = u2["[object Uint32Array]"] = true, u2[n2] = u2["[object Array]"] = u2["[object ArrayBuffer]"] = u2["[object Boolean]"] = u2["[object DataView]"] = u2["[object Date]"] = u2["[object Error]"] = u2["[object Function]"] = u2[o2] = u2["[object Number]"] = u2[r2] = u2["[object RegExp]"] = u2[i2] = u2["[object String]"] = u2["[object WeakMap]"] = false;
        var c2 = "object" == typeof global && global && global.Object === Object && global, l2 = "object" == typeof self && self && self.Object === Object && self, d2 = c2 || l2 || Function("return this")(), p2 = e3 && !e3.nodeType && e3, f2 = p2 && t2 && !t2.nodeType && t2, h2 = f2 && f2.exports === p2, g2 = h2 && c2.process, y2 = function() {
          try {
            return g2 && g2.binding && g2.binding("util");
          } catch (t3) {
          }
        }(), v2 = y2 && y2.isTypedArray;
        function m2(t3, e4) {
          for (var n3 = -1, o3 = null == t3 ? 0 : t3.length; ++n3 < o3; )
            if (e4(t3[n3], n3, t3))
              return true;
          return false;
        }
        function b2(t3) {
          var e4 = -1, n3 = Array(t3.size);
          return t3.forEach(function(t4, o3) {
            n3[++e4] = [o3, t4];
          }), n3;
        }
        function _2(t3) {
          var e4 = -1, n3 = Array(t3.size);
          return t3.forEach(function(t4) {
            n3[++e4] = t4;
          }), n3;
        }
        var S2, x2, C2, E2 = Array.prototype, M2 = Function.prototype, w2 = Object.prototype, I2 = d2["__core-js_shared__"], L2 = M2.toString, P2 = w2.hasOwnProperty, F2 = (S2 = /[^.]+$/.exec(I2 && I2.keys && I2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + S2 : "", O2 = w2.toString, k2 = RegExp("^" + L2.call(P2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), T2 = h2 ? d2.Buffer : void 0, j2 = d2.Symbol, A2 = d2.Uint8Array, D2 = w2.propertyIsEnumerable, N2 = E2.splice, U2 = j2 ? j2.toStringTag : void 0, R2 = Object.getOwnPropertySymbols, B2 = T2 ? T2.isBuffer : void 0, V2 = (x2 = Object.keys, C2 = Object, function(t3) {
          return x2(C2(t3));
        }), J2 = yt2(d2, "DataView"), G2 = yt2(d2, "Map"), z2 = yt2(d2, "Promise"), $2 = yt2(d2, "Set"), W2 = yt2(d2, "WeakMap"), q2 = yt2(Object, "create"), Y2 = _t2(J2), Z2 = _t2(G2), K2 = _t2(z2), X2 = _t2($2), H2 = _t2(W2), Q2 = j2 ? j2.prototype : void 0, tt2 = Q2 ? Q2.valueOf : void 0;
        function et2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.clear(); ++e4 < n3; ) {
            var o3 = t3[e4];
            this.set(o3[0], o3[1]);
          }
        }
        function nt2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.clear(); ++e4 < n3; ) {
            var o3 = t3[e4];
            this.set(o3[0], o3[1]);
          }
        }
        function ot2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.clear(); ++e4 < n3; ) {
            var o3 = t3[e4];
            this.set(o3[0], o3[1]);
          }
        }
        function rt2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.__data__ = new ot2(); ++e4 < n3; )
            this.add(t3[e4]);
        }
        function it2(t3) {
          var e4 = this.__data__ = new nt2(t3);
          this.size = e4.size;
        }
        function at2(t3, e4) {
          var n3 = Ct2(t3), o3 = !n3 && xt2(t3), r3 = !n3 && !o3 && Et2(t3), i3 = !n3 && !o3 && !r3 && Pt2(t3), a3 = n3 || o3 || r3 || i3, s3 = a3 ? function(t4, e5) {
            for (var n4 = -1, o4 = Array(t4); ++n4 < t4; )
              o4[n4] = e5(n4);
            return o4;
          }(t3.length, String) : [], u3 = s3.length;
          for (var c3 in t3)
            !e4 && !P2.call(t3, c3) || a3 && ("length" == c3 || r3 && ("offset" == c3 || "parent" == c3) || i3 && ("buffer" == c3 || "byteLength" == c3 || "byteOffset" == c3) || bt2(c3, u3)) || s3.push(c3);
          return s3;
        }
        function st2(t3, e4) {
          for (var n3 = t3.length; n3--; )
            if (St2(t3[n3][0], e4))
              return n3;
          return -1;
        }
        function ut2(t3) {
          return null == t3 ? void 0 === t3 ? "[object Undefined]" : "[object Null]" : U2 && U2 in Object(t3) ? function(t4) {
            var e4 = P2.call(t4, U2), n3 = t4[U2];
            try {
              t4[U2] = void 0;
              var o3 = true;
            } catch (t5) {
            }
            var r3 = O2.call(t4);
            o3 && (e4 ? t4[U2] = n3 : delete t4[U2]);
            return r3;
          }(t3) : function(t4) {
            return O2.call(t4);
          }(t3);
        }
        function ct2(t3) {
          return Lt2(t3) && ut2(t3) == n2;
        }
        function lt2(t3, e4, a3, s3, u3) {
          return t3 === e4 || (null == t3 || null == e4 || !Lt2(t3) && !Lt2(e4) ? t3 != t3 && e4 != e4 : function(t4, e5, a4, s4, u4, c3) {
            var l3 = Ct2(t4), d3 = Ct2(e5), p3 = l3 ? "[object Array]" : mt2(t4), f3 = d3 ? "[object Array]" : mt2(e5), h3 = (p3 = p3 == n2 ? r2 : p3) == r2, g3 = (f3 = f3 == n2 ? r2 : f3) == r2, y3 = p3 == f3;
            if (y3 && Et2(t4)) {
              if (!Et2(e5))
                return false;
              l3 = true, h3 = false;
            }
            if (y3 && !h3)
              return c3 || (c3 = new it2()), l3 || Pt2(t4) ? ft2(t4, e5, a4, s4, u4, c3) : function(t5, e6, n3, r3, a5, s5, u5) {
                switch (n3) {
                  case "[object DataView]":
                    if (t5.byteLength != e6.byteLength || t5.byteOffset != e6.byteOffset)
                      return false;
                    t5 = t5.buffer, e6 = e6.buffer;
                  case "[object ArrayBuffer]":
                    return !(t5.byteLength != e6.byteLength || !s5(new A2(t5), new A2(e6)));
                  case "[object Boolean]":
                  case "[object Date]":
                  case "[object Number]":
                    return St2(+t5, +e6);
                  case "[object Error]":
                    return t5.name == e6.name && t5.message == e6.message;
                  case "[object RegExp]":
                  case "[object String]":
                    return t5 == e6 + "";
                  case o2:
                    var c4 = b2;
                  case i2:
                    var l4 = 1 & r3;
                    if (c4 || (c4 = _2), t5.size != e6.size && !l4)
                      return false;
                    var d4 = u5.get(t5);
                    if (d4)
                      return d4 == e6;
                    r3 |= 2, u5.set(t5, e6);
                    var p4 = ft2(c4(t5), c4(e6), r3, a5, s5, u5);
                    return u5.delete(t5), p4;
                  case "[object Symbol]":
                    if (tt2)
                      return tt2.call(t5) == tt2.call(e6);
                }
                return false;
              }(t4, e5, p3, a4, s4, u4, c3);
            if (!(1 & a4)) {
              var v3 = h3 && P2.call(t4, "__wrapped__"), m3 = g3 && P2.call(e5, "__wrapped__");
              if (v3 || m3) {
                var S3 = v3 ? t4.value() : t4, x3 = m3 ? e5.value() : e5;
                return c3 || (c3 = new it2()), u4(S3, x3, a4, s4, c3);
              }
            }
            if (!y3)
              return false;
            return c3 || (c3 = new it2()), function(t5, e6, n3, o3, r3, i3) {
              var a5 = 1 & n3, s5 = ht2(t5), u5 = s5.length, c4 = ht2(e6).length;
              if (u5 != c4 && !a5)
                return false;
              var l4 = u5;
              for (; l4--; ) {
                var d4 = s5[l4];
                if (!(a5 ? d4 in e6 : P2.call(e6, d4)))
                  return false;
              }
              var p4 = i3.get(t5);
              if (p4 && i3.get(e6))
                return p4 == e6;
              var f4 = true;
              i3.set(t5, e6), i3.set(e6, t5);
              var h4 = a5;
              for (; ++l4 < u5; ) {
                d4 = s5[l4];
                var g4 = t5[d4], y4 = e6[d4];
                if (o3)
                  var v4 = a5 ? o3(y4, g4, d4, e6, t5, i3) : o3(g4, y4, d4, t5, e6, i3);
                if (!(void 0 === v4 ? g4 === y4 || r3(g4, y4, n3, o3, i3) : v4)) {
                  f4 = false;
                  break;
                }
                h4 || (h4 = "constructor" == d4);
              }
              if (f4 && !h4) {
                var m4 = t5.constructor, b3 = e6.constructor;
                m4 == b3 || !("constructor" in t5) || !("constructor" in e6) || "function" == typeof m4 && m4 instanceof m4 && "function" == typeof b3 && b3 instanceof b3 || (f4 = false);
              }
              return i3.delete(t5), i3.delete(e6), f4;
            }(t4, e5, a4, s4, u4, c3);
          }(t3, e4, a3, s3, lt2, u3));
        }
        function dt2(t3) {
          return !(!It2(t3) || function(t4) {
            return !!F2 && F2 in t4;
          }(t3)) && (Mt2(t3) ? k2 : a2).test(_t2(t3));
        }
        function pt2(t3) {
          if (n3 = (e4 = t3) && e4.constructor, o3 = "function" == typeof n3 && n3.prototype || w2, e4 !== o3)
            return V2(t3);
          var e4, n3, o3, r3 = [];
          for (var i3 in Object(t3))
            P2.call(t3, i3) && "constructor" != i3 && r3.push(i3);
          return r3;
        }
        function ft2(t3, e4, n3, o3, r3, i3) {
          var a3 = 1 & n3, s3 = t3.length, u3 = e4.length;
          if (s3 != u3 && !(a3 && u3 > s3))
            return false;
          var c3 = i3.get(t3);
          if (c3 && i3.get(e4))
            return c3 == e4;
          var l3 = -1, d3 = true, p3 = 2 & n3 ? new rt2() : void 0;
          for (i3.set(t3, e4), i3.set(e4, t3); ++l3 < s3; ) {
            var f3 = t3[l3], h3 = e4[l3];
            if (o3)
              var g3 = a3 ? o3(h3, f3, l3, e4, t3, i3) : o3(f3, h3, l3, t3, e4, i3);
            if (void 0 !== g3) {
              if (g3)
                continue;
              d3 = false;
              break;
            }
            if (p3) {
              if (!m2(e4, function(t4, e5) {
                if (a4 = e5, !p3.has(a4) && (f3 === t4 || r3(f3, t4, n3, o3, i3)))
                  return p3.push(e5);
                var a4;
              })) {
                d3 = false;
                break;
              }
            } else if (f3 !== h3 && !r3(f3, h3, n3, o3, i3)) {
              d3 = false;
              break;
            }
          }
          return i3.delete(t3), i3.delete(e4), d3;
        }
        function ht2(t3) {
          return function(t4, e4, n3) {
            var o3 = e4(t4);
            return Ct2(t4) ? o3 : function(t5, e5) {
              for (var n4 = -1, o4 = e5.length, r3 = t5.length; ++n4 < o4; )
                t5[r3 + n4] = e5[n4];
              return t5;
            }(o3, n3(t4));
          }(t3, Ft2, vt2);
        }
        function gt2(t3, e4) {
          var n3, o3, r3 = t3.__data__;
          return ("string" == (o3 = typeof (n3 = e4)) || "number" == o3 || "symbol" == o3 || "boolean" == o3 ? "__proto__" !== n3 : null === n3) ? r3["string" == typeof e4 ? "string" : "hash"] : r3.map;
        }
        function yt2(t3, e4) {
          var n3 = function(t4, e5) {
            return null == t4 ? void 0 : t4[e5];
          }(t3, e4);
          return dt2(n3) ? n3 : void 0;
        }
        et2.prototype.clear = function() {
          this.__data__ = q2 ? q2(null) : {}, this.size = 0;
        }, et2.prototype.delete = function(t3) {
          var e4 = this.has(t3) && delete this.__data__[t3];
          return this.size -= e4 ? 1 : 0, e4;
        }, et2.prototype.get = function(t3) {
          var e4 = this.__data__;
          if (q2) {
            var n3 = e4[t3];
            return "__lodash_hash_undefined__" === n3 ? void 0 : n3;
          }
          return P2.call(e4, t3) ? e4[t3] : void 0;
        }, et2.prototype.has = function(t3) {
          var e4 = this.__data__;
          return q2 ? void 0 !== e4[t3] : P2.call(e4, t3);
        }, et2.prototype.set = function(t3, e4) {
          var n3 = this.__data__;
          return this.size += this.has(t3) ? 0 : 1, n3[t3] = q2 && void 0 === e4 ? "__lodash_hash_undefined__" : e4, this;
        }, nt2.prototype.clear = function() {
          this.__data__ = [], this.size = 0;
        }, nt2.prototype.delete = function(t3) {
          var e4 = this.__data__, n3 = st2(e4, t3);
          return !(n3 < 0) && (n3 == e4.length - 1 ? e4.pop() : N2.call(e4, n3, 1), --this.size, true);
        }, nt2.prototype.get = function(t3) {
          var e4 = this.__data__, n3 = st2(e4, t3);
          return n3 < 0 ? void 0 : e4[n3][1];
        }, nt2.prototype.has = function(t3) {
          return st2(this.__data__, t3) > -1;
        }, nt2.prototype.set = function(t3, e4) {
          var n3 = this.__data__, o3 = st2(n3, t3);
          return o3 < 0 ? (++this.size, n3.push([t3, e4])) : n3[o3][1] = e4, this;
        }, ot2.prototype.clear = function() {
          this.size = 0, this.__data__ = { hash: new et2(), map: new (G2 || nt2)(), string: new et2() };
        }, ot2.prototype.delete = function(t3) {
          var e4 = gt2(this, t3).delete(t3);
          return this.size -= e4 ? 1 : 0, e4;
        }, ot2.prototype.get = function(t3) {
          return gt2(this, t3).get(t3);
        }, ot2.prototype.has = function(t3) {
          return gt2(this, t3).has(t3);
        }, ot2.prototype.set = function(t3, e4) {
          var n3 = gt2(this, t3), o3 = n3.size;
          return n3.set(t3, e4), this.size += n3.size == o3 ? 0 : 1, this;
        }, rt2.prototype.add = rt2.prototype.push = function(t3) {
          return this.__data__.set(t3, "__lodash_hash_undefined__"), this;
        }, rt2.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, it2.prototype.clear = function() {
          this.__data__ = new nt2(), this.size = 0;
        }, it2.prototype.delete = function(t3) {
          var e4 = this.__data__, n3 = e4.delete(t3);
          return this.size = e4.size, n3;
        }, it2.prototype.get = function(t3) {
          return this.__data__.get(t3);
        }, it2.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, it2.prototype.set = function(t3, e4) {
          var n3 = this.__data__;
          if (n3 instanceof nt2) {
            var o3 = n3.__data__;
            if (!G2 || o3.length < 199)
              return o3.push([t3, e4]), this.size = ++n3.size, this;
            n3 = this.__data__ = new ot2(o3);
          }
          return n3.set(t3, e4), this.size = n3.size, this;
        };
        var vt2 = R2 ? function(t3) {
          return null == t3 ? [] : (t3 = Object(t3), function(t4, e4) {
            for (var n3 = -1, o3 = null == t4 ? 0 : t4.length, r3 = 0, i3 = []; ++n3 < o3; ) {
              var a3 = t4[n3];
              e4(a3, n3, t4) && (i3[r3++] = a3);
            }
            return i3;
          }(R2(t3), function(e4) {
            return D2.call(t3, e4);
          }));
        } : function() {
          return [];
        }, mt2 = ut2;
        function bt2(t3, e4) {
          return !!(e4 = null == e4 ? 9007199254740991 : e4) && ("number" == typeof t3 || s2.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e4;
        }
        function _t2(t3) {
          if (null != t3) {
            try {
              return L2.call(t3);
            } catch (t4) {
            }
            try {
              return t3 + "";
            } catch (t4) {
            }
          }
          return "";
        }
        function St2(t3, e4) {
          return t3 === e4 || t3 != t3 && e4 != e4;
        }
        (J2 && "[object DataView]" != mt2(new J2(new ArrayBuffer(1))) || G2 && mt2(new G2()) != o2 || z2 && "[object Promise]" != mt2(z2.resolve()) || $2 && mt2(new $2()) != i2 || W2 && "[object WeakMap]" != mt2(new W2())) && (mt2 = function(t3) {
          var e4 = ut2(t3), n3 = e4 == r2 ? t3.constructor : void 0, a3 = n3 ? _t2(n3) : "";
          if (a3)
            switch (a3) {
              case Y2:
                return "[object DataView]";
              case Z2:
                return o2;
              case K2:
                return "[object Promise]";
              case X2:
                return i2;
              case H2:
                return "[object WeakMap]";
            }
          return e4;
        });
        var xt2 = ct2(function() {
          return arguments;
        }()) ? ct2 : function(t3) {
          return Lt2(t3) && P2.call(t3, "callee") && !D2.call(t3, "callee");
        }, Ct2 = Array.isArray;
        var Et2 = B2 || function() {
          return false;
        };
        function Mt2(t3) {
          if (!It2(t3))
            return false;
          var e4 = ut2(t3);
          return "[object Function]" == e4 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
        }
        function wt2(t3) {
          return "number" == typeof t3 && t3 > -1 && t3 % 1 == 0 && t3 <= 9007199254740991;
        }
        function It2(t3) {
          var e4 = typeof t3;
          return null != t3 && ("object" == e4 || "function" == e4);
        }
        function Lt2(t3) {
          return null != t3 && "object" == typeof t3;
        }
        var Pt2 = v2 ? function(t3) {
          return function(e4) {
            return t3(e4);
          };
        }(v2) : function(t3) {
          return Lt2(t3) && wt2(t3.length) && !!u2[ut2(t3)];
        };
        function Ft2(t3) {
          return null != (e4 = t3) && wt2(e4.length) && !Mt2(e4) ? at2(t3) : pt2(t3);
          var e4;
        }
        t2.exports = function(t3, e4) {
          return lt2(t3, e4);
        };
      });
      var ve = { Polygon: ft, LineString: pt, Point: dt, MultiPolygon: yt, MultiLineString: yt, MultiPoint: yt };
      function me(t2, e3) {
        return e3.modes = j, e3.getFeatureIdsAt = function(e4) {
          return nt.click({ point: e4 }, null, t2).map(function(t3) {
            return t3.properties.id;
          });
        }, e3.getSelectedIds = function() {
          return t2.store.getSelectedIds();
        }, e3.getSelected = function() {
          return { type: P, features: t2.store.getSelectedIds().map(function(e4) {
            return t2.store.get(e4);
          }).map(function(t3) {
            return t3.toGeoJSON();
          }) };
        }, e3.getSelectedPoints = function() {
          return { type: P, features: t2.store.getSelectedCoordinates().map(function(t3) {
            return { type: M, properties: {}, geometry: { type: L, coordinates: t3.coordinates } };
          }) };
        }, e3.set = function(n2) {
          if (void 0 === n2.type || n2.type !== P || !Array.isArray(n2.features))
            throw new Error("Invalid FeatureCollection");
          var o2 = t2.store.createRenderBatch(), r2 = t2.store.getAllIds().slice(), i2 = e3.add(n2), a2 = new tt(i2);
          return (r2 = r2.filter(function(t3) {
            return !a2.has(t3);
          })).length && e3.delete(r2), o2(), i2;
        }, e3.add = function(e4) {
          var n2 = JSON.parse(JSON.stringify(zt(e4))).features.map(function(e5) {
            if (e5.id = e5.id || ct(), null === e5.geometry)
              throw new Error("Invalid geometry: null");
            if (void 0 === t2.store.get(e5.id) || t2.store.get(e5.id).type !== e5.geometry.type) {
              var n3 = ve[e5.geometry.type];
              if (void 0 === n3)
                throw new Error("Invalid geometry type: " + e5.geometry.type + ".");
              var o2 = new n3(t2, e5);
              t2.store.add(o2);
            } else {
              var r2 = t2.store.get(e5.id);
              r2.properties = e5.properties, ye(r2.getCoordinates(), e5.geometry.coordinates) || r2.incomingCoords(e5.geometry.coordinates);
            }
            return e5.id;
          });
          return t2.store.render(), n2;
        }, e3.get = function(e4) {
          var n2 = t2.store.get(e4);
          if (n2)
            return n2.toGeoJSON();
        }, e3.getAll = function() {
          return { type: P, features: t2.store.getAll().map(function(t3) {
            return t3.toGeoJSON();
          }) };
        }, e3.delete = function(n2) {
          return t2.store.delete(n2, { silent: true }), e3.getMode() !== j.DIRECT_SELECT || t2.store.getSelectedIds().length ? t2.store.render() : t2.events.changeMode(j.SIMPLE_SELECT, void 0, { silent: true }), e3;
        }, e3.deleteAll = function() {
          return t2.store.delete(t2.store.getAllIds(), { silent: true }), e3.getMode() === j.DIRECT_SELECT ? t2.events.changeMode(j.SIMPLE_SELECT, void 0, { silent: true }) : t2.store.render(), e3;
        }, e3.changeMode = function(n2, o2) {
          return void 0 === o2 && (o2 = {}), n2 === j.SIMPLE_SELECT && e3.getMode() === j.SIMPLE_SELECT ? (r2 = o2.featureIds || [], i2 = t2.store.getSelectedIds(), r2.length === i2.length && JSON.stringify(r2.map(function(t3) {
            return t3;
          }).sort()) === JSON.stringify(i2.map(function(t3) {
            return t3;
          }).sort()) || (t2.store.setSelected(o2.featureIds, { silent: true }), t2.store.render()), e3) : (n2 === j.DIRECT_SELECT && e3.getMode() === j.DIRECT_SELECT && o2.featureId === t2.store.getSelectedIds()[0] || t2.events.changeMode(n2, o2, { silent: true }), e3);
          var r2, i2;
        }, e3.getMode = function() {
          return t2.events.getMode();
        }, e3.trash = function() {
          return t2.events.trash({ silent: true }), e3;
        }, e3.combineFeatures = function() {
          return t2.events.combineFeatures({ silent: true }), e3;
        }, e3.uncombineFeatures = function() {
          return t2.events.uncombineFeatures({ silent: true }), e3;
        }, e3.setFeatureProperty = function(n2, o2, r2) {
          return t2.store.setFeatureProperty(n2, o2, r2), e3;
        }, e3;
      }
      var be = function(t2, e3) {
        var n2 = { options: t2 = function(t3) {
          void 0 === t3 && (t3 = {});
          var e4 = Mt(t3);
          return t3.controls || (e4.controls = {}), false === t3.displayControlsDefault ? e4.controls = Mt(he, t3.controls) : e4.controls = Mt(fe, t3.controls), (e4 = Mt(pe, e4)).styles = ge(e4.styles, "cold").concat(ge(e4.styles, "hot")), e4;
        }(t2) };
        e3 = me(n2, e3), n2.api = e3;
        var o2 = Lt(n2);
        return e3.onAdd = o2.onAdd, e3.onRemove = o2.onRemove, e3.types = E, e3.options = t2, e3;
      };
      function _e(t2) {
        be(t2, this);
      }
      return _e.modes = de, _e;
    });
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/constants.js
var require_constants = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/constants.js"(exports, module) {
    module.exports = {
      classes: {
        CONTROL_BASE: "mapboxgl-ctrl",
        CONTROL_PREFIX: "mapboxgl-ctrl-",
        CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn",
        CONTROL_BUTTON_LINE: "mapbox-gl-draw_line",
        CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon",
        CONTROL_BUTTON_POINT: "mapbox-gl-draw_point",
        CONTROL_BUTTON_TRASH: "mapbox-gl-draw_trash",
        CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine",
        CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine",
        CONTROL_GROUP: "mapboxgl-ctrl-group",
        ATTRIBUTION: "mapboxgl-ctrl-attrib",
        ACTIVE_BUTTON: "active",
        BOX_SELECT: "mapbox-gl-draw_boxselect"
      },
      sources: {
        HOT: "mapbox-gl-draw-hot",
        COLD: "mapbox-gl-draw-cold"
      },
      cursors: {
        ADD: "add",
        MOVE: "move",
        DRAG: "drag",
        POINTER: "pointer",
        NONE: "none"
      },
      types: {
        POLYGON: "polygon",
        LINE: "line_string",
        POINT: "point"
      },
      geojsonTypes: {
        FEATURE: "Feature",
        POLYGON: "Polygon",
        LINE_STRING: "LineString",
        POINT: "Point",
        FEATURE_COLLECTION: "FeatureCollection",
        MULTI_PREFIX: "Multi",
        MULTI_POINT: "MultiPoint",
        MULTI_LINE_STRING: "MultiLineString",
        MULTI_POLYGON: "MultiPolygon"
      },
      modes: {
        DRAW_LINE_STRING: "draw_line_string",
        DRAW_POLYGON: "draw_polygon",
        DRAW_POINT: "draw_point",
        SIMPLE_SELECT: "simple_select",
        DIRECT_SELECT: "direct_select",
        STATIC: "static"
      },
      events: {
        CREATE: "draw.create",
        DELETE: "draw.delete",
        UPDATE: "draw.update",
        SELECTION_CHANGE: "draw.selectionchange",
        MODE_CHANGE: "draw.modechange",
        ACTIONABLE: "draw.actionable",
        RENDER: "draw.render",
        COMBINE_FEATURES: "draw.combine",
        UNCOMBINE_FEATURES: "draw.uncombine"
      },
      updateActions: {
        MOVE: "move",
        CHANGE_COORDINATES: "change_coordinates"
      },
      meta: {
        FEATURE: "feature",
        MIDPOINT: "midpoint",
        VERTEX: "vertex"
      },
      activeStates: {
        ACTIVE: "true",
        INACTIVE: "false"
      },
      interactions: ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"],
      LAT_MIN: -90,
      LAT_RENDERED_MIN: -85,
      LAT_MAX: 90,
      LAT_RENDERED_MAX: 85,
      LNG_MIN: -270,
      LNG_MAX: 270
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/double_click_zoom.js
var require_double_click_zoom = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/double_click_zoom.js"(exports, module) {
    module.exports = {
      enable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue)
            return;
          if (!ctx._ctx.store.getInitialConfigValue("doubleClickZoom"))
            return;
          ctx.map.doubleClickZoom.enable();
        }, 0);
      },
      disable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.doubleClickZoom)
            return;
          ctx.map.doubleClickZoom.disable();
        }, 0);
      }
    };
  }
});

// node_modules/@turf/helpers/dist/js/index.js
var require_js = __commonJS({
  "node_modules/@turf/helpers/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.earthRadius = 63710088e-1;
    exports.factors = {
      centimeters: exports.earthRadius * 100,
      centimetres: exports.earthRadius * 100,
      degrees: exports.earthRadius / 111325,
      feet: exports.earthRadius * 3.28084,
      inches: exports.earthRadius * 39.37,
      kilometers: exports.earthRadius / 1e3,
      kilometres: exports.earthRadius / 1e3,
      meters: exports.earthRadius,
      metres: exports.earthRadius,
      miles: exports.earthRadius / 1609.344,
      millimeters: exports.earthRadius * 1e3,
      millimetres: exports.earthRadius * 1e3,
      nauticalmiles: exports.earthRadius / 1852,
      radians: 1,
      yards: exports.earthRadius * 1.0936
    };
    exports.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.37,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1e3,
      millimetres: 1e3,
      nauticalmiles: 1 / 1852,
      radians: 1 / exports.earthRadius,
      yards: 1.0936133
    };
    exports.areaFactors = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046
    };
    function feature2(geom, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var feat = { type: "Feature" };
      if (options.id === 0 || options.id) {
        feat.id = options.id;
      }
      if (options.bbox) {
        feat.bbox = options.bbox;
      }
      feat.properties = properties || {};
      feat.geometry = geom;
      return feat;
    }
    exports.feature = feature2;
    function geometry(type, coordinates, _options) {
      if (_options === void 0) {
        _options = {};
      }
      switch (type) {
        case "Point":
          return point2(coordinates).geometry;
        case "LineString":
          return lineString2(coordinates).geometry;
        case "Polygon":
          return polygon2(coordinates).geometry;
        case "MultiPoint":
          return multiPoint(coordinates).geometry;
        case "MultiLineString":
          return multiLineString(coordinates).geometry;
        case "MultiPolygon":
          return multiPolygon(coordinates).geometry;
        default:
          throw new Error(type + " is invalid");
      }
    }
    exports.geometry = geometry;
    function point2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (!coordinates) {
        throw new Error("coordinates is required");
      }
      if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
      }
      if (!isNumber2(coordinates[0]) || !isNumber2(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
      }
      var geom = {
        type: "Point",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.point = point2;
    function points(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return point2(coords, properties);
      }), options);
    }
    exports.points = points;
    function polygon2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
          if (ring[ring.length - 1][j] !== ring[0][j]) {
            throw new Error("First and last Position are not equivalent.");
          }
        }
      }
      var geom = {
        type: "Polygon",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.polygon = polygon2;
    function polygons(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return polygon2(coords, properties);
      }), options);
    }
    exports.polygons = polygons;
    function lineString2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
      }
      var geom = {
        type: "LineString",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.lineString = lineString2;
    function lineStrings(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return lineString2(coords, properties);
      }), options);
    }
    exports.lineStrings = lineStrings;
    function featureCollection(features, options) {
      if (options === void 0) {
        options = {};
      }
      var fc = { type: "FeatureCollection" };
      if (options.id) {
        fc.id = options.id;
      }
      if (options.bbox) {
        fc.bbox = options.bbox;
      }
      fc.features = features;
      return fc;
    }
    exports.featureCollection = featureCollection;
    function multiLineString(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiLineString",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiLineString = multiLineString;
    function multiPoint(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPoint",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiPoint = multiPoint;
    function multiPolygon(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPolygon",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiPolygon = multiPolygon;
    function geometryCollection(geometries, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "GeometryCollection",
        geometries
      };
      return feature2(geom, properties, options);
    }
    exports.geometryCollection = geometryCollection;
    function round(num, precision) {
      if (precision === void 0) {
        precision = 0;
      }
      if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
      }
      var multiplier = Math.pow(10, precision || 0);
      return Math.round(num * multiplier) / multiplier;
    }
    exports.round = round;
    function radiansToLength2(radians, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return radians * factor;
    }
    exports.radiansToLength = radiansToLength2;
    function lengthToRadians2(distance, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return distance / factor;
    }
    exports.lengthToRadians = lengthToRadians2;
    function lengthToDegrees(distance, units) {
      return radiansToDegrees2(lengthToRadians2(distance, units));
    }
    exports.lengthToDegrees = lengthToDegrees;
    function bearingToAzimuth(bearing2) {
      var angle = bearing2 % 360;
      if (angle < 0) {
        angle += 360;
      }
      return angle;
    }
    exports.bearingToAzimuth = bearingToAzimuth;
    function radiansToDegrees2(radians) {
      var degrees = radians % (2 * Math.PI);
      return degrees * 180 / Math.PI;
    }
    exports.radiansToDegrees = radiansToDegrees2;
    function degreesToRadians2(degrees) {
      var radians = degrees % 360;
      return radians * Math.PI / 180;
    }
    exports.degreesToRadians = degreesToRadians2;
    function convertLength(length2, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "kilometers";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(length2 >= 0)) {
        throw new Error("length must be a positive number");
      }
      return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
    }
    exports.convertLength = convertLength;
    function convertArea(area, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "meters";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(area >= 0)) {
        throw new Error("area must be a positive number");
      }
      var startFactor = exports.areaFactors[originalUnit];
      if (!startFactor) {
        throw new Error("invalid original units");
      }
      var finalFactor = exports.areaFactors[finalUnit];
      if (!finalFactor) {
        throw new Error("invalid final units");
      }
      return area / startFactor * finalFactor;
    }
    exports.convertArea = convertArea;
    function isNumber2(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num);
    }
    exports.isNumber = isNumber2;
    function isObject2(input) {
      return !!input && input.constructor === Object;
    }
    exports.isObject = isObject2;
    function validateBBox(bbox) {
      if (!bbox) {
        throw new Error("bbox is required");
      }
      if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
      }
      if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      }
      bbox.forEach(function(num) {
        if (!isNumber2(num)) {
          throw new Error("bbox must only contain numbers");
        }
      });
    }
    exports.validateBBox = validateBBox;
    function validateId(id) {
      if (!id) {
        throw new Error("id is required");
      }
      if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
      }
    }
    exports.validateId = validateId;
  }
});

// node_modules/@turf/invariant/dist/js/index.js
var require_js2 = __commonJS({
  "node_modules/@turf/invariant/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    function getCoord2(coord) {
      if (!coord) {
        throw new Error("coord is required");
      }
      if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
          return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
          return coord.coordinates;
        }
      }
      if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
      }
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    exports.getCoord = getCoord2;
    function getCoords2(coords) {
      if (Array.isArray(coords)) {
        return coords;
      }
      if (coords.type === "Feature") {
        if (coords.geometry !== null) {
          return coords.geometry.coordinates;
        }
      } else {
        if (coords.coordinates) {
          return coords.coordinates;
        }
      }
      throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
    }
    exports.getCoords = getCoords2;
    function containsNumber(coordinates) {
      if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
      }
      if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
      }
      throw new Error("coordinates must only contain numbers");
    }
    exports.containsNumber = containsNumber;
    function geojsonType(value, type, name) {
      if (!type || !name) {
        throw new Error("type and name required");
      }
      if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
      }
    }
    exports.geojsonType = geojsonType;
    function featureOf(feature2, type, name) {
      if (!feature2) {
        throw new Error("No feature passed");
      }
      if (!name) {
        throw new Error(".featureOf() requires a name");
      }
      if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
      }
      if (!feature2.geometry || feature2.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
      }
    }
    exports.featureOf = featureOf;
    function collectionOf(featureCollection, type, name) {
      if (!featureCollection) {
        throw new Error("No featureCollection passed");
      }
      if (!name) {
        throw new Error(".collectionOf() requires a name");
      }
      if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
      }
      for (var _i = 0, _a2 = featureCollection.features; _i < _a2.length; _i++) {
        var feature2 = _a2[_i];
        if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
          throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature2.geometry || feature2.geometry.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
        }
      }
    }
    exports.collectionOf = collectionOf;
    function getGeom2(geojson) {
      if (geojson.type === "Feature") {
        return geojson.geometry;
      }
      return geojson;
    }
    exports.getGeom = getGeom2;
    function getType(geojson, _name) {
      if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
      }
      if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
      }
      if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
      }
      return geojson.type;
    }
    exports.getType = getType;
  }
});

// node_modules/@turf/destination/dist/js/index.js
var require_js3 = __commonJS({
  "node_modules/@turf/destination/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js2();
    function destination2(origin, distance, bearing2, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(origin);
      var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);
      var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);
      var bearingRad = helpers_1.degreesToRadians(bearing2);
      var radians = helpers_1.lengthToRadians(distance, options.units);
      var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
      var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
      var lng = helpers_1.radiansToDegrees(longitude2);
      var lat = helpers_1.radiansToDegrees(latitude2);
      return helpers_1.point([lng, lat], options.properties);
    }
    exports.default = destination2;
  }
});

// node_modules/@turf/circle/dist/js/index.js
var require_js4 = __commonJS({
  "node_modules/@turf/circle/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var destination_1 = __importDefault(require_js3());
    var helpers_1 = require_js();
    function circle(center, radius, options) {
      if (options === void 0) {
        options = {};
      }
      var steps = options.steps || 64;
      var properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
      var coordinates = [];
      for (var i = 0; i < steps; i++) {
        coordinates.push(destination_1.default(center, radius, i * -360 / steps, options).geometry.coordinates);
      }
      coordinates.push(coordinates[0]);
      return helpers_1.polygon([coordinates], properties);
    }
    exports.default = circle;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/CircleMode.js
var require_CircleMode = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/CircleMode.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw2();
    var Constants = require_constants();
    var doubleClickZoom = require_double_click_zoom();
    var circle = require_js4().default;
    var CircleMode2 = { ...MapboxDraw2.modes.draw_polygon };
    var DEFAULT_RADIUS_IN_KM = 2;
    CircleMode2.onSetup = function(opts) {
      const polygon2 = this.newFeature({
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          isCircle: true,
          center: []
        },
        geometry: {
          type: Constants.geojsonTypes.POLYGON,
          coordinates: [[]]
        }
      });
      this.addFeature(polygon2);
      this.clearSelectedFeatures();
      doubleClickZoom.disable(this);
      this.updateUIClasses({ mouse: Constants.cursors.ADD });
      this.activateUIButton(Constants.types.POLYGON);
      this.setActionableState({
        trash: true
      });
      return {
        initialRadiusInKm: opts.initialRadiusInKm || DEFAULT_RADIUS_IN_KM,
        polygon: polygon2,
        currentVertexPosition: 0
      };
    };
    CircleMode2.clickAnywhere = function(state, e2) {
      if (state.currentVertexPosition === 0) {
        state.currentVertexPosition++;
        const center = [e2.lngLat.lng, e2.lngLat.lat];
        const circleFeature = circle(center, state.initialRadiusInKm);
        state.polygon.incomingCoords(circleFeature.geometry.coordinates);
        state.polygon.properties.center = center;
        state.polygon.properties.radiusInKm = state.initialRadiusInKm;
      }
      return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
    };
    module.exports = CircleMode2;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/drag_pan.js
var require_drag_pan = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/drag_pan.js"(exports, module) {
    module.exports = {
      enable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.dragPan || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue)
            return;
          if (!ctx._ctx.store.getInitialConfigValue("dragPan"))
            return;
          ctx.map.dragPan.enable();
        }, 0);
      },
      disable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.doubleClickZoom)
            return;
          ctx.map.dragPan.disable();
        }, 0);
      }
    };
  }
});

// node_modules/@turf/distance/dist/js/index.js
var require_js5 = __commonJS({
  "node_modules/@turf/distance/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var invariant_1 = require_js2();
    var helpers_1 = require_js();
    function distance(from, to, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(from);
      var coordinates2 = invariant_1.getCoord(to);
      var dLat = helpers_1.degreesToRadians(coordinates2[1] - coordinates1[1]);
      var dLon = helpers_1.degreesToRadians(coordinates2[0] - coordinates1[0]);
      var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
      var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
      var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
      return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
    }
    exports.default = distance;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/DragCircleMode.js
var require_DragCircleMode = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/DragCircleMode.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw2();
    var Constants = require_constants();
    var doubleClickZoom = require_double_click_zoom();
    var dragPan = require_drag_pan();
    var circle = require_js4().default;
    var distance = require_js5().default;
    var turfHelpers = require_js();
    var DragCircleMode = { ...MapboxDraw2.modes.draw_polygon };
    DragCircleMode.onSetup = function(opts) {
      const polygon2 = this.newFeature({
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          isCircle: true,
          center: []
        },
        geometry: {
          type: Constants.geojsonTypes.POLYGON,
          coordinates: [[]]
        }
      });
      this.addFeature(polygon2);
      this.clearSelectedFeatures();
      doubleClickZoom.disable(this);
      dragPan.disable(this);
      this.updateUIClasses({ mouse: Constants.cursors.ADD });
      this.activateUIButton(Constants.types.POLYGON);
      this.setActionableState({
        trash: true
      });
      return {
        polygon: polygon2,
        currentVertexPosition: 0
      };
    };
    DragCircleMode.onMouseDown = DragCircleMode.onTouchStart = function(state, e2) {
      const currentCenter = state.polygon.properties.center;
      if (currentCenter.length === 0) {
        state.polygon.properties.center = [e2.lngLat.lng, e2.lngLat.lat];
      }
    };
    DragCircleMode.onDrag = DragCircleMode.onMouseMove = function(state, e2) {
      const center = state.polygon.properties.center;
      if (center.length > 0) {
        const distanceInKm = distance(
          turfHelpers.point(center),
          turfHelpers.point([e2.lngLat.lng, e2.lngLat.lat]),
          { units: "kilometers" }
        );
        const circleFeature = circle(center, distanceInKm);
        state.polygon.incomingCoords(circleFeature.geometry.coordinates);
        state.polygon.properties.radiusInKm = distanceInKm;
      }
    };
    DragCircleMode.onMouseUp = DragCircleMode.onTouchEnd = function(state, e2) {
      dragPan.enable(this);
      return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
    };
    DragCircleMode.onClick = DragCircleMode.onTap = function(state, e2) {
      state.polygon.properties.center = [];
    };
    DragCircleMode.toDisplayFeatures = function(state, geojson, display) {
      const isActivePolygon = geojson.properties.id === state.polygon.id;
      geojson.properties.active = isActivePolygon ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      return display(geojson);
    };
    module.exports = DragCircleMode;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_vertex.js
var require_create_vertex = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_vertex.js"(exports, module) {
    var Constants = require_constants();
    module.exports = function(parentId, coordinates, path, selected) {
      return {
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          meta: Constants.meta.VERTEX,
          parent: parentId,
          coord_path: path,
          active: selected ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE
        },
        geometry: {
          type: Constants.geojsonTypes.POINT,
          coordinates
        }
      };
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_midpoint.js
var require_create_midpoint = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_midpoint.js"(exports, module) {
    var Constants = require_constants();
    module.exports = function(parent, startVertex, endVertex, map) {
      const startCoord = startVertex.geometry.coordinates;
      const endCoord = endVertex.geometry.coordinates;
      if (startCoord[1] > Constants.LAT_RENDERED_MAX || startCoord[1] < Constants.LAT_RENDERED_MIN || endCoord[1] > Constants.LAT_RENDERED_MAX || endCoord[1] < Constants.LAT_RENDERED_MIN) {
        return null;
      }
      const ptA = map.project([startCoord[0], startCoord[1]]);
      const ptB = map.project([endCoord[0], endCoord[1]]);
      const mid = map.unproject([(ptA.x + ptB.x) / 2, (ptA.y + ptB.y) / 2]);
      return {
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          meta: Constants.meta.MIDPOINT,
          parent,
          lng: mid.lng,
          lat: mid.lat,
          coord_path: endVertex.properties.coord_path
        },
        geometry: {
          type: Constants.geojsonTypes.POINT,
          coordinates: [mid.lng, mid.lat]
        }
      };
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points.js
var require_create_supplementary_points = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points.js"(exports, module) {
    var createVertex = require_create_vertex();
    var createMidpoint = require_create_midpoint();
    var Constants = require_constants();
    function createSupplementaryPoints(geojson, options = {}, basePath = null) {
      const { type, coordinates } = geojson.geometry;
      const featureId = geojson.properties && geojson.properties.id;
      let supplementaryPoints = [];
      if (type === Constants.geojsonTypes.POINT) {
        supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));
      } else if (type === Constants.geojsonTypes.POLYGON) {
        coordinates.forEach((line, lineIndex) => {
          processLine(line, basePath !== null ? `${basePath}.${lineIndex}` : String(lineIndex));
        });
      } else if (type === Constants.geojsonTypes.LINE_STRING) {
        processLine(coordinates, basePath);
      } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {
        processMultiGeometry();
      }
      function processLine(line, lineBasePath) {
        let firstPointString = "";
        let lastVertex = null;
        line.forEach((point2, pointIndex) => {
          const pointPath = lineBasePath !== void 0 && lineBasePath !== null ? `${lineBasePath}.${pointIndex}` : String(pointIndex);
          const vertex = createVertex(featureId, point2, pointPath, isSelectedPath(pointPath));
          if (options.midpoints && lastVertex) {
            const midpoint = createMidpoint(featureId, lastVertex, vertex, options.map);
            if (midpoint) {
              supplementaryPoints.push(midpoint);
            }
          }
          lastVertex = vertex;
          const stringifiedPoint = JSON.stringify(point2);
          if (firstPointString !== stringifiedPoint) {
            supplementaryPoints.push(vertex);
          }
          if (pointIndex === 0) {
            firstPointString = stringifiedPoint;
          }
        });
      }
      function isSelectedPath(path) {
        if (!options.selectedPaths)
          return false;
        return options.selectedPaths.indexOf(path) !== -1;
      }
      function processMultiGeometry() {
        const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, "");
        coordinates.forEach((subCoordinates, index) => {
          const subFeature = {
            type: Constants.geojsonTypes.FEATURE,
            properties: geojson.properties,
            geometry: {
              type: subType,
              coordinates: subCoordinates
            }
          };
          supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));
        });
      }
      return supplementaryPoints;
    }
    module.exports = createSupplementaryPoints;
  }
});

// node_modules/@mapbox/geojson-normalize/index.js
var require_geojson_normalize = __commonJS({
  "node_modules/@mapbox/geojson-normalize/index.js"(exports, module) {
    module.exports = normalize;
    var types = {
      Point: "geometry",
      MultiPoint: "geometry",
      LineString: "geometry",
      MultiLineString: "geometry",
      Polygon: "geometry",
      MultiPolygon: "geometry",
      GeometryCollection: "geometry",
      Feature: "feature",
      FeatureCollection: "featurecollection"
    };
    function normalize(gj) {
      if (!gj || !gj.type)
        return null;
      var type = types[gj.type];
      if (!type)
        return null;
      if (type === "geometry") {
        return {
          type: "FeatureCollection",
          features: [{
            type: "Feature",
            properties: {},
            geometry: gj
          }]
        };
      } else if (type === "feature") {
        return {
          type: "FeatureCollection",
          features: [gj]
        };
      } else if (type === "featurecollection") {
        return gj;
      }
    }
  }
});

// node_modules/geojson-flatten/dist/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  default: () => e
});
function e(t) {
  switch (t && t.type || null) {
    case "FeatureCollection":
      return t.features = t.features.reduce(function(t2, r) {
        return t2.concat(e(r));
      }, []), t;
    case "Feature":
      return t.geometry ? e(t.geometry).map(function(e2) {
        var r = { type: "Feature", properties: JSON.parse(JSON.stringify(t.properties)), geometry: e2 };
        return void 0 !== t.id && (r.id = t.id), r;
      }) : [t];
    case "MultiPoint":
      return t.coordinates.map(function(e2) {
        return { type: "Point", coordinates: e2 };
      });
    case "MultiPolygon":
      return t.coordinates.map(function(e2) {
        return { type: "Polygon", coordinates: e2 };
      });
    case "MultiLineString":
      return t.coordinates.map(function(e2) {
        return { type: "LineString", coordinates: e2 };
      });
    case "GeometryCollection":
      return t.geometries.map(e).reduce(function(e2, t2) {
        return e2.concat(t2);
      }, []);
    case "Point":
    case "Polygon":
    case "LineString":
      return [t];
  }
}
var init_index_es = __esm({
  "node_modules/geojson-flatten/dist/index.es.js"() {
  }
});

// node_modules/@mapbox/geojson-coords/flatten.js
var require_flatten = __commonJS({
  "node_modules/@mapbox/geojson-coords/flatten.js"(exports, module) {
    module.exports = function flatten(list) {
      return _flatten(list);
      function _flatten(list2) {
        if (Array.isArray(list2) && list2.length && typeof list2[0] === "number") {
          return [list2];
        }
        return list2.reduce(function(acc, item) {
          if (Array.isArray(item) && Array.isArray(item[0])) {
            return acc.concat(_flatten(item));
          } else {
            acc.push(item);
            return acc;
          }
        }, []);
      }
    };
  }
});

// node_modules/@mapbox/geojson-coords/index.js
var require_geojson_coords = __commonJS({
  "node_modules/@mapbox/geojson-coords/index.js"(exports, module) {
    var geojsonNormalize = require_geojson_normalize();
    var geojsonFlatten = (init_index_es(), __toCommonJS(index_es_exports));
    var flatten = require_flatten();
    if (!(geojsonFlatten instanceof Function))
      geojsonFlatten = geojsonFlatten.default;
    module.exports = function(_) {
      if (!_)
        return [];
      var normalized = geojsonFlatten(geojsonNormalize(_)), coordinates = [];
      normalized.features.forEach(function(feature2) {
        if (!feature2.geometry)
          return;
        coordinates = coordinates.concat(flatten(feature2.geometry.coordinates));
      });
      return coordinates;
    };
  }
});

// node_modules/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/traverse/index.js"(exports, module) {
    "use strict";
    function toS(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isDate(obj) {
      return toS(obj) === "[object Date]";
    }
    function isRegExp(obj) {
      return toS(obj) === "[object RegExp]";
    }
    function isError(obj) {
      return toS(obj) === "[object Error]";
    }
    function isBoolean(obj) {
      return toS(obj) === "[object Boolean]";
    }
    function isNumber2(obj) {
      return toS(obj) === "[object Number]";
    }
    function isString(obj) {
      return toS(obj) === "[object String]";
    }
    var isArray = Array.isArray || function isArray2(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    function forEach(xs, fn) {
      if (xs.forEach) {
        return xs.forEach(fn);
      }
      for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
      }
      return void 0;
    }
    var objectKeys = Object.keys || function keys(obj) {
      var res = [];
      for (var key in obj) {
        res.push(key);
      }
      return res;
    };
    var propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    function ownEnumerableKeys(obj) {
      var res = objectKeys(obj);
      if (getOwnPropertySymbols) {
        var symbols = getOwnPropertySymbols(obj);
        for (var i = 0; i < symbols.length; i++) {
          if (propertyIsEnumerable.call(obj, symbols[i])) {
            res.push(symbols[i]);
          }
        }
      }
      return res;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty || function(obj, key) {
      return key in obj;
    };
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (isArray(src)) {
          dst = [];
        } else if (isDate(src)) {
          dst = new Date(src.getTime ? src.getTime() : src);
        } else if (isRegExp(src)) {
          dst = new RegExp(src);
        } else if (isError(src)) {
          dst = { message: src.message };
        } else if (isBoolean(src) || isNumber2(src) || isString(src)) {
          dst = Object(src);
        } else if (Object.create && Object.getPrototypeOf) {
          dst = Object.create(Object.getPrototypeOf(src));
        } else if (src.constructor === Object) {
          dst = {};
        } else {
          var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};
          var T = function T2() {
          };
          T.prototype = proto;
          dst = new T();
        }
        forEach(ownEnumerableKeys(src), function(key) {
          dst[key] = src[key];
        });
        return dst;
      }
      return src;
    }
    function walk(root, cb, immutable) {
      var path = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var keepGoing = true;
        var state = {
          node,
          node_,
          path: [].concat(path),
          parent: parents[parents.length - 1],
          parents,
          key: path[path.length - 1],
          isRoot: path.length === 0,
          level: path.length,
          circular: null,
          update: function(x, stopHere) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
            if (stopHere) {
              keepGoing = false;
            }
          },
          delete: function(stopHere) {
            delete state.parent.node[state.key];
            if (stopHere) {
              keepGoing = false;
            }
          },
          remove: function(stopHere) {
            if (isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
            if (stopHere) {
              keepGoing = false;
            }
          },
          keys: null,
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          },
          block: function() {
            keepGoing = false;
          }
        };
        if (!alive) {
          return state;
        }
        function updateState() {
          if (typeof state.node === "object" && state.node !== null) {
            if (!state.keys || state.node_ !== state.node) {
              state.keys = ownEnumerableKeys(state.node);
            }
            state.isLeaf = state.keys.length === 0;
            for (var i = 0; i < parents.length; i++) {
              if (parents[i].node_ === node_) {
                state.circular = parents[i];
                break;
              }
            }
          } else {
            state.isLeaf = true;
            state.keys = null;
          }
          state.notLeaf = !state.isLeaf;
          state.notRoot = !state.isRoot;
        }
        updateState();
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update) {
          state.update(ret);
        }
        if (modifiers.before) {
          modifiers.before.call(state, state.node);
        }
        if (!keepGoing) {
          return state;
        }
        if (typeof state.node === "object" && state.node !== null && !state.circular) {
          parents.push(state);
          updateState();
          forEach(state.keys, function(key, i) {
            path.push(key);
            if (modifiers.pre) {
              modifiers.pre.call(state, state.node[key], key);
            }
            var child = walker(state.node[key]);
            if (immutable && hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i === state.keys.length - 1;
            child.isFirst = i === 0;
            if (modifiers.post) {
              modifiers.post.call(state, child);
            }
            path.pop();
          });
          parents.pop();
        }
        if (modifiers.after) {
          modifiers.after.call(state, state.node);
        }
        return state;
      }(root).node;
    }
    function Traverse(obj) {
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
          return void 0;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.has = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
          return false;
        }
        node = node[key];
      }
      return true;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) {
          node[key] = {};
        }
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function() {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function() {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [];
      var nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          forEach(ownEnumerableKeys(src), function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        }
        return src;
      }(this.value);
    };
    function traverse(obj) {
      return new Traverse(obj);
    }
    forEach(ownEnumerableKeys(Traverse.prototype), function(key) {
      traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    module.exports = traverse;
  }
});

// node_modules/@mapbox/extent/index.js
var require_extent = __commonJS({
  "node_modules/@mapbox/extent/index.js"(exports, module) {
    module.exports = Extent;
    function Extent(bbox) {
      if (!(this instanceof Extent)) {
        return new Extent(bbox);
      }
      this._bbox = bbox || [Infinity, Infinity, -Infinity, -Infinity];
      this._valid = !!bbox;
    }
    Extent.prototype.include = function(ll) {
      this._valid = true;
      this._bbox[0] = Math.min(this._bbox[0], ll[0]);
      this._bbox[1] = Math.min(this._bbox[1], ll[1]);
      this._bbox[2] = Math.max(this._bbox[2], ll[0]);
      this._bbox[3] = Math.max(this._bbox[3], ll[1]);
      return this;
    };
    Extent.prototype.equals = function(_) {
      var other;
      if (_ instanceof Extent) {
        other = _.bbox();
      } else {
        other = _;
      }
      return this._bbox[0] == other[0] && this._bbox[1] == other[1] && this._bbox[2] == other[2] && this._bbox[3] == other[3];
    };
    Extent.prototype.center = function(_) {
      if (!this._valid)
        return null;
      return [
        (this._bbox[0] + this._bbox[2]) / 2,
        (this._bbox[1] + this._bbox[3]) / 2
      ];
    };
    Extent.prototype.union = function(_) {
      this._valid = true;
      var other;
      if (_ instanceof Extent) {
        other = _.bbox();
      } else {
        other = _;
      }
      this._bbox[0] = Math.min(this._bbox[0], other[0]);
      this._bbox[1] = Math.min(this._bbox[1], other[1]);
      this._bbox[2] = Math.max(this._bbox[2], other[2]);
      this._bbox[3] = Math.max(this._bbox[3], other[3]);
      return this;
    };
    Extent.prototype.bbox = function() {
      if (!this._valid)
        return null;
      return this._bbox;
    };
    Extent.prototype.contains = function(ll) {
      if (!ll)
        return this._fastContains();
      if (!this._valid)
        return null;
      var lon = ll[0], lat = ll[1];
      return this._bbox[0] <= lon && this._bbox[1] <= lat && this._bbox[2] >= lon && this._bbox[3] >= lat;
    };
    Extent.prototype.intersect = function(_) {
      if (!this._valid)
        return null;
      var other;
      if (_ instanceof Extent) {
        other = _.bbox();
      } else {
        other = _;
      }
      return !(this._bbox[0] > other[2] || this._bbox[2] < other[0] || this._bbox[3] < other[1] || this._bbox[1] > other[3]);
    };
    Extent.prototype._fastContains = function() {
      if (!this._valid)
        return new Function("return null;");
      var body = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]";
      return new Function("ll", body);
    };
    Extent.prototype.polygon = function() {
      if (!this._valid)
        return null;
      return {
        type: "Polygon",
        coordinates: [
          [
            // W, S
            [this._bbox[0], this._bbox[1]],
            // E, S
            [this._bbox[2], this._bbox[1]],
            // E, N
            [this._bbox[2], this._bbox[3]],
            // W, N
            [this._bbox[0], this._bbox[3]],
            // W, S
            [this._bbox[0], this._bbox[1]]
          ]
        ]
      };
    };
  }
});

// node_modules/@mapbox/geojson-extent/index.js
var require_geojson_extent = __commonJS({
  "node_modules/@mapbox/geojson-extent/index.js"(exports, module) {
    var geojsonCoords = require_geojson_coords();
    var traverse = require_traverse();
    var extent = require_extent();
    var geojsonTypesByDataAttributes = {
      features: ["FeatureCollection"],
      coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"],
      geometry: ["Feature"],
      geometries: ["GeometryCollection"]
    };
    var dataAttributes = Object.keys(geojsonTypesByDataAttributes);
    module.exports = function(_) {
      return getExtent(_).bbox();
    };
    module.exports.polygon = function(_) {
      return getExtent(_).polygon();
    };
    module.exports.bboxify = function(_) {
      return traverse(_).map(function(value) {
        if (!value)
          return;
        var isValid = dataAttributes.some(function(attribute) {
          if (value[attribute]) {
            return geojsonTypesByDataAttributes[attribute].indexOf(value.type) !== -1;
          }
          return false;
        });
        if (isValid) {
          value.bbox = getExtent(value).bbox();
          this.update(value);
        }
      });
    };
    function getExtent(_) {
      var ext = extent(), coords = geojsonCoords(_);
      for (var i = 0; i < coords.length; i++)
        ext.include(coords[i]);
      return ext;
    }
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/constrain_feature_movement.js
var require_constrain_feature_movement = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/constrain_feature_movement.js"(exports, module) {
    var extent = require_geojson_extent();
    var Constants = require_constants();
    var { LAT_MIN, LAT_MAX, LAT_RENDERED_MIN, LAT_RENDERED_MAX, LNG_MIN, LNG_MAX } = Constants;
    module.exports = function(geojsonFeatures, delta) {
      let northInnerEdge = LAT_MIN;
      let southInnerEdge = LAT_MAX;
      let northOuterEdge = LAT_MIN;
      let southOuterEdge = LAT_MAX;
      let westEdge = LNG_MAX;
      let eastEdge = LNG_MIN;
      geojsonFeatures.forEach((feature2) => {
        const bounds = extent(feature2);
        const featureSouthEdge = bounds[1];
        const featureNorthEdge = bounds[3];
        const featureWestEdge = bounds[0];
        const featureEastEdge = bounds[2];
        if (featureSouthEdge > northInnerEdge)
          northInnerEdge = featureSouthEdge;
        if (featureNorthEdge < southInnerEdge)
          southInnerEdge = featureNorthEdge;
        if (featureNorthEdge > northOuterEdge)
          northOuterEdge = featureNorthEdge;
        if (featureSouthEdge < southOuterEdge)
          southOuterEdge = featureSouthEdge;
        if (featureWestEdge < westEdge)
          westEdge = featureWestEdge;
        if (featureEastEdge > eastEdge)
          eastEdge = featureEastEdge;
      });
      const constrainedDelta = delta;
      if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {
        constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;
      }
      if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {
        constrainedDelta.lat = LAT_MAX - northOuterEdge;
      }
      if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {
        constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;
      }
      if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {
        constrainedDelta.lat = LAT_MIN - southOuterEdge;
      }
      if (westEdge + constrainedDelta.lng <= LNG_MIN) {
        constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
      }
      if (eastEdge + constrainedDelta.lng >= LNG_MAX) {
        constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
      }
      return constrainedDelta;
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/move_features.js
var require_move_features = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/move_features.js"(exports, module) {
    var constrainFeatureMovement = require_constrain_feature_movement();
    var Constants = require_constants();
    module.exports = function(features, delta) {
      const constrainedDelta = constrainFeatureMovement(
        features.map((feature2) => feature2.toGeoJSON()),
        delta
      );
      features.forEach((feature2) => {
        const currentCoordinates = feature2.getCoordinates();
        const moveCoordinate = (coord) => {
          const point2 = {
            lng: coord[0] + constrainedDelta.lng,
            lat: coord[1] + constrainedDelta.lat
          };
          return [point2.lng, point2.lat];
        };
        const moveRing = (ring) => ring.map((coord) => moveCoordinate(coord));
        const moveMultiPolygon = (multi) => multi.map((ring) => moveRing(ring));
        let nextCoordinates;
        if (feature2.type === Constants.geojsonTypes.POINT) {
          nextCoordinates = moveCoordinate(currentCoordinates);
        } else if (feature2.type === Constants.geojsonTypes.LINE_STRING || feature2.type === Constants.geojsonTypes.MULTI_POINT) {
          nextCoordinates = currentCoordinates.map(moveCoordinate);
        } else if (feature2.type === Constants.geojsonTypes.POLYGON || feature2.type === Constants.geojsonTypes.MULTI_LINE_STRING) {
          nextCoordinates = currentCoordinates.map(moveRing);
        } else if (feature2.type === Constants.geojsonTypes.MULTI_POLYGON) {
          nextCoordinates = currentCoordinates.map(moveMultiPolygon);
        }
        feature2.incomingCoords(nextCoordinates);
      });
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points_circle.js
var require_create_supplementary_points_circle = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points_circle.js"(exports, module) {
    var createVertex = require_create_vertex();
    function createSupplementaryPointsForCircle(geojson) {
      const { properties, geometry } = geojson;
      if (!properties.user_isCircle)
        return null;
      const supplementaryPoints = [];
      const vertices = geometry.coordinates[0].slice(0, -1);
      for (let index = 0; index < vertices.length; index += Math.round(vertices.length / 4)) {
        supplementaryPoints.push(createVertex(properties.id, vertices[index], `0.${index}`, false));
      }
      return supplementaryPoints;
    }
    module.exports = createSupplementaryPointsForCircle;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/DirectModeOverride.js
var require_DirectModeOverride = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/DirectModeOverride.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw2();
    var createSupplementaryPoints = require_create_supplementary_points();
    var moveFeatures = require_move_features();
    var Constants = require_constants();
    var constrainFeatureMovement = require_constrain_feature_movement();
    var distance = require_js5().default;
    var turfHelpers = require_js();
    var circle = require_js4().default;
    var createSupplementaryPointsForCircle = require_create_supplementary_points_circle();
    var DirectModeOverride = MapboxDraw2.modes.direct_select;
    DirectModeOverride.dragFeature = function(state, e2, delta) {
      moveFeatures(this.getSelected(), delta);
      this.getSelected().filter((feature2) => feature2.properties.isCircle).map((circle2) => circle2.properties.center).forEach((center) => {
        center[0] += delta.lng;
        center[1] += delta.lat;
      });
      state.dragMoveLocation = e2.lngLat;
    };
    DirectModeOverride.dragVertex = function(state, e2, delta) {
      if (state.feature.properties.isCircle) {
        const center = state.feature.properties.center;
        const movedVertex = [e2.lngLat.lng, e2.lngLat.lat];
        const radius = distance(turfHelpers.point(center), turfHelpers.point(movedVertex), { units: "kilometers" });
        const circleFeature = circle(center, radius);
        state.feature.incomingCoords(circleFeature.geometry.coordinates);
        state.feature.properties.radiusInKm = radius;
      } else {
        const selectedCoords = state.selectedCoordPaths.map((coord_path) => state.feature.getCoordinate(coord_path));
        const selectedCoordPoints = selectedCoords.map((coords) => ({
          type: Constants.geojsonTypes.FEATURE,
          properties: {},
          geometry: {
            type: Constants.geojsonTypes.POINT,
            coordinates: coords
          }
        }));
        const constrainedDelta = constrainFeatureMovement(selectedCoordPoints, delta);
        for (let i = 0; i < selectedCoords.length; i++) {
          const coord = selectedCoords[i];
          state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);
        }
      }
    };
    DirectModeOverride.toDisplayFeatures = function(state, geojson, push) {
      if (state.featureId === geojson.properties.id) {
        geojson.properties.active = Constants.activeStates.ACTIVE;
        push(geojson);
        const supplementaryPoints = geojson.properties.user_isCircle ? createSupplementaryPointsForCircle(geojson) : createSupplementaryPoints(geojson, {
          map: this.map,
          midpoints: true,
          selectedPaths: state.selectedCoordPaths
        });
        supplementaryPoints.forEach(push);
      } else {
        geojson.properties.active = Constants.activeStates.INACTIVE;
        push(geojson);
      }
      this.fireActionable(state);
    };
    module.exports = DirectModeOverride;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/SimpleSelectModeOverride.js
var require_SimpleSelectModeOverride = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/SimpleSelectModeOverride.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw2();
    var createSupplementaryPoints = require_create_supplementary_points();
    var moveFeatures = require_move_features();
    var Constants = require_constants();
    var createSupplementaryPointsForCircle = require_create_supplementary_points_circle();
    var SimpleSelectModeOverride = MapboxDraw2.modes.simple_select;
    SimpleSelectModeOverride.dragMove = function(state, e2) {
      state.dragMoving = true;
      e2.originalEvent.stopPropagation();
      const delta = {
        lng: e2.lngLat.lng - state.dragMoveLocation.lng,
        lat: e2.lngLat.lat - state.dragMoveLocation.lat
      };
      moveFeatures(this.getSelected(), delta);
      this.getSelected().filter((feature2) => feature2.properties.isCircle).map((circle) => circle.properties.center).forEach((center) => {
        center[0] += delta.lng;
        center[1] += delta.lat;
      });
      state.dragMoveLocation = e2.lngLat;
    };
    SimpleSelectModeOverride.toDisplayFeatures = function(state, geojson, display) {
      geojson.properties.active = this.isSelected(geojson.properties.id) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      display(geojson);
      this.fireActionable();
      if (geojson.properties.active !== Constants.activeStates.ACTIVE || geojson.geometry.type === Constants.geojsonTypes.POINT)
        return;
      const supplementaryPoints = geojson.properties.user_isCircle ? createSupplementaryPointsForCircle(geojson) : createSupplementaryPoints(geojson);
      supplementaryPoints.forEach(display);
    };
    module.exports = SimpleSelectModeOverride;
  }
});

// node_modules/maplibre-gl-draw-circle/index.js
var require_maplibre_gl_draw_circle = __commonJS({
  "node_modules/maplibre-gl-draw-circle/index.js"(exports, module) {
    var CircleMode2 = require_CircleMode();
    var DragCircleMode = require_DragCircleMode();
    var DirectMode2 = require_DirectModeOverride();
    var SimpleSelectMode2 = require_SimpleSelectModeOverride();
    module.exports = { CircleMode: CircleMode2, DragCircleMode, DirectMode: DirectMode2, SimpleSelectMode: SimpleSelectMode2 };
  }
});

// node_modules/@aws-amplify/ui-react-geo/dist/esm/components/MapView/MapView.mjs
var import_react = __toESM(require_react(), 1);
var import_maplibre_gl5 = __toESM(require_maplibre_gl(), 1);

// node_modules/@aws-amplify/geo/dist/esm/providers/location-service/AmazonLocationServiceProvider.mjs
var import_camelcase_keys = __toESM(require_camelcase_keys(), 1);

// node_modules/@turf/helpers/dist/es/index.js
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};

// node_modules/@turf/invariant/dist/es/index.js
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}

// node_modules/@turf/boolean-clockwise/dist/es/index.js
function booleanClockwise(line) {
  var ring = getCoords(line);
  var sum = 0;
  var i = 1;
  var prev;
  var cur;
  while (i < ring.length) {
    prev = cur || ring[0];
    cur = ring[i];
    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i++;
  }
  return sum > 0;
}

// node_modules/@aws-amplify/geo/dist/esm/util.mjs
function validateCoordinates(lng, lat) {
  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {
    throw new Error(`Invalid coordinates: [${lng},${lat}]`);
  }
  if (lat < -90 || lat > 90) {
    throw new Error("Latitude must be between -90 and 90 degrees inclusive.");
  } else if (lng < -180 || lng > 180) {
    throw new Error("Longitude must be between -180 and 180 degrees inclusive.");
  }
}
function validateGeofenceId(geofenceId) {
  const geofenceIdRegex = /^[-._\p{L}\p{N}]+$/iu;
  if (!geofenceIdRegex.test(geofenceId)) {
    throw new Error(`Invalid geofenceId: '${geofenceId}' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.`);
  }
}
function validateLinearRing(linearRing, geofenceId) {
  const errorPrefix = geofenceId ? `${geofenceId}: ` : "";
  if (linearRing.length < 4) {
    throw new Error(`${errorPrefix}LinearRing must contain 4 or more coordinates.`);
  }
  const badCoordinates = [];
  linearRing.forEach((coordinates) => {
    try {
      validateCoordinates(coordinates[0], coordinates[1]);
    } catch (error) {
      badCoordinates.push({ coordinates, error: error.message });
    }
  });
  if (badCoordinates.length > 0) {
    throw new Error(`${errorPrefix}One or more of the coordinates in the Polygon LinearRing are not valid: ${JSON.stringify(badCoordinates)}`);
  }
  const [lngA, latA] = linearRing[0];
  const [lngB, latB] = linearRing[linearRing.length - 1];
  if (lngA !== lngB || latA !== latB) {
    throw new Error(`${errorPrefix}LinearRing's first and last coordinates are not the same`);
  }
  if (booleanClockwise(linearRing)) {
    throw new Error(`${errorPrefix}LinearRing coordinates must be wound counterclockwise`);
  }
}
function validatePolygon(polygon2, geofenceId) {
  const errorPrefix = geofenceId ? `${geofenceId}: ` : "";
  if (!Array.isArray(polygon2)) {
    throw new Error(`${errorPrefix}Polygon is of incorrect structure. It should be an array of LinearRings`);
  }
  if (polygon2.length < 1) {
    throw new Error(`${errorPrefix}Polygon must have a single LinearRing array.`);
  }
  if (polygon2.length > 1) {
    throw new Error(`${errorPrefix}Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.`);
  }
  const verticesCount = polygon2.reduce((prev, linearRing) => prev + linearRing.length, 0);
  if (verticesCount > 1e3) {
    throw new Error(`${errorPrefix}Polygon has more than the maximum 1000 vertices.`);
  }
  polygon2.forEach((linearRing) => {
    validateLinearRing(linearRing, geofenceId);
  });
}
function validateGeofencesInput(geofences) {
  const geofenceIds = {};
  geofences.forEach((geofence) => {
    if (!geofence.geofenceId) {
      throw new Error(`Geofence '${geofence}' is missing geofenceId`);
    }
    const { geofenceId } = geofence;
    validateGeofenceId(geofenceId);
    if (geofenceIds[geofenceId]) {
      throw new Error(`Duplicate geofenceId: ${geofenceId}`);
    } else {
      geofenceIds[geofenceId] = true;
    }
    if (!geofence.geometry) {
      throw new Error(`Geofence '${geofenceId}' is missing geometry`);
    }
    const { geometry } = geofence;
    if (!geometry.polygon) {
      throw new Error(`Geofence '${geofenceId}' is missing geometry.polygon`);
    }
    const { polygon: polygon2 } = geometry;
    try {
      validatePolygon(polygon2, geofenceId);
    } catch (error) {
      if (error.message.includes("Polygon has more than the maximum 1000 vertices.")) {
        throw new Error(`Geofence '${geofenceId}' has more than the maximum of 1000 vertices`);
      }
    }
    const [linearRing] = polygon2;
    validateLinearRing(linearRing, geofenceId);
  });
}
function mapSearchOptions(options, locationServiceInput) {
  const locationServiceModifiedInput = { ...locationServiceInput };
  locationServiceModifiedInput.FilterCountries = options.countries;
  locationServiceModifiedInput.MaxResults = options.maxResults;
  locationServiceModifiedInput.Language = options.language;
  if (options.searchIndexName) {
    locationServiceModifiedInput.IndexName = options.searchIndexName;
  }
  if (options.biasPosition && options.searchAreaConstraints) {
    throw new Error("BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object");
  }
  if (options.biasPosition) {
    locationServiceModifiedInput.BiasPosition = options.biasPosition;
  }
  if (options.searchAreaConstraints) {
    locationServiceModifiedInput.FilterBBox = options.searchAreaConstraints;
  }
  return locationServiceModifiedInput;
}
function getGeoUserAgent(action) {
  return getAmplifyUserAgentObject({
    category: Category.Geo,
    action
  });
}

// node_modules/@aws-amplify/geo/dist/esm/providers/location-service/AmazonLocationServiceProvider.mjs
var logger = new ConsoleLogger("AmazonLocationServiceProvider");
var AmazonLocationServiceProvider = class _AmazonLocationServiceProvider {
  /**
   * Initialize Geo with AWS configurations
   * @param {Object} config - Configuration object for Geo
   */
  constructor(config) {
    this._config = config || {};
    logger.debug("Geo Options", this._config);
  }
  /**
   * get the category of the plugin
   * @returns {string} name of the category
   */
  getCategory() {
    return _AmazonLocationServiceProvider.CATEGORY;
  }
  /**
   * get provider name of the plugin
   * @returns {string} name of the provider
   */
  getProviderName() {
    return _AmazonLocationServiceProvider.PROVIDER_NAME;
  }
  /**
   * Get the map resources that are currently available through the provider
   * @returns {AmazonLocationServiceMapStyle[]}- Array of available map resources
   */
  getAvailableMaps() {
    this._verifyMapResources();
    const mapStyles = [];
    const availableMaps = this._config.maps.items;
    const { region } = this._config;
    for (const mapName in availableMaps) {
      const { style } = availableMaps[mapName];
      mapStyles.push({ mapName, style, region });
    }
    return mapStyles;
  }
  /**
   * Get the map resource set as default in amplify config
   * @returns {AmazonLocationServiceMapStyle} - Map resource set as the default in amplify config
   */
  getDefaultMap() {
    this._verifyMapResources();
    const mapName = this._config.maps.default;
    const { style } = this._config.maps.items[mapName];
    const { region } = this._config;
    return { mapName, style, region };
  }
  /**
   * Search by text input with optional parameters
   * @param  {string} text The text string that is to be searched for
   * @param  {SearchByTextOptions} options Optional parameters to the search
   * @returns {Promise<Place[]>} - Promise resolves to a list of Places that match search parameters
   */
  async searchByText(text, options) {
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    this._verifySearchIndex(options == null ? void 0 : options.searchIndexName);
    let locationServiceInput = {
      Text: text,
      IndexName: this._config.search_indices.default
    };
    if (options) {
      locationServiceInput = {
        ...locationServiceInput,
        ...mapSearchOptions(options, locationServiceInput)
      };
    }
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.SearchByText)
    });
    const command = new SearchPlaceIndexForTextCommand(locationServiceInput);
    let response;
    try {
      response = await client.send(command);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    const PascalResults = response.Results.map((result) => result.Place);
    const results = (0, import_camelcase_keys.default)(PascalResults, {
      deep: true
    });
    return results;
  }
  /**
   * Search for suggestions based on the input text
   * @param  {string} text The text string that is to be searched for
   * @param  {SearchByTextOptions} options Optional parameters to the search
   * @returns {Promise<SearchForSuggestionsResults>} - Resolves to an array of search suggestion strings
   */
  async searchForSuggestions(text, options) {
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    this._verifySearchIndex(options == null ? void 0 : options.searchIndexName);
    let locationServiceInput = {
      Text: text,
      IndexName: this._config.search_indices.default
    };
    if (options) {
      locationServiceInput = {
        ...locationServiceInput,
        ...mapSearchOptions(options, locationServiceInput)
      };
    }
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.SearchForSuggestions)
    });
    const command = new SearchPlaceIndexForSuggestionsCommand(locationServiceInput);
    let response;
    try {
      response = await client.send(command);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    const results = response.Results.map((result) => ({
      text: result.Text,
      placeId: result.PlaceId
    }));
    return results;
  }
  _verifyPlaceId(placeId) {
    if (placeId.length === 0) {
      const errorString = "PlaceId cannot be an empty string.";
      logger.debug(errorString);
      throw new Error(errorString);
    }
  }
  async searchByPlaceId(placeId, options) {
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    this._verifySearchIndex(options == null ? void 0 : options.searchIndexName);
    this._verifyPlaceId(placeId);
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.SearchByPlaceId)
    });
    const searchByPlaceIdInput = {
      PlaceId: placeId,
      IndexName: (options == null ? void 0 : options.searchIndexName) || this._config.search_indices.default
    };
    const command = new GetPlaceCommand(searchByPlaceIdInput);
    let response;
    try {
      response = await client.send(command);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    const place = response.Place;
    if (place) {
      return (0, import_camelcase_keys.default)(place, { deep: true });
    }
  }
  /**
   * Reverse geocoding search via a coordinate point on the map
   * @param coordinates Coordinates array for the search input
   * @param options Options parameters for the search
   * @returns {Promise<Place>} - Promise that resolves to a place matching search coordinates
   */
  async searchByCoordinates(coordinates, options) {
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    this._verifySearchIndex(options == null ? void 0 : options.searchIndexName);
    const locationServiceInput = {
      Position: coordinates,
      IndexName: this._config.search_indices.default
    };
    if (options) {
      if (options.searchIndexName) {
        locationServiceInput.IndexName = options.searchIndexName;
      }
      locationServiceInput.MaxResults = options.maxResults;
    }
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.SearchByCoordinates)
    });
    const command = new SearchPlaceIndexForPositionCommand(locationServiceInput);
    let response;
    try {
      response = await client.send(command);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    const PascalResults = response.Results.map((result) => result.Place);
    const results = (0, import_camelcase_keys.default)(PascalResults[0], {
      deep: true
    });
    return results;
  }
  /**
   * Create geofences inside of a geofence collection
   * @param geofences Array of geofence objects to create
   * @param options Optional parameters for creating geofences
   * @returns a promise that resolves to an object that conforms to {@link SaveGeofencesResults}:
   *   successes: list of geofences successfully created
   *   errors: list of geofences that failed to create
   */
  async saveGeofences(geofences, options) {
    if (geofences.length < 1) {
      throw new Error("Geofence input array is empty");
    }
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    try {
      this._verifyGeofenceCollections(options == null ? void 0 : options.collectionName);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    validateGeofencesInput(geofences);
    const PascalGeofences = geofences.map(({ geofenceId, geometry: { polygon: polygon2 } }) => {
      return {
        GeofenceId: geofenceId,
        Geometry: {
          Polygon: polygon2
        }
      };
    });
    const results = {
      successes: [],
      errors: []
    };
    const geofenceBatches = [];
    while (PascalGeofences.length > 0) {
      const apiLimit = 10;
      geofenceBatches.push(PascalGeofences.splice(0, apiLimit));
    }
    await Promise.all(geofenceBatches.map(async (batch) => {
      var _a2, _b;
      let response;
      try {
        response = await this._AmazonLocationServiceBatchPutGeofenceCall(batch, (options == null ? void 0 : options.collectionName) || this._config.geofenceCollections.default);
      } catch (error) {
        batch.forEach((geofence) => {
          results.errors.push({
            geofenceId: geofence.GeofenceId,
            error: {
              code: "APIConnectionError",
              message: error.message
            }
          });
        });
        return;
      }
      (_a2 = response.Successes) == null ? void 0 : _a2.forEach((success) => {
        const { GeofenceId: geofenceId, CreateTime, UpdateTime } = success;
        results.successes.push({
          geofenceId,
          createTime: CreateTime,
          updateTime: UpdateTime
        });
      });
      (_b = response.Errors) == null ? void 0 : _b.forEach((error) => {
        const { Error: Error2, GeofenceId: geofenceId } = error;
        const { Code, Message } = Error2;
        results.errors.push({
          error: {
            code: Code,
            message: Message
          },
          geofenceId
        });
      });
    }));
    return results;
  }
  /**
   * Get geofence from a geofence collection
   * @param geofenceId string
   * @param options Optional parameters for getGeofence
   * @returns {Promise<AmazonLocationServiceGeofence>} - Promise that resolves to a geofence object
   */
  async getGeofence(geofenceId, options) {
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    try {
      this._verifyGeofenceCollections(options == null ? void 0 : options.collectionName);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    validateGeofenceId(geofenceId);
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.GetGeofence)
    });
    const commandInput = {
      GeofenceId: geofenceId,
      CollectionName: (options == null ? void 0 : options.collectionName) || this._config.geofenceCollections.default
    };
    const command = new GetGeofenceCommand(commandInput);
    let response;
    try {
      response = await client.send(command);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    const { GeofenceId: responseGeofenceId, CreateTime, UpdateTime, Status, Geometry } = response;
    const geofence = {
      createTime: CreateTime,
      geofenceId: responseGeofenceId,
      geometry: {
        polygon: Geometry.Polygon
      },
      status: Status,
      updateTime: UpdateTime
    };
    return geofence;
  }
  /**
   * List geofences from a geofence collection
   * @param  options ListGeofenceOptions
   * @returns a promise that resolves to an object that conforms to {@link ListGeofenceResults}:
   *   entries: list of geofences - 100 geofences are listed per page
   *   nextToken: token for next page of geofences
   */
  async listGeofences(options) {
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    try {
      this._verifyGeofenceCollections(options == null ? void 0 : options.collectionName);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.ListGeofences)
    });
    const listGeofencesInput = {
      NextToken: options == null ? void 0 : options.nextToken,
      CollectionName: (options == null ? void 0 : options.collectionName) || this._config.geofenceCollections.default
    };
    const command = new ListGeofencesCommand(listGeofencesInput);
    let response;
    try {
      response = await client.send(command);
    } catch (error) {
      logger.debug(error);
      throw error;
    }
    const { NextToken, Entries } = response;
    const results = {
      entries: Entries.map(({ GeofenceId: geofenceId, CreateTime, UpdateTime, Status, Geometry }) => {
        return {
          geofenceId,
          createTime: CreateTime,
          updateTime: UpdateTime,
          status: Status,
          geometry: {
            polygon: Geometry.Polygon
          }
        };
      }),
      nextToken: NextToken
    };
    return results;
  }
  /**
   * Delete geofences from a geofence collection
   * @param geofenceIds string|string[]
   * @param options GeofenceOptions
   * @returns a promise that resolves to an object that conforms to {@link AmazonLocationServiceDeleteGeofencesResults}:
   *  successes: list of geofences successfully deleted
   *  errors: list of geofences that failed to delete
   */
  async deleteGeofences(geofenceIds, options) {
    if (geofenceIds.length < 1) {
      throw new Error("GeofenceId input array is empty");
    }
    const credentialsOK = await this._ensureCredentials();
    if (!credentialsOK) {
      throw new Error("No credentials");
    }
    this._verifyGeofenceCollections(options == null ? void 0 : options.collectionName);
    const badGeofenceIds = geofenceIds.filter((geofenceId) => {
      try {
        validateGeofenceId(geofenceId);
      } catch (error) {
        return true;
      }
      return false;
    });
    if (badGeofenceIds.length > 0) {
      throw new Error(`Invalid geofence ids: ${badGeofenceIds.join(", ")}`);
    }
    const results = {
      successes: [],
      errors: []
    };
    const geofenceIdBatches = [];
    let count = 0;
    while (count < geofenceIds.length) {
      geofenceIdBatches.push(geofenceIds.slice(count, count += 10));
    }
    await Promise.all(geofenceIdBatches.map(async (batch) => {
      let response;
      try {
        response = await this._AmazonLocationServiceBatchDeleteGeofenceCall(batch, (options == null ? void 0 : options.collectionName) || this._config.geofenceCollections.default);
      } catch (error) {
        batch.forEach((geofenceId) => {
          const errorObject = {
            geofenceId,
            error: {
              code: error.message,
              message: error.message
            }
          };
          results.errors.push(errorObject);
        });
        return;
      }
      const targetBadGeofenceIds = response.Errors.map(({ geofenceId }) => geofenceId);
      results.successes.push(...batch.filter((Id) => !targetBadGeofenceIds.includes(Id)));
    }));
    return results;
  }
  /**
   * @private
   */
  async _ensureCredentials() {
    try {
      const { credentials } = await fetchAuthSession();
      if (!credentials)
        return false;
      logger.debug("Set credentials for storage. Credentials are:", credentials);
      this._credentials = credentials;
      return true;
    } catch (error) {
      logger.debug("Ensure credentials error. Credentials are:", error);
      return false;
    }
  }
  _refreshConfig() {
    var _a2;
    this._config = (_a2 = Amplify.getConfig().Geo) == null ? void 0 : _a2.LocationService;
    if (!this._config) {
      const errorString = "No Geo configuration found in amplify config, run 'amplify add geo' to create one and run `amplify push` after";
      logger.debug(errorString);
      throw new Error(errorString);
    }
  }
  _verifyMapResources() {
    this._refreshConfig();
    if (!this._config.maps) {
      const errorString = "No map resources found in amplify config, run 'amplify add geo' to create one and run `amplify push` after";
      logger.debug(errorString);
      throw new Error(errorString);
    }
    if (!this._config.maps.default) {
      const errorString = "No default map resource found in amplify config, run 'amplify add geo' to create one and run `amplify push` after";
      logger.debug(errorString);
      throw new Error(errorString);
    }
  }
  _verifySearchIndex(optionalSearchIndex) {
    this._refreshConfig();
    if ((!this._config.searchIndices || !this._config.searchIndices.default) && !optionalSearchIndex) {
      const errorString = "No Search Index found in amplify config, please run `amplify add geo` to create one and run `amplify push` after.";
      logger.debug(errorString);
      throw new Error(errorString);
    }
  }
  _verifyGeofenceCollections(optionalGeofenceCollectionName) {
    this._refreshConfig();
    if ((!this._config.geofenceCollections || !this._config.geofenceCollections.default) && !optionalGeofenceCollectionName) {
      const errorString = "No Geofence Collections found, please run `amplify add geo` to create one and run `amplify push` after.";
      logger.debug(errorString);
      throw new Error(errorString);
    }
  }
  async _AmazonLocationServiceBatchPutGeofenceCall(PascalGeofences, collectionName) {
    const geofenceInput = {
      Entries: PascalGeofences,
      CollectionName: collectionName || this._config.geofenceCollections.default
    };
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.SaveGeofences)
    });
    const command = new BatchPutGeofenceCommand(geofenceInput);
    return client.send(command);
  }
  async _AmazonLocationServiceBatchDeleteGeofenceCall(geofenceIds, collectionName) {
    const deleteGeofencesInput = {
      GeofenceIds: geofenceIds,
      CollectionName: collectionName || this._config.geofenceCollections.default
    };
    const client = new LocationClient({
      credentials: this._credentials,
      region: this._config.region,
      customUserAgent: getGeoUserAgent(GeoAction.DeleteGeofences)
    });
    const command = new BatchDeleteGeofenceCommand(deleteGeofencesInput);
    return client.send(command);
  }
};
AmazonLocationServiceProvider.CATEGORY = "Geo";
AmazonLocationServiceProvider.PROVIDER_NAME = "AmazonLocationService";

// node_modules/@aws-amplify/geo/dist/esm/Geo.mjs
var logger2 = new ConsoleLogger("Geo");
var DEFAULT_PROVIDER = "AmazonLocationService";
var GeoClass = class _GeoClass {
  constructor() {
    this._config = void 0;
    this._pluggables = [];
    const amplifyConfig = Amplify.getConfig() ?? {};
    this._config = Object.assign({}, this._config, amplifyConfig.Geo);
    const locationProvider = new AmazonLocationServiceProvider(amplifyConfig.Geo);
    this._pluggables.push(locationProvider);
    logger2.debug("Geo Options", this._config);
  }
  /**
   * get the name of the module category
   * @returns {string} name of the module category
   */
  getModuleName() {
    return _GeoClass.MODULE;
  }
  /**
   * add plugin into Geo category
   * @param {Object} pluggable an instance of the plugin
   */
  addPluggable(pluggable) {
    if (pluggable && pluggable.getCategory() === "Geo") {
      this._pluggables.push(pluggable);
    }
  }
  /**
   * Get the plugin object
   * @param providerName the name of the plugin
   */
  getPluggable(providerName) {
    const targetPluggable = this._pluggables.find((pluggable) => pluggable.getProviderName() === providerName);
    if (targetPluggable === void 0) {
      logger2.debug("No plugin found with providerName", providerName);
      throw new Error("No plugin found in Geo for the provider");
    } else
      return targetPluggable;
  }
  /**
   * Remove the plugin object
   * @param providerName the name of the plugin
   */
  removePluggable(providerName) {
    this._pluggables = this._pluggables.filter((pluggable) => pluggable.getProviderName() !== providerName);
  }
  /**
   * Get the map resources that are currently available through the provider
   * @param {string} provider
   * @returns - Array of available map resources
   */
  getAvailableMaps(provider = DEFAULT_PROVIDER) {
    const prov = this.getPluggable(provider);
    return prov.getAvailableMaps();
  }
  /**
   * Get the map resource set as default in amplify config
   * @param {string} provider
   * @returns - Map resource set as the default in amplify config
   */
  getDefaultMap(provider = DEFAULT_PROVIDER) {
    const prov = this.getPluggable(provider);
    return prov.getDefaultMap();
  }
  /**
   * Search by text input with optional parameters
   * @param  {string} text The text string that is to be searched for
   * @param  {SearchByTextOptions} options Optional parameters to the search
   * @returns {Promise<Place[]>} - Promise resolves to a list of Places that match search parameters
   */
  async searchByText(text, options) {
    const { providerName = DEFAULT_PROVIDER } = options || {};
    const prov = this.getPluggable(providerName);
    try {
      return await prov.searchByText(text, options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
  /**
   * Search for search term suggestions based on input text
   * @param  {string} text The text string that is to be search for
   * @param  {SearchByTextOptions} options Optional parameters to the search
   * @returns a `Promise` of {@link SearchForSuggestionsResults} that resolves to an array of search suggestion strings
   */
  async searchForSuggestions(text, options) {
    const { providerName = DEFAULT_PROVIDER } = options || {};
    const prov = this.getPluggable(providerName);
    try {
      return await prov.searchForSuggestions(text, options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
  /**
   * Search for location by unique ID
   * @param  {string} placeId Unique ID of the location that is to be searched for
   * @param  {searchByPlaceIdOptions} options Optional parameters to the search
   * @returns {Promise<Place>} - Resolves to a place with the given placeId
   */
  async searchByPlaceId(placeId, options) {
    const providerName = DEFAULT_PROVIDER;
    const prov = this.getPluggable(providerName);
    try {
      return await prov.searchByPlaceId(placeId, options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
  /**
   * Reverse geocoding search via a coordinate point on the map
   * @param coordinates Coordinates array for the search input
   * @param options Options parameters for the search
   * @returns {Promise<Place>} - Promise that resolves to a place matching search coordinates
   */
  async searchByCoordinates(coordinates, options) {
    const { providerName = DEFAULT_PROVIDER } = options || {};
    const prov = this.getPluggable(providerName);
    const [lng, lat] = coordinates;
    try {
      validateCoordinates(lng, lat);
      return await prov.searchByCoordinates(coordinates, options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
  /**
   * Create geofences
   * @param geofences Single or array of geofence objects to create
   * @param options Optional parameters for creating geofences
   * @returns {Promise<SaveGeofencesResults>} - Promise that resolves to an object with:
   *   successes: list of geofences successfully created
   *   errors: list of geofences that failed to create
   */
  async saveGeofences(geofences, options) {
    const { providerName = DEFAULT_PROVIDER } = options || {};
    const prov = this.getPluggable(providerName);
    let geofenceInputArray;
    if (!Array.isArray(geofences)) {
      geofenceInputArray = [geofences];
    } else {
      geofenceInputArray = geofences;
    }
    try {
      return await prov.saveGeofences(geofenceInputArray, options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
  /**
   * Get a single geofence by geofenceId
   * @param geofenceId The string id of the geofence to get
   * @param options Optional parameters for getting a geofence
   * @returns Promise<Geofence> - Promise that resolves to a geofence object
   */
  async getGeofence(geofenceId, options) {
    const { providerName = DEFAULT_PROVIDER } = options || {};
    const prov = this.getPluggable(providerName);
    try {
      return await prov.getGeofence(geofenceId, options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
  /**
   * List geofences
   * @param  options ListGeofenceOptions
   * @returns a promise that resolves to an object that conforms to {@link ListGeofenceResults}:
   *   entries: list of geofences - 100 geofences are listed per page
   *   nextToken: token for next page of geofences
   */
  async listGeofences(options) {
    const { providerName = DEFAULT_PROVIDER } = options || {};
    const prov = this.getPluggable(providerName);
    try {
      return await prov.listGeofences(options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
  /**
   * Delete geofences
   * @param geofenceIds string|string[]
   * @param options GeofenceOptions
   * @returns {Promise<DeleteGeofencesResults>} - Promise that resolves to an object with:
   *  successes: list of geofences successfully deleted
   *  errors: list of geofences that failed to delete
   */
  async deleteGeofences(geofenceIds, options) {
    const { providerName = DEFAULT_PROVIDER } = options || {};
    const prov = this.getPluggable(providerName);
    let geofenceIdsInputArray;
    if (!Array.isArray(geofenceIds)) {
      geofenceIdsInputArray = [geofenceIds];
    } else {
      geofenceIdsInputArray = geofenceIds;
    }
    try {
      return await prov.deleteGeofences(geofenceIdsInputArray, options);
    } catch (error) {
      logger2.debug(error);
      throw error;
    }
  }
};
GeoClass.MODULE = "Geo";
var Geo = new GeoClass();

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreRequest.js
var import_maplibre_gl = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/utils.js
var urlEncodePeriods = (str) => {
  return str.replace(/\./g, "%2E");
};

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreRequest.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _a;
var AmplifyMapLibreRequest = class {
  constructor(currentCredentials, region) {
    this.refreshCredentials = () => __awaiter(this, void 0, void 0, function* () {
      try {
        this.credentials = (yield fetchAuthSession()).credentials;
      } catch (e2) {
        console.error(`Failed to refresh credentials: ${e2}`);
        throw e2;
      }
    });
    this.refreshCredentialsWithRetry = () => __awaiter(this, void 0, void 0, function* () {
      try {
        const MAX_DELAY_MS = 5 * 60 * 1e3;
        yield jitteredExponentialRetry(this.refreshCredentials, [], MAX_DELAY_MS);
        this.activeTimeout && clearTimeout(this.activeTimeout);
        if (this.credentials.expiration.getTime() > (/* @__PURE__ */ new Date()).getTime()) {
          const expiration = new Date(this.credentials.expiration);
          const timeout = expiration.getTime() - (/* @__PURE__ */ new Date()).getTime() - 1e4;
          this.activeTimeout = window.setTimeout(
            this.refreshCredentialsWithRetry,
            Math.min(timeout, 36e5)
            // Set timeout to an hour if we somehow don't have a value for timeout
          );
        }
      } catch (e2) {
        console.error(`Failed to refresh credentials: ${e2}`);
      }
    });
    this.transformRequest = (url, resourceType) => {
      let styleUrl = url;
      if (resourceType === "Style" && !url.includes("://")) {
        if (this.region == void 0) {
          throw new Error("AWS region for map is undefined. Please verify that the region is set in aws-exports.js or that you are providing an AWS region parameter to createMap");
        }
        styleUrl = `https://maps.geo.${this.region}.amazonaws.com/maps/v0/maps/${url}/style-descriptor`;
      }
      const urlObject = new URL(styleUrl);
      if (urlObject.hostname.endsWith(".amazonaws.com")) {
        urlObject.searchParams.append("x-amz-user-agent", encodeURIComponent(urlEncodePeriods(getAmplifyUserAgentString())));
        return {
          url: Signer.signUrl(urlObject.href, {
            access_key: this.credentials.accessKeyId,
            secret_key: this.credentials.secretAccessKey,
            session_token: this.credentials.sessionToken
          })
        };
      }
    };
    this.credentials = currentCredentials;
    this.region = region;
    this.activeTimeout = null;
    this.refreshCredentialsWithRetry();
    Hub.listen("auth", (data) => {
      switch (data.payload.event) {
        case "signedIn":
        case "signedOut":
        case "tokenRefresh":
          this.refreshCredentialsWithRetry();
          break;
      }
    });
  }
};
_a = AmplifyMapLibreRequest;
AmplifyMapLibreRequest.createMapLibreMap = (options) => __awaiter(void 0, void 0, void 0, function* () {
  const { region, mapConstructor = import_maplibre_gl.Map } = options, maplibreOption = __rest(options, ["region", "mapConstructor"]);
  const defaultMap = Geo.getDefaultMap();
  const amplifyRequest = new AmplifyMapLibreRequest((yield fetchAuthSession()).credentials, region || defaultMap.region);
  const transformRequest = amplifyRequest.transformRequest;
  const map = new mapConstructor(Object.assign(Object.assign({}, maplibreOption), {
    style: options.style || defaultMap.mapName,
    // Amplify uses the name of the map in the maplibre style field,
    transformRequest
  }));
  return map;
});
function getAmplifyUserAgentString() {
  const userAgent = getAmplifyUserAgent();
  if (userAgent && typeof userAgent === "object") {
    return userAgent.map(([agentKey, agentValue]) => `${agentKey}/${agentValue}`).join(" ");
  }
  return userAgent;
}

// node_modules/maplibre-gl-js-amplify/lib/esm/constants.js
var LOCATION_MARKER = "M24.8133 38.533C18.76 31.493 13 28.8264 13 20.8264C13.4827 14.9864 16.552 9.67169 21.368 6.33302C33.768 -2.26165 50.824 5.78902 52.0667 20.8264C52.0667 28.613 46.5733 31.6797 40.6533 38.373C32.4933 47.5464 35.4 63.093 32.4933 63.093C29.72 63.093 32.4933 47.5464 24.8133 38.533ZM32.4933 8.23969C26.5573 8.23969 21.7467 13.0504 21.7467 18.9864C21.7467 24.9224 26.5573 29.733 32.4933 29.733C38.4293 29.733 43.24 24.9224 43.24 18.9864C43.24 13.0504 38.4293 8.23969 32.4933 8.23969Z";
var MAP_STYLES;
(function(MAP_STYLES2) {
  MAP_STYLES2["ESRI_TOPOGRAPHIC"] = "VectorEsriTopographic";
  MAP_STYLES2["ESRI_STREETS"] = "VectorEsriStreets";
  MAP_STYLES2["ESRI_LIGHT_GRAY"] = "VectorEsriLightGrayCanvas";
  MAP_STYLES2["ESRI_DARK_GRAY"] = "VectorEsriDarkGrayCanvas";
  MAP_STYLES2["ESRI_NAVIGATION"] = "VectorEsriNavigation";
  MAP_STYLES2["HERE_BERLIN"] = "VectorHereBerlin";
})(MAP_STYLES || (MAP_STYLES = {}));
var FONT_DEFAULT_BY_STYLE = {
  [MAP_STYLES.ESRI_TOPOGRAPHIC]: "Noto Sans Regular",
  [MAP_STYLES.ESRI_STREETS]: "Arial Regular",
  [MAP_STYLES.ESRI_LIGHT_GRAY]: "Ubuntu Regular",
  [MAP_STYLES.ESRI_DARK_GRAY]: "Ubuntu Regular",
  [MAP_STYLES.ESRI_NAVIGATION]: "Arial Regular",
  [MAP_STYLES.HERE_BERLIN]: "Fira GO Regular"
};

// node_modules/maplibre-gl-js-amplify/lib/esm/drawUnclusteredLayer.js
var import_maplibre_gl2 = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreGeocoder.js
var import_maplibre_gl_geocoder = __toESM(require_lib());
var import_maplibre_gl3 = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/createDefaultIcon.js
function createDefaultIcon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  const iconCircle = document.createElement("circle");
  customIcon.setAttribute("viewBox", "0 0 64 64");
  customIcon.setAttribute("width", "32");
  customIcon.setAttribute("height", "32");
  iconPath.setAttribute("d", LOCATION_MARKER);
  iconPath.setAttribute("fill", "#5d8aff");
  iconCircle.setAttribute("fill", "white");
  iconCircle.setAttribute("cx", "50%");
  iconCircle.setAttribute("cy", "50%");
  iconCircle.setAttribute("r", "5");
  customIcon.appendChild(iconCircle);
  customIcon.appendChild(iconPath);
  return customIcon;
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreGeocoder.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest2 = function(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var AmplifyGeocoderAPI = {
  forwardGeocode: (config) => __awaiter2(void 0, void 0, void 0, function* () {
    const features = [];
    try {
      const data = yield Geo.searchByText(config.query, {
        biasPosition: config.bbox ? void 0 : config.proximity,
        searchAreaConstraints: config.bbox,
        countries: config.countries,
        maxResults: config.limit
      });
      if (data) {
        data.forEach((result) => {
          const { geometry } = result, otherResults = __rest2(result, ["geometry"]);
          features.push({
            type: "Feature",
            geometry: { type: "Point", coordinates: geometry.point },
            properties: Object.assign({}, otherResults),
            place_name: otherResults.label,
            text: otherResults.label,
            center: geometry.point
          });
        });
      }
    } catch (e2) {
      console.error(`Failed to forwardGeocode with error: ${e2}`);
    }
    return { features };
  }),
  reverseGeocode: (config) => __awaiter2(void 0, void 0, void 0, function* () {
    const features = [];
    try {
      const data = yield Geo.searchByCoordinates(config.query, {
        maxResults: config.limit
      });
      if (data && data.geometry) {
        const { geometry } = data, otherResults = __rest2(data, ["geometry"]);
        features.push({
          type: "Feature",
          geometry: { type: "Point", coordinates: geometry.point },
          properties: Object.assign({}, otherResults),
          place_name: otherResults.label,
          text: otherResults.label,
          center: geometry.point
        });
      }
    } catch (e2) {
      console.error(`Failed to reverseGeocode with error: ${e2}`);
    }
    return { features };
  }),
  getSuggestions: (config) => __awaiter2(void 0, void 0, void 0, function* () {
    const suggestions = [];
    try {
      const response = yield Geo.searchForSuggestions(config.query, {
        biasPosition: config.proximity,
        searchAreaConstraints: config.bbox,
        countries: config.countries,
        maxResults: config.limit
      });
      suggestions.push(...response);
    } catch (e2) {
      console.error(`Failed to get suggestions with error: ${e2}`);
    }
    return { suggestions };
  }),
  searchByPlaceId: (config) => __awaiter2(void 0, void 0, void 0, function* () {
    let feature2 = void 0;
    try {
      const place = yield Geo.searchByPlaceId(config.query);
      if (place) {
        const { geometry } = place, otherResults = __rest2(place, ["geometry"]);
        feature2 = {
          type: "Feature",
          geometry: { type: "Point", coordinates: geometry.point },
          properties: Object.assign({}, otherResults),
          place_name: otherResults.label,
          text: otherResults.label,
          center: geometry.point
        };
      }
    } catch (e2) {
      console.error(`Failed to get place with error: ${e2}`);
    }
    return { place: feature2 };
  })
};
function createAmplifyGeocoder(options) {
  return new import_maplibre_gl_geocoder.default(AmplifyGeocoderAPI, Object.assign({
    maplibregl: import_maplibre_gl3.default,
    showResultMarkers: { element: createDefaultIcon() },
    marker: { element: createDefaultIcon() },
    // autocomplete temporarily disabled by default until CLI is updated
    showResultsWhileTyping: options === null || options === void 0 ? void 0 : options.autocomplete
  }, options));
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/index.js
var import_maplibre_gl4 = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/ui.js
var import_debounce = __toESM(require_debounce());

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/AmplifyMapDraw.js
var import_mapbox_gl_draw = __toESM(require_mapbox_gl_draw());
var import_maplibre_gl_draw_circle = __toESM(require_maplibre_gl_draw_circle());

// node_modules/@aws-amplify/ui-react-geo/dist/esm/components/MapView/MapView.mjs
var MapView = (0, import_react.forwardRef)(({ mapLib, mapStyle, style, ...props }, ref) => {
  var _a2;
  const geoConfig = (0, import_react.useMemo)(() => {
    var _a3;
    return ((_a3 = DefaultAmplify.getConfig().Geo) == null ? void 0 : _a3.LocationService) ?? {};
  }, []);
  const [transformRequest, setTransformRequest] = (0, import_react.useState)();
  const styleProps = (0, import_react.useMemo)(() => ({
    height: "100vh",
    position: "relative",
    width: "100vw",
    ...style
  }), [style]);
  (0, import_react.useEffect)(() => {
    (async () => {
      const { credentials } = await fetchAuthSession();
      if (credentials && geoConfig) {
        const { region } = geoConfig;
        const { transformRequest: amplifyTransformRequest } = new AmplifyMapLibreRequest(credentials, region);
        setTransformRequest(() => amplifyTransformRequest);
      }
    })();
  }, [geoConfig]);
  return transformRequest ? import_react.default.createElement(map_default, { ...props, mapLib: mapLib ?? import_maplibre_gl5.default, mapStyle: mapStyle ?? ((_a2 = geoConfig == null ? void 0 : geoConfig.maps) == null ? void 0 : _a2.default), ref, style: styleProps, transformRequest, fog: props.fog, terrain: props.terrain }) : null;
});
MapView.displayName = "MapView";

// node_modules/@aws-amplify/ui-react-geo/dist/esm/components/LocationSearch/LocationSearch.mjs
var import_react2 = __toESM(require_react(), 1);
var import_maplibre_gl6 = __toESM(require_maplibre_gl(), 1);

// node_modules/@aws-amplify/ui-react-geo/dist/esm/version.mjs
var VERSION = "2.0.12";

// node_modules/@aws-amplify/ui-react-geo/dist/esm/components/LocationSearch/LocationSearch.mjs
var LOCATION_SEARCH_OPTIONS = {
  maplibregl: import_maplibre_gl6.default,
  marker: { color: "#3FB1CE" },
  popup: true,
  showResultMarkers: { color: "#3FB1CE" },
  showResultsWhileTyping: true
};
var LOCATION_SEARCH_CONTAINER = "geocoder-container";
var LocationSearchControl = ({ position = "top-right", ...props }) => {
  use_control_default(() => createAmplifyGeocoder(props), {
    position
  });
  return null;
};
var LocationSearchStandalone = (props) => {
  const hasMounted = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(() => {
    if (!hasMounted.current) {
      createAmplifyGeocoder(props).addTo(`#${LOCATION_SEARCH_CONTAINER}`);
      hasMounted.current = true;
    }
  }, [props]);
  return import_react2.default.createElement("div", { id: LOCATION_SEARCH_CONTAINER });
};
var LocationSearch = (props) => {
  const { current: map } = useMap();
  useSetUserAgent({
    componentName: "LocationSearch",
    packageName: "react-geo",
    version: VERSION
  });
  if (map) {
    return import_react2.default.createElement(LocationSearchControl, { ...LOCATION_SEARCH_OPTIONS, ...props });
  }
  return import_react2.default.createElement(LocationSearchStandalone, { ...LOCATION_SEARCH_OPTIONS, ...props });
};
export {
  LocationSearch,
  MapView
};
//# sourceMappingURL=@aws-amplify_ui-react-geo.js.map
